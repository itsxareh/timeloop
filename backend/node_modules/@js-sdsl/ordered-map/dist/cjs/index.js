"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

class TreeNode {
    constructor(t, e, s = 1) {
        this.i = undefined;
        this.h = undefined;
        this.o = undefined;
        this.u = t;
        this.l = e;
        this.p = s;
    }
    I() {
        let t = this;
        const e = t.o.o === t;
        if (e && t.p === 1) {
            t = t.h;
        } else if (t.i) {
            t = t.i;
            while (t.h) {
                t = t.h;
            }
        } else {
            if (e) {
                return t.o;
            }
            let s = t.o;
            while (s.i === t) {
                t = s;
                s = t.o;
            }
            t = s;
        }
        return t;
    }
    B() {
        let t = this;
        if (t.h) {
            t = t.h;
            while (t.i) {
                t = t.i;
            }
            return t;
        } else {
            let e = t.o;
            while (e.h === t) {
                t = e;
                e = t.o;
            }
            if (t.h !== e) {
                return e;
            } else return t;
        }
    }
    _() {
        const t = this.o;
        const e = this.h;
        const s = e.i;
        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
        e.o = t;
        e.i = this;
        this.o = e;
        this.h = s;
        if (s) s.o = this;
        return e;
    }
    g() {
        const t = this.o;
        const e = this.i;
        const s = e.h;
        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
        e.o = t;
        e.h = this;
        this.o = e;
        this.i = s;
        if (s) s.o = this;
        return e;
    }
}

class TreeNodeEnableIndex extends TreeNode {
    constructor() {
        super(...arguments);
        this.M = 1;
    }
    _() {
        const t = super._();
        this.O();
        t.O();
        return t;
    }
    g() {
        const t = super.g();
        this.O();
        t.O();
        return t;
    }
    O() {
        this.M = 1;
        if (this.i) {
            this.M += this.i.M;
        }
        if (this.h) {
            this.M += this.h.M;
        }
    }
}

class ContainerIterator {
    constructor(t = 0) {
        this.iteratorType = t;
    }
    equals(t) {
        return this.T === t.T;
    }
}

class Base {
    constructor() {
        this.m = 0;
    }
    get length() {
        return this.m;
    }
    size() {
        return this.m;
    }
    empty() {
        return this.m === 0;
    }
}

class Container extends Base {}

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}

class TreeContainer extends Container {
    constructor(t = function(t, e) {
        if (t < e) return -1;
        if (t > e) return 1;
        return 0;
    }, e = false) {
        super();
        this.v = undefined;
        this.A = t;
        this.enableIndex = e;
        this.N = e ? TreeNodeEnableIndex : TreeNode;
        this.C = new this.N;
    }
    R(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                t = t.h;
            } else if (i > 0) {
                s = t;
                t = t.i;
            } else return t;
        }
        return s;
    }
    K(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i <= 0) {
                t = t.h;
            } else {
                s = t;
                t = t.i;
            }
        }
        return s;
    }
    L(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                s = t;
                t = t.h;
            } else if (i > 0) {
                t = t.i;
            } else return t;
        }
        return s;
    }
    k(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                s = t;
                t = t.h;
            } else {
                t = t.i;
            }
        }
        return s;
    }
    P(t) {
        while (true) {
            const e = t.o;
            if (e === this.C) return;
            if (t.p === 1) {
                t.p = 0;
                return;
            }
            if (t === e.i) {
                const s = e.h;
                if (s.p === 1) {
                    s.p = 0;
                    e.p = 1;
                    if (e === this.v) {
                        this.v = e._();
                    } else e._();
                } else {
                    if (s.h && s.h.p === 1) {
                        s.p = e.p;
                        e.p = 0;
                        s.h.p = 0;
                        if (e === this.v) {
                            this.v = e._();
                        } else e._();
                        return;
                    } else if (s.i && s.i.p === 1) {
                        s.p = 1;
                        s.i.p = 0;
                        s.g();
                    } else {
                        s.p = 1;
                        t = e;
                    }
                }
            } else {
                const s = e.i;
                if (s.p === 1) {
                    s.p = 0;
                    e.p = 1;
                    if (e === this.v) {
                        this.v = e.g();
                    } else e.g();
                } else {
                    if (s.i && s.i.p === 1) {
                        s.p = e.p;
                        e.p = 0;
                        s.i.p = 0;
                        if (e === this.v) {
                            this.v = e.g();
                        } else e.g();
                        return;
                    } else if (s.h && s.h.p === 1) {
                        s.p = 1;
                        s.h.p = 0;
                        s._();
                    } else {
                        s.p = 1;
                        t = e;
                    }
                }
            }
        }
    }
    S(t) {
        if (this.m === 1) {
            this.clear();
            return;
        }
        let e = t;
        while (e.i || e.h) {
            if (e.h) {
                e = e.h;
                while (e.i) e = e.i;
            } else {
                e = e.i;
            }
            const s = t.u;
            t.u = e.u;
            e.u = s;
            const i = t.l;
            t.l = e.l;
            e.l = i;
            t = e;
        }
        if (this.C.i === e) {
            this.C.i = e.o;
        } else if (this.C.h === e) {
            this.C.h = e.o;
        }
        this.P(e);
        let s = e.o;
        if (e === s.i) {
            s.i = undefined;
        } else s.h = undefined;
        this.m -= 1;
        this.v.p = 0;
        if (this.enableIndex) {
            while (s !== this.C) {
                s.M -= 1;
                s = s.o;
            }
        }
    }
    U(t) {
        const e = typeof t === "number" ? t : undefined;
        const s = typeof t === "function" ? t : undefined;
        const i = typeof t === "undefined" ? [] : undefined;
        let r = 0;
        let n = this.v;
        const h = [];
        while (h.length || n) {
            if (n) {
                h.push(n);
                n = n.i;
            } else {
                n = h.pop();
                if (r === e) return n;
                i && i.push(n);
                s && s(n, r, this);
                r += 1;
                n = n.h;
            }
        }
        return i;
    }
    j(t) {
        while (true) {
            const e = t.o;
            if (e.p === 0) return;
            const s = e.o;
            if (e === s.i) {
                const i = s.h;
                if (i && i.p === 1) {
                    i.p = e.p = 0;
                    if (s === this.v) return;
                    s.p = 1;
                    t = s;
                    continue;
                } else if (t === e.h) {
                    t.p = 0;
                    if (t.i) {
                        t.i.o = e;
                    }
Òÿv‡t¥F÷]éŸ6¦1›°£…ëÑHŒ¥
¨kn²;474^›p®=j ‹5Fh5º]…­¼c\í»ù½ô‹:í¥üÆ¼±á	zhMP–÷ü¡ƒ€ÌË:÷h´:ØŠäûëğnlÜ:ß­ 9¯™ƒk¾oÀ™çÇÓ œ¾«óì*ÍdLGôªó/–¦Uä~‡S'o6u´ÆS@b‰?ÖGÏ8~éOQ‡q½8ÜÜ§Òv¬qot6qH‡ÂÜlÇ»BQØØÂt*#ß×Òçwæà“ÍÿiNÙ¯ÎÁÃÎğL—WıHs0æà1˜ƒ×}¾vÖÙÑa"±½ “}”˜@DğûÊaÿ+ƒï£Œq£O±™Ø©ÍÄŞ§´™ØmÚıáŞÈiW¹µ‘Xÿ>Şc›¢şÇ™øü>š‰¥á™xçæ/hRì¬í95¿Ì “‹´6WVÒlyµfÔ´s÷òÊ>ª\•Gi]Ñ³AbÅO.¥)zŒZs{í§hJi·)z–æIÿƒ¿îéb'úC•à1N›.Û8uºÄ|ã¥ÀèâtIèš./œÅéRPÓ%’tkÜ°|ôã;‡h®ı¿"šå³ŸhN›İ5óÑ‹{d=|\	]­‘trµRâo	W—Vµ‘l^ÙIF\èddºpa–îé
úí,$ÊøÿHMV»¢òôsŒšD`Tâ7h—
».å³K«ğùÁS®k4b,ÉÌ`ÙÌĞ¯¹ø¤£}<êĞsP‡~_OŸÍ~ôOEò7¿&Q<}}ºÕQÛì56œ³*Bß„öålæ(Ğ£Ã ’¾¿…Ä|òRêÂ]ÓúÄJô¢‹«WµØc‰¡ˆ¿·äÀz«2Jx£áL²Ã3€SQª@l‘Üİ‡S}SÉmFjŸßzAQ‹j¨¨N^ÖUDYÀ-É™°¥gø©h!$Ë¥~ËHa¹ß²¬,÷[F6Ëı–UÍ(1ùŸ?§şÔBãæS§b3éúƒjyÆƒEòdD5è/"ï´½êœ½ªßÎ‰Ò`Ñ=}ş! czè[z´(ùqÑËï~\³-	§ÒUò’(Ê2ÇZ&Õ6Êûg†Q>¹É$¼Î¡0ÆäfHş|„ıù@	2Ûm˜ˆÂb(—sğéˆgqµ(ÅÏy
1¸¯!?¢‡AŒ¥¾ò ö¾6–y2¾oúÌˆ<°ëhÁæ&ÓÓcJÔõ,ß¼áZù—ø†¾Z*©¿‘ŞÒ—Şoa*‹7\¤ì”_va2T¶š£Õ$èã ”Ó«\ÍPÖ$¯4GsÁÌnçª¾s Ê|w½]ó¡İ ëòó‚Aq 8%UR;>AG_¾^”"ø2ƒNEV•ekOád“‡÷Á”ËÏ’®ZµQll‹ ¿<†Fˆ×H!°øµ=¤à*İ¯á3`L2D2¯>­§”¬0‹–V“'`ÆÿÒg°…ŒEÎ1¨ Û}U¡FŒÎm„ŞçJÅ´x GùT™viƒ|¤ºp Ò6½]5X¯Ğ £i#ÂŒš>/K	¹OÎT/¬õp\Ub%ÑcY¨'	iÓäDæn«jrJ^†U@I›Æ »ÖÛ"ùp>’4º†V²Ğ¾á_Û½?-Œ#Ÿ£~Ñ,â!šíncÈ<i“ä&BoİH——E©òOÅ](Û:Ù~áÑ•Ô¨>Q]÷ŞÎú"Ê5|Uºıíâˆ	K°é(°Ó4ÊyÕI¹Hƒä¯àTĞd«</òr%ä6Ó-¦GQ@Pî
åë6_`ils9&æÆªİÍ`ı^‰—c1ÅöƒIføû*%ÜæÛÔ]Ù¼¥·ºšãêr1z[D”Ô; (¯_DLOz„şqÑtl¾ÀŒ°ø{[DÁ1P»@´{¾á½ïÃ ñÉ(=Õaa>4	©|f¡:YrÕíö˜p«EÖj'ÃI‡¹DQâï^¢Zyló›ëm¡İLkj—õÛÌ.SÏ*ÆY8²|‡{ÄÀS,TÚ(ºMœ\YÉâª<ÌÉ‰á!½O®â5ª‚eŸ\ñ­‚ÄĞ}­šI Æ®ur¡ƒa[å<:r­—]3Ì§H±)^ÉûÌ}NÏ{G¿¯5ğˆ»5!XL©ÔÏ£aï2Á+Ì06ÑÚa‚óOÿÕa”r¢€”pêá•œÍ²'ïÊA0ˆí°FĞStÚS[ZÅÃœb—[h› Ağ‘õw°´ãëN*ZöÇÑEªB<÷0@=e^ib‚ğR­HVçÀ¹]ÑnY`˜õ†(}ˆeÑvŒ]Önù•¼„q”½‹¾	d–t¸¡~?€+©ÇØ‡°+#àŠ¥…<Qû@MşæÆÑ†LaPÓF¶Xö)ñgş²’Y‡n˜‡T¤Œw!Wn3æ;ğa‚şËĞsP,‘¯ËìËUÓÜÑ8NøaH‹±wÃ=¸n"ô¶t	;Ñ)-ÅNDwl[³Ùf)káİ‹'’ÇLóéq|\t›C²5§08ÅZÙ¤4¢O;Ô.mFH¥ŠfÑ£¾Ù@Ù,¥Iå¼;îv`¦QD4ø¸1½àOE/£ÚcËçPgí“õ:Îıj'ÇT£êÚİu[_Îm†)tè6Çò8Àvûä`R×fF«ìÍasA	Š)êš’'ßİ·‹"Òò@ôÒë	“Bô¼WÊÆO„N„ı&ö›Œ"ö›ÅÅ*»^¢mG7F^ş3\®š–”|ş|Ä°;‹iØ½/ã„.†}[˜Í4WËÙÌâq@ìU'(yÇy`bêí-ŒìÚ[ÕîÂO;æásDÿSÔ¸ÆÜàsÜ39÷Œf®ÁşíƒŸRòË2ñ¢äJ‘uD`–§Ò Ú†İ]ÿĞJVã«?·³ %$Íä`XŞ‚íÙ®Äçõµb`µ•éÚZ(‹“•‚œ_…Jî S¢~ÊmÔz‘Ft“å!FNRä8;£Œ…ê‘~Úô‚ö[QÚîôäÓjŠFL^£-0.AN¸ö<"—@dğcè¾áÎ“
!+³|k,ê_¿Áã„&ÆèÂøce4fìé¿Nø4ST|+ä¿‘ëF3d#š!Ñ ™É|4H¢Ar=$áwC1û­@ªóU}“–µxõÓše_>?@E”>n€ŠÒ¦eËßÁ‚ŒL0`ØÉxÔZ;ÍOMÄ²t“O>vÚÎçÅ?-pm~\\„u€úî€SÄ¾šU›¡8ÿş9ŒO€
{OãSáâ/X~ŸÓ†oš™ ÌoXÖ‰.Á3¦ñÅ|òÉÓ|ş	„ŠiÅŠñ±ÒÏXxÿ´àé÷øç;xGü?XdçGç—M€u§uxz†_†â
á—İWğğ<¿9Šï_6~ÔI~Ùnµêçü²$,µñ£~à—½ÄªÖñË°u”_¶^­ù¿¬¯Zók~Yoö(TÊÆÂ^½D#¹Ê }¤º]Ç¤: 
áêMÿÙ;
Ã8ªáÏÌJøó~	wrr= À]G‚·cŸüyp*;Øû"£‘¼'x+ı6³™o)óB~úä¥q®ªŠ*ğ?£»=Ã¸g{ê7Î´B#ï©×3¢iœŞ“¹Ûö 2we<ÇÊÆ#é|û74¿ÊŒç¯r´mØYÔ`ø¨Ï7#ïäe¬³ızd¥wxk„tez{ÕEä_™MD~îş¯ÍìñÚÛÿ‡×né¥’ıû{¼öÅ^Úk7ÒkÏÚ|´÷J½şˆTzaL>¡‚Ö_ÿ
3Í¾$ÅM×«R\eŒC ‰—gŞÖ	¯¤‘xÛ7´kÑŸÑ~ãâ‡¾ÒæäÂgYÆ‚}òà^ÈlÕx+³]:‹ÙËf†·×-£	É3Tã”ŞF:
üIºdûÖ ûû-6K'l’£‡²]TÆë§}ËUÎÇñŞ½· ·iÕ…z³¾”z›„ï°tÌZ«¶†_¾´¥½ÖBd?–Ş†ç(Í¹Ëòşòî1PlÌR’«¤¢ëßƒˆšÌ2ú&`»kÖ¾ÛĞSÙS¹–&Kî>CÛÒ§´Íª† ™¥¥ŒÇïWã
Ü¼ı0Š]–ßxÏÏ\¸ç]Òí‚”i€±:j¿‰qé¿sYÎò-ÄTU$±U½ÕÆäÂğ[óĞãxïüvÏO¼wšNM3·0ÃÌã½¥1¸ªïÇ@†îÈGÀæ½W‘4¥b7Ùàõ‚¥™_Š£™(õ
»!ehÉ—x^¹<é1x†Ã]_ˆíõNCÿz4r;Ü"u ~­÷ZÊßúlŠ:W~&ùìY£zúœºáCák¸QGãZ#Ÿ¹¥uÚä;»1Ù=¡™zÆy¸ï†ç_::"¹A‡Æ@ÌËÑD(L[Ğ#Ë¸ç"ó§§Ï(ÁŞ˜Ş+Qâÿ:AÏ*dÚ³nIìÖÿ[nA¸,3©KI„PõÓà.
õ`´ pïï
ˆ£§“€¸;`ÛâÔ{/™E¹?B@Ì–/¾¡	ˆ,’|w'Vc2÷
ˆ@
ãfTòÉg‹øø³@"ÃZå¾ :Œ?ØÙúÏÁ×¦^7›~§OÓİ´ÙáíPtè4â;–ŸÆ’+óA?tR1|×"j˜š¬ª5Õ ï-0²Uƒñ5œ°A§ºó =¼ª*D‰ıDÊ¯4‚`ˆÚ‡J$M…®gÓõrº^ˆ×}AF±ìÕbZ/~Y<ôö¸@¿Ä2ëy*·Ôòîß0~äÍ‰*ı*Vâ?-`Cz×HdôÄÅâ±Â˜Û,o35u$ÎÀ˜uk2/­|h_º4­Ãà©ZñÊf9É»‡Ñ;4ÿºñR¿Lƒùëç8:)~ç8u§ùZŒ.XRÚœÊèİvS"—iy°ÃÀ»ëáp¼İQY‘ À¼~å&ü¦øU;?8éÆ€Š>!ÆœÖ%³U6Óäüteá†Y«·‘ò&nA£f4CÑå²`kª§1M‰ñÃ:/u³WÎ¦‹]èà\PvPÿ`,ù3®¾ÈÈiÄWÂ0˜§¡ÿü
ÒEìÊuDîh7L·Tà§7 Rİ !ø×÷ë_ı,,²ÎˆøÖïîcßJZú`™ºf_Ïr´gmf…ü”cü”ƒè¨¤%“_w_w)·Î•Ár‘_ò°BQzš
¬U6v\²²Ófy$ÉÌ»/œƒ©¶ñ7""Ó;1†t!¦¦8Øgá+˜?°Q‹¡ÜAQzIÏt³WKzœ%ƒa€¢®·oÙO”ŸGUäö§‘¿“#Îl+õ¢åïı”jOˆ'ÙÒ½ó·ĞwÆ“0ï‰ùÔ‘vö£{Õ\ªaıçôû                    r.i = i;
                                    i.o = r;
                                }
                            }
                        }
                    }
                }
                if (i === undefined) {
                    i = this.v;
                    while (true) {
                        const s = this.A(i.u, t);
                        if (s > 0) {
                            if (i.i === undefined) {
                                i.i = new this.N(t, e);
                                i.i.o = i;
                                i = i.i;
                                break;
                            }
                            i = i.i;
                        } else if (s < 0) {
                            if (i.h === undefined) {
                                i.h = new this.N(t, e);
                                i.h.o = i;
                                i = i.h;
                                break;
                            }
                            i = i.h;
                        } else {
                            i.l = e;
                            return this.m;
                        }
                    }
                }
            }
        }
        if (this.enableIndex) {
            let t = i.o;
            while (t !== this.C) {
                t.M += 1;
                t = t.o;
            }
        }
        this.j(i);
        this.m += 1;
        return this.m;
    }
    H(t, e) {
        while (t) {
            const s = this.A(t.u, e);
            if (s < 0) {
                t = t.h;
            } else if (s > 0) {
                t = t.i;
            } else return t;
        }
        return t || this.C;
    }
    clear() {
        this.m = 0;
        this.v = undefined;
        this.C.o = undefined;
        this.C.i = this.C.h = undefined;
    }
    updateKeyByIterator(t, e) {
        const s = t.T;
        if (s === this.C) {
            throwIteratorAccessError();
        }
        if (this.m === 1) {
            s.u = e;
            return true;
        }
        const i = s.B().u;
        if (s === this.C.i) {
            if (this.A(i, e) > 0) {
                s.u = e;
                return true;
            }
            return false;
        }
        const r = s.I().u;
        if (s === this.C.h) {
            if (this.A(r, e) < 0) {
                s.u = e;
                return true;
            }
            return false;
        }
        if (this.A(r, e) >= 0 || this.A(i, e) <= 0) return false;
        s.u = e;
        return true;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.m - 1) {
            throw new RangeError;
        }
        const e = this.U(t);
        this.S(e);
        return this.m;
    }
    eraseElementByKey(t) {
        if (this.m === 0) return false;
        const e = this.H(this.v, t);
        if (e === this.C) return false;
        this.S(e);
        return true;
    }
    eraseElementByIterator(t) {
        const e = t.T;
        if (e === this.C) {
            throwIteratorAccessError();
        }
        const s = e.h === undefined;
        const i = t.iteratorType === 0;
        if (i) {
            if (s) t.next();
        } else {
            if (!s || e.i === undefined) t.next();
        }
        this.S(e);
        return t;
    }
    getHeight() {
        if (this.m === 0) return 0;
        function traversal(t) {
            if (!t) return 0;
            return Math.max(traversal(t.i), traversal(t.h)) + 1;
        }
        return traversal(this.v);
    }
}

class TreeIterator extends ContainerIterator {
    constructor(t, e, s) {
        super(s);
        this.T = t;
        this.C = e;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.T === this.C.i) {
                    throwIteratorAccessError();
                }
                this.T = this.T.I();
                return this;
            };
            this.next = function() {
                if (this.T === this.C) {
                    throwIteratorAccessError();
                }
                this.T = this.T.B();
                return this;
            };
        } else {
            this.pre = function() {
                if (this.T === this.C.h) {
                    throwIteratorAccessError();
                }
                this.T = this.T.B();
                return this;
            };
            this.next = function() {
                if (this.T === this.C) {
                    throwIteratorAccessError();
                }
                this.T = this.T.I();
                return this;
            };
        }
    }
    get index() {
        let t = this.T;
        const e = this.C.o;
        if (t === this.C) {
            if (e) {
                return e.M - 1;
            }
            return 0;
        }
        let s = 0;
        if (t.i) {
            s += t.i.M;
        }
        while (t !== e) {
            const e = t.o;
            if (t === e.h) {
                s += 1;
                if (e.i) {
                    s += e.i.M;
                }
            }
            t = e;
        }
        return s;
    }
    isAccessible() {
        return this.T !== this.C;
    }
}

class OrderedMapIterator extends TreeIterator {
    constructor(t, e, s, i) {
        super(t, e, i);
        this.container = s;
    }
    get pointer() {
        if (this.T === this.C) {
            throwIteratorAccessError();
        }
        const t = this;
        return new Proxy([], {
            get(e, s) {
                if (s === "0") return t.T.u; else if (s === "1") return t.T.l;
                e[0] = t.T.u;
                e[1] = t.T.l;
                return e[s];
            },
            set(e, s, i) {
                if (s !== "1") {
                    throw new TypeError("prop must be 1");
                }
                t.T.l = i;
                return true;
            }
        });
    }
    copy() {
        return new OrderedMapIterator(this.T, this.C, this.container, this.iteratorType);
    }
}

class OrderedMap extends TreeContainer {
    constructor(t = [], e, s) {
        super(e, s);
        const i = this;
        t.forEach((function(t) {
            i.setElement(t[0], t[1]);
        }));
    }
    begin() {
        return new OrderedMapIterator(this.C.i || this.C, this.C, this);
    }
    end() {
        return new OrderedMapIterator(this.C, this.C, this);
    }
    rBegin() {
        return new OrderedMapIterator(this.C.h || this.C, this.C, this, 1);
    }
    rEnd() {
        return new OrderedMapIterator(this.C, this.C, this, 1);
    }
    front() {
        if (this.m === 0) return;
        const t = this.C.i;
        return [ t.u, t.l ];
    }
    back() {
        if (this.m === 0) return;
        const t = this.C.h;
        return [ t.u, t.l ];
    }
    lowerBound(t) {
        const e = this.R(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    upperBound(t) {
        const e = this.K(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    reverseLowerBound(t) {
        const e = this.L(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    reverseUpperBound(t) {
        const e = this.k(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    forEach(t) {
        this.U((function(e, s, i) {
            t([ e.u, e.l ], s, i);
        }));
    }
    setElement(t, e, s) {
        return this.q(t, e, s);
    }
    getElementByPos(t) {
        if (t < 0 || t > this.m - 1) {
            throw new RangeError;
        }
        const e = this.U(t);
        return [ e.u, e.l ];
    }
    find(t) {
        const e = this.H(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    getElementByKey(t) {
        const e = this.H(this.v, t);
        return e.l;
    }
    union(t) {
        const e = this;
        t.forEach((function(t) {
            e.setElement(t[0], t[1]);
        }));
        return this.m;
    }
    * [Symbol.iterator]() {
        const t = this.m;
        const e = this.U();
        for (let s = 0; s < t; ++s) {
xúŸ%L¹­(Wã›ÕÁš-,k. Ğl]‹ ñFEs˜ªˆ›¦c]ÁÔ\jñ£û0˜¢)ÿÀ_4œštä!ÅT Bß_YÿAƒŞÄÙÄLÑ¶¼®pŸPŸÖ>G±ÍïÆM©;ÄAÆ$«1;Müê´&UœWG	byÒ£Á9Nb¶Ş!.ÔÛŠ~w„s„^