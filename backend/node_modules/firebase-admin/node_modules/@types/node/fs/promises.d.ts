/**
 * The `fs/promises` API provides asynchronous file system methods that return
 * promises.
 *
 * The promise APIs use the underlying Node.js threadpool to perform file
 * system operations off the event loop thread. These operations are not
 * synchronized or threadsafe. Care must be taken when performing multiple
 * concurrent modifications on the same file or data corruption may occur.
 * @since v10.0.0
 */
declare module "fs/promises" {
    import { Abortable } from "node:events";
    import { Stream } from "node:stream";
    import { ReadableStream } from "node:stream/web";
    import {
        BigIntStats,
        BigIntStatsFs,
        BufferEncodingOption,
        constants as fsConstants,
        CopyOptions,
        Dir,
        Dirent,
        GlobOptions,
        GlobOptionsWithFileTypes,
        GlobOptionsWithoutFileTypes,
        MakeDirectoryOptions,
        Mode,
        ObjectEncodingOptions,
        OpenDirOptions,
        OpenMode,
        PathLike,
        ReadPosition,
        ReadStream,
        ReadVResult,
        RmDirOptions,
        RmOptions,
        StatFsOptions,
        StatOptions,
        Stats,
        StatsFs,
        TimeLike,
        WatchEventType,
        WatchOptions,
        WriteStream,
        WriteVResult,
    } from "node:fs";
    import { Interface as ReadlineInterface } from "node:readline";
    interface FileChangeInfo<T extends string | Buffer> {
        eventType: WatchEventType;
        filename: T | null;
    }
    interface FlagAndOpenMode {
        mode?: Mode | undefined;
        flag?: OpenMode | undefined;
    }
    interface FileReadResult<T extends NodeJS.ArrayBufferView> {
        bytesRead: number;
        buffer: T;
    }
    interface FileReadOptions<T extends NodeJS.ArrayBufferView = Buffer> {
        /**
         * @default `Buffer.alloc(0xffff)`
         */
        buffer?: T;
        /**
         * @default 0
         */
        offset?: number | null;
        /**
         * @default `buffer.byteLength`
         */
        length?: number | null;
        position?: ReadPosition | null;
    }
    interface CreateReadStreamOptions extends Abortable {
        encoding?: BufferEncoding | null | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        end?: number | undefined;
        highWaterMark?: number | undefined;
    }
    interface CreateWriteStreamOptions {
        encoding?: BufferEncoding | null | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        highWaterMark?: number | undefined;
        flush?: boolean | undefined;
    }
    // TODO: Add `EventEmitter` close
    interface FileHandle {
        /**
         * The numeric file descriptor managed by the {FileHandle} object.
         * @since v10.0.0
         */
        readonly fd: number;
        /**
         * Alias of `filehandle.writeFile()`.
         *
         * When operating on file handles, the mode cannot be changed from what it was set
         * to with `fsPromises.open()`. Therefore, this is equivalent to `filehandle.writeFile()`.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        appendFile(
            data: string | Uint8Array,
            options?:
                | (ObjectEncodingOptions & Abortable)
                | BufferEncoding
                | null,
        ): Promise<void>;
        /**
         * Changes the ownership of the file. A wrapper for [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html).
         * @since v10.0.0
         * @param uid The file's new owner's user id.
         * @param gid The file's new group's group id.
         * @return Fulfills with `undefined` upon success.
         */
        chown(uid: number, gid: number): Promise<void>;
        /**
         * Modifies the permissions on the file. See [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html).
         * @since v10.0.0
         * @param mode the file mode bit mask.
         * @return Fulfills with `undefined` upon success.
         */
        chmod(mode: Mode): Promise<void>;
        /**
         * Unlike the 16 KiB default `highWaterMark` for a `stream.Readable`, the stream
         * returned by this method has a default `highWaterMark` of 64 KiB.
         *
         * `options` can include `start` and `end` values to read a range of bytes from
         * the file instead of the entire file. Both `start` and `end` are inclusive and
         * start counting at 0, allowed values are in the
         * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `start` is
         * omitted or `undefined`, `filehandle.createReadStream()` reads sequentially from
         * the current file position. The `encoding` can be any one of those accepted by `Buffer`.
         *
         * If the `FileHandle` points to a character device that only supports blocking
         * reads (such as keyboard or sound card), read operations do not finish until data
         * is available. This can prevent the process from exiting and the stream from
         * closing naturally.
         *
         * By default, the stream will emit a `'close'` event after it has been
         * destroyed.  Set the `emitClose` option to `false` to change this behavior.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const fd = await open('/dev/input/event0');
         * // Create a stream from some character device.
         * const stream = fd.createReadStream();
         * setTimeout(() => {
         *   stream.close(); // This may not close the stream.
         *   // Artificially marking end-of-stream, as if the underlying resource had
         *   // indicated end-of-file by itself, allows the stream to close.
         *   // This does not cancel pending read operations, and if there is such an
         *   // operation, the process may still not be able to exit successfully
         *   // until it finishes.
         *   stream.push(null);
         *   stream.read(0);
         * }, 100);
         * ```
         *
         * If `autoClose` is false, then the file descriptor won't be closed, even if
         * there's an error. It is the application's responsibility to close it and make
         * sure there's no file descriptor leak. If `autoClose` is set to true (default
         * behavior), on `'error'` or `'end'` the file descriptor will be closed
         * automatically.
         *
         * An example to read the last 10 bytes of a file which is 100 bytes long:
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const fd = await open('sample.txt');
         * fd.createReadStream({ start: 90, end: 99 });
         * ```
         * @since v16.11.0
         */
        createReadStream(options?: CreateReadStreamOptions): ReadStream;
        /**
         * `options` may also include a `start` option to allow writing data at some
         * position past the beginning of the file, allowed values are in the
         * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
         * replacing it may require the `flags` `open` option to be set to `r+` rather than
         * the default `r`. The `encoding` can be any one of those accepted by `Buffer`.
         *
         * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
         * then the file descriptor won't be closed, even if there's an error.
         * It is the application's responsibility to close it and make sure there's no
         * file descriptor leak.
         *
         * By default, the stream will emit a `'close'` event after it has been
         * destroyed.  Set the `emitClose` option to `false` to change this behavior.
         * @since v16.11.0
         */
        createWriteStream(options?: CreateWriteStreamOptions): WriteStream;
        /**
         * Forces all currently queued I/O operations associated with the file to the
         * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details.
         *
         * Unlike `filehandle.sync` this method does not flush modified metadata.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        datasync(): Promise<void>;
        /**
         * Request that all data for the open file descriptor is flushed to the storage
         * device. The specific implementation is operating system and device specific.
         * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        sync(): Promise<void>;
        /**
         * Reads data from the file and stores that in the given buffer.
         *
         * If the file is not modified concurrently, the end-of-file is reached when the
         * number of bytes read is zero.
         * @since v10.0.0
         * @param buffer A buffer that will be filled with the file data read.
         * @param offset The location in the buffer at which to start filling.
         * @param length The number of bytes to read.
         * @param position The location where to begin reading data from the file. If `null`, data will be read from the current file position, and the position will be updated. If `position` is an
         * integer, the current file position will remain unchanged.
         * @return Fulfills upon success with an object with two properties:
         */
        read<T extends NodeJS.ArrayBufferView>(
            buffer: T,
            offset?: number | null,
            length?: number | null,
            position?: ReadPosition | null,
        ): Promise<FileReadResult<T>>;
        read<T extends NodeJS.ArrayBufferView = Buffer>(
            buffer: T,
            options?: FileReadOptions<T>,
        ): Promise<FileReadResult<T>>;
        read<T extends NodeJS.ArrayBufferView = Buffer>(options?: FileReadOptions<T>): Promise<FileReadResult<T>>;
        /**
         * Returns a byte-oriented `ReadableStream` that may be used to read the file's
         * contents.
         *
         * An error will be thrown if this method is called more than once or is called
         * after the `FileHandle` is closed or closing.
         *
         * ```js
         * import {
         *   open,
         * } from 'node:fs/promises';
         *
         * const file = await open('./some/file/to/read');
         *
         * for await (const chunk of file.readableWebStream())
         *   console.log(chunk);
         *
         * await file.close();
         * ```
         *
         * While the `ReadableStream` will read the file to completion, it will not
         * close the `FileHandle` automatically. User code must still call the`fileHandle.close()` method.
         * @since v17.0.0
         * @experimental
         */
        readableWebStream(): ReadableStream;
        /**
         * Asynchronously reads the entire contents of a file.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support reading.
         *
         * If one or more `filehandle.read()` calls are made on a file handle and then a `filehandle.readFile()` call is made, the data will be read from the current
         * position till the end of the file. It doesn't always read from the beginning
         * of the file.
         * @since v10.0.0
         * @return Fulfills upon a successful read with the contents of the file. If no encoding is specified (using `options.encoding`), the data is returned as a {Buffer} object. Otherwise, the
         * data will be a string.
         */
        readFile(
            options?:
                | ({ encoding?: null | undefined } & Abortable)
                | null,
        ): Promise<Buffer>;
        /**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         */
        readFile(
            options:
                | ({ encoding: BufferEncoding } & Abortable)
                | BufferEncoding,
        ): Promise<string>;
        /**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         */
        readFile(
            options?:
                | (ObjectEncodingOptions & Abortable)
                | BufferEncoding
                | null,
        ): Promise<string | Buffer>;
        /**
         * Convenience method to create a `readline` interface and stream over the file.
         * See `filehandle.createReadStream()` for the options.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const file = await open('./some/file/to/read');
         *
         * for await (const line of file.readLines()) {
         *   console.log(line);
         * }
         * ```
         * @since v18.11.0
         */
        readLines(options?: CreateReadStreamOptions): ReadlineInterface;
        /**
         * @since v10.0.0
         * @return Fulfills with an {fs.Stats} for the file.
         */
        stat(
            opts?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        stat(
            opts: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        stat(opts?: StatOptions): Promise<Stats | BigIntStats>;
        /**
         * Truncates the file.
         *
         * If the file was larger than `len` bytes, only the first `len` bytes will be
         * retained in the file.
         *
         * The following example retains only the first four bytes of the file:
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * let filehandle = null;
         * try {
         *   filehandle = await open('temp.txt', 'r+');
         *   await filehandle.truncate(4);
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         *
         * If the file previously was shorter than `len` bytes, it is extended, and the
         * extended part is filled with null bytes (`'\0'`):
         *
         * If `len` is negative then `0` will be used.
         * @since v10.0.0
         * @param [len=0]
         * @return Fulfills with `undefined` upon success.
         */
        truncate(len?: number): Promise<void>;
        /**
         * Change the file system timestamps of the object referenced by the `FileHandle` then fulfills the promise with no arguments upon success.
         * @since v10.0.0
         */
        utimes(atime: TimeLike, mtime: TimeLike): Promise<void>;
        /**
         * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an
         * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an
         * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.
         * The promise is fulfilled with no arguments upon success.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support writing.
         *
         * It is unsafe to use `filehandle.writeFile()` multiple times on the same file
         * without waiting for the promise to be fulfilled (or rejected).
         *
         * If one or more `filehandle.write()` calls are made on a file handle and then a`filehandle.writeFile()` call is made, the data will be written from the
         * current position till the end of the file. It doesn't always write from the
         * beginning of the file.
         * @since v10.0.0
         */
        writeFile(
            data: string | Uint8Array,
            options?:
                | (ObjectEncodingOptions & Abortable)
                | BufferEncoding
                | null,
        ): Promise<void>;
        /**
         * Write `buffer` to the file.
         *
         * The promise is fulfilled with an object containing two properties:
         *
         * It is unsafe to use `filehandle.write()` multiple times on the same file
         * without waiting for the promise to be fulfilled (or rejected). For this
         * scenario, use `filehandle.createWriteStream()`.
         *
         * On Linux, positional writes do not work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * @since v10.0.0
         * @param offset The start position from within `buffer` where the data to write begins.
         * @param [length=buffer.byteLength - offset] The number of bytes from `buffer` to write.
         * @param [position='null'] The offset from the beginning of the file where the data from `buffer` should be written. If `position` is not a `number`, the data will be written at the current
         * position. See the POSIX pwrite(2) documentation for more detail.
         */
        write<TBuffer extends Uint8Array>(
            buffer: TBuffer,
            offset?: number | null,
            length?: number | null,
            position?: number | null,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        write<TBuffer extends Uint8Array>(
            buffer: TBuffer,
            options?: { offset?: number; length?: number; position?: number },
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        write(
            data: string,
            position?: number | null,
            encoding?: BufferEncoding | null,
        ): Promise<{
            bytesWritten: number;
            buffer: string;
        }>;
        /**
         * Write an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s to the file.
         *
         * The promise is fulfilled with an object containing a two properties:
         *
         * It is unsafe to call `writev()` multiple times on the same file without waiting
         * for the promise to be fulfilled (or rejected).
         *
         * On Linux, positional writes don't work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * @since v12.9.0
         * @param [position='null'] The offset from the beginning of the file where the data from `buffers` should be written. If `position` is not a `number`, the data will be written at the current
         * position.
         */
        writev(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<WriteVResult>;
        /**
         * Read from a file and write to an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s
         * @since v13.13.0, v12.17.0
         * @param [position='null'] The offset from the beginning of the file where the data should be read from. If `position` is not a `number`, the data will be read from the current position.
         * @return Fulfills upon success an object containing two properties:
         */
        readv(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<ReadVResult>;
        /**
         * Closes the file handle after waiting for any pending operation on the handle to
         * complete.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * let filehandle;
         * try {
         *   filehandle = await open('thefile.txt', 'r');
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        close(): Promise<void>;
        /**
         * An alias for {@link FileHandle.close()}.
         * @since v20.4.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
    const constants: typeof fsConstants;
    /**
     * Tests a user's permissions for the file or directory specified by `path`.
     * The `mode` argument is an optional integer that specifies the accessibility
     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * If the accessibility check is successful, the promise is fulfilled with no
     * value. If any of the accessibility checks fail, the promise is rejected
     * with an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object. The following example checks if the file`/etc/passwd` can be read and
     * written by the current process.
     *
     * ```js
     * import { access, constants } from 'node:fs/promises';
     *
     * try {
     *   await access('/etc/passwd', constants.R_OK | constants.W_OK);
     *   console.log('can access');
     * } catch {
     *   console.error('cannot access');
     * }
     * ```
     *
     * Using `fsPromises.access()` to check for the accessibility of a file before
     * calling `fsPromises.open()` is not recommended. Doing so introduces a race
     * condition, since other processes may change the file's state between the two
     * calls. Instead, user code should open/read/write the file directly and handle
     * the error raised if the file is not accessible.
     * @since v10.0.0
     * @param [mode=fs.constants.F_OK]
     * @return Fulfills with `undefined` upon success.
     */
    function access(path: PathLike, mode?: number): Promise<void>;
    /**
     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists.
     *
     * No guarantees are made about the atomicity of the copy operation. If an
     * error occurs after the destination file has been opened for writing, an attempt
     * will be made to remove the destination.
     *
     * ```js
     * import { copyFile, constants } from 'node:fs/promises';
     *
     * try {
     *   await copyFile('source.txt', 'destination.txt');
     *   console.log('source.txt was copied to destination.txt');
     * } catch {
     *   console.error('The file could not be copied');
     * }
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * try {
     *   await copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
     *   console.log('source.txt was copied to destination.txt');
     * } catch {
     *   console.error('The file could not be copied');
     * }
     * ```
     * @since v10.0.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] Optional modifiers that specify the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g.
     * `fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`)
     * @return Fulfills with `undefined` upon success.
     */
    function copyFile(src: PathLike, dest: PathLike, mode?: number): Promise<void>;
    /**
     * Opens a `FileHandle`.
     *
     * Refer to the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more detail.
     *
     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
     * @since v10.0.0
     * @param [flags='r'] See `support of file system `flags``.
     * @param [mode=0o666] Sets the file mode (permission and sticky bits) if the file is created.
     * @return Fulfills with a {FileHandle} object.
     */
    function open(path: PathLike, flags?: string | number, mode?: Mode): Promise<FileHandle>;
    /**
     * Renames `oldPath` to `newPath`.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;
    /**
     * Truncates (shortens or extends the length) of the content at `path` to `len` bytes.
     * @since v10.0.0
     * @param [len=0]
     * @return Fulfills with `undefined` upon success.
     */
    function truncate(path: PathLike, len?: number): Promise<void>;
    /**
     * Removes the directory identified by `path`.
     *
     * Using `fsPromises.rmdir()` on a file (not a directory) results in the
     * promise being rejected with an `ENOENT` error on Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use `fsPromises.rm()` with options `{ recursive: true, force: true }`.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;
    /**
     * Removes files and directories (modeled on the standard POSIX `rm` utility).
     * @since v14.14.0
     * @return Fulfills with `undefined` upon success.
     */
    function rm(path: PathLike, options?: RmOptions): Promise<void>;
    /**
     * Asynchronously creates a directory.
     *
     * The optional `options` argument can be an integer specifying `mode` (permission
     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fsPromises.mkdir()` when `path` is a directory
     * that exists results in a
     * rejection only when `recursive` is false.
     *
     * ```js
     * import { mkdir } from 'node:fs/promises';
     *
     * try {
     *   const projectFolder = new URL('./test/project/', import.meta.url);
     *   const createDir = await mkdir(projectFolder, { recursive: true });
     *
     *   console.log(`created ${createDir}`);
     * } catch (err) {
     *   console.error(err.message);
     * }
     * ```
     * @since v10.0.0
     * @return Upon success, fulfills with `undefined` if `recursive` is `false`, or the first directory path created if `recursive` is `true`.
     */
    function mkdir(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
    ): Promise<string | undefined>;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdir(
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null,
    ): Promise<void>;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdir(path: PathLike, options?: Mode | MakeDirectoryOptions | null): Promise<string | undefined>;
    /**
     * Reads the contents of a directory.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames. If the `encoding` is set to `'buffer'`, the filenames returned
     * will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the returned array will contain `fs.Dirent` objects.
     *
     * ```js
     * import { readdir } from 'node:fs/promises';
     *
     * try {
     *   const files = await readdir(path);
     *   for (const file of files)
     *     console.log(file);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     * @since v10.0.0
     * @return Fulfills with an array of the names of the files in the directory excluding `'.'` and `'..'`.
     */
    function readdir(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): Promise<string[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
    ): Promise<Buffer[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): Promise<string[] | Buffer[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    function readdir(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Promise<Dirent[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a directory. If a URL is provided, it must use the `file:` protocol.
     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
     */
    function readdir(
        path: PathLike,
        options: {
            encoding: "buffer";
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Promise<Dirent<Buffer>[]>;
    /**
     * Reads the contents of the symbolic link referred to by `path`. See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more detail. The promise is
     * fulfilled with the`linkString` upon success.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path returned. If the `encoding` is set to `'buffer'`, the link path
     * returned will be passed as a `Buffer` object.
     * @since v10.0.0
     * @return Fulfills with the `linkString` upon success.
     */
    function readlink(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(path: PathLike, options?: ObjectEncodingOptions | string | null): Promise<string | Buffer>;
    /**
     * Creates a symbolic link.
     *
     * The `type` argument is only used on Windows platforms and can be one of `'dir'`, `'file'`, or `'junction'`. If the `type` argument is not a string, Node.js will
     * autodetect `target` type and use `'file'` or `'dir'`. If the `target` does not
     * exist, `'file'` will be used. Windows junction points require the destination
     * path to be absolute. When using `'junction'`, the `target` argument will
     * automatically be normalized to absolute path. Junction points on NTFS volumes
     * can only point to directories.
     * @since v10.0.0
     * @param [type='null']
     * @return Fulfills with `undefined` upon success.
     */
    function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
    /**
     * Equivalent to `fsPromises.stat()` unless `path` refers to a symbolic link,
     * in which case the link itself is stat-ed, not the file that it refers to.
     * Refer to the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) document for more detail.
     * @since v10.0.0
     * @return Fulfills with the {fs.Stats} object for the given symbolic link `path`.
     */
    function lstat(
        path: PathLike,
        opts?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Promise<Stats>;
    function lstat(
        path: PathLike,
        opts: StatOptions & {
            bigint: true;
        },
    ): Promise<BigIntStats>;
    function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;
    /**
     * @since v10.0.0
     * @return Fulfills with the {fs.Stats} object for the given `path`.
     */
    function stat(
        path: PathLike,
        opts?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Promise<Stats>;
    function stat(
        path: PathLike,
        opts: StatOptions & {
            bigint: true;
        },
    ): Promise<BigIntStats>;
    function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;
    /**
     * @since v19.6.0, v18.15.0
     * @return Fulfills with the {fs.StatFs} object for the given `path`.
     */
    function statfs(
        path: PathLike,
        opts?: StatFsOptions & {
            bigint?: false | undefined;
        },
    ): Promise<StatsFs>;
    function statfs(
        path: PathLike,
        opts: StatFsOptions & {
            bigint: true;
        },
    ): Promise<BigIntStatsFs>;
    function statfs(path: PathLike, opts?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function link(existingPath: PathLike, newPath: PathLike): Promise<void>;
    /**
     * If `path` refers to a symbolic link, then the link is removed without affecting
     * the file or directory to which that link refers. If the `path` refers to a file
     * path that is not a symbolic link, the file is deleted. See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more detail.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function unlink(path: PathLike): Promise<void>;
    /**
     * Changes the permissions of a file.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function chmod(path: PathLike, mode: Mode): Promise<void>;
    /**
     * Changes the permissions on a symbolic link.
     *
     * This method is only implemented on macOS.
     * @deprecated Since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function lchmod(path: PathLike, mode: Mode): Promise<void>;
    /**
     * Changes the ownership on a symbolic link.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function lchown(path: PathLike, uid: number, gid: number): Promise<void>;
    /**
     * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`, with the difference that if the path refers to a
     * symbolic link, then the link is not dereferenced: instead, the timestamps of
     * the symbolic link itself are changed.
     * @since v14.5.0, v12.19.0
     * @return Fulfills with `undefined` upon success.
     */
    function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    /**
     * Changes the ownership of a file.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function chown(path: PathLike, uid: number, gid: number): Promise<void>;
    /**
     * Change the file system timestamps of the object referenced by `path`.
     *
     * The `atime` and `mtime` arguments follow these rules:
     *
     * * Values can be either numbers representing Unix epoch time, `Date`s, or a
     * numeric string like `'123456789.0'`.
     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    /**
     * Determines the actual location of `path` using the same semantics as the `fs.realpath.native()` function.
     *
     * Only paths that can be converted to UTF8 strings are supported.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the path. If the `encoding` is set to `'buffer'`, the path returned will be
     * passed as a `Buffer` object.
     *
     * On Linux, when Node.js is linked against musl libc, the procfs file system must
     * be mounted on `/proc` in order for this function to work. Glibc does not have
     * this restriction.
     * @since v10.0.0
     * @return Fulfills with the resolved path upon success.
     */
    function realpath(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(
        path: PathLike,
        options?: ObjectEncodingOptions | BufferEncoding | null,
    ): Promise<string | Buffer>;
    /**
     * Creates a unique temporary directory. A unique directory name is generated by
     * appending six random characters to the end of the provided `prefix`. Due to
     * platform inconsistencies, avoid trailing `X` characters in `prefix`. Some
     * platforms, notably the BSDs, can return more than six random characters, and
     * replace trailing `X` characters in `prefix` with random characters.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     *
     * ```js
     * import { mkdtemp } from 'node:fs/promises';
     * import { join } from 'node:path';
     * import { tmpdir } from 'node:os';
     *
     * try {
     *   await mkdtemp(join(tmpdir(), 'foo-'));
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * The `fsPromises.mkdtemp()` method will append the six randomly selected
     * characters directly to the `prefix` string. For instance, given a directory `/tmp`, if the intention is to create a temporary directory _within_ `/tmp`, the `prefix` must end with a trailing
     * platform-specific path separator
     * (`import { sep } from 'node:path'`).
     * @since v10.0.0
     * @return Fulfills with a string containing the file system path of the newly created temporary directory.
     */
    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string | Buffer>;
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an
     * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an
     * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.
     *
     * The `encoding` option is ignored if `data` is a buffer.
     *
     * If `options` is a string, then it specifies the encoding.
     *
     * The `mode` option only affects the newly created file. See `fs.open()` for more details.
     *
     * Any specified `FileHandle` has to support writing.
     *
     * It is unsafe to use `fsPromises.writeFile()` multiple times on the same file
     * without waiting for the promise to be settled.
     *
     * Similarly to `fsPromises.readFile` \- `fsPromises.writeFile` is a convenience
     * method that performs multiple `write` calls internally to write the buffer
     * passed to it. For performance sensitive code consider using `fs.createWriteStream()` or `filehandle.createWriteStream()`.
     *
     * It is possible to use an `AbortSignal` to cancel an `fsPromises.writeFile()`.
     * Cancelation is "best effort", and some amount of data is likely still
     * to be written.
     *
     * ```js
     * import { writeFile } from 'node:fs/promises';
     * import { Buffer } from 'node:buffer';
     *
     * try {
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const data = new Uint8Array(Buffer.from('Hello Node.js'));
     *   const promise = writeFile('message.txt', data, { signal });
     *
     *   // Abort the request before the promise settles.
     *   controller.abort();
     *
     *   await promise;
     * } catch (err) {
     *   // When a request is aborted - err is an AbortError
     *   console.error(err);
     * }
     * ```
     *
     * Aborting an on6vwôúŸ˛µRÿ0«Û˘∂¯˝U¸ﬁø∑çﬂ«ï¬V⁄ü˜Ø ßwµs€F~Ô∫m#ÔC®òΩáﬂA+iÓÆ—Ô¢ÙNtM5ıçﬂdÃÿ@—◊Wõøø…„vé˜ó˙“a+≠6»¯œÏŸØàìvçË˚ûJA«ôˆˇ⁄9˛Øù„ˇ◊Ì'K∆>Vo∫∞iVÔ@aXΩÉÖdsw∏ÊÓ0Î¬c)]aÌéQª£≠]ƒ_ }h≥˘ÌOØ∞s<9+ÏèUùêsö‰újrNœömâë¥é¸é<õﬂŒÒÒ:€xù+<è±≠∂n”Ëqòª0ã8LÖ~/æ∑…ºX2m2/…ömâ}◊Mx`ÿ2≤./3^Wä◊∆Î*·—Ójµuõ∆k$„j√ÆÓ˝ø^8˝Á,;ƒ∞G,ﬂm≥∑>ï%[@Œ\yˇ|@Âºürf|≥ ô[ŒR}sVÿ(26ﬁâ?Ù;µÁå˙qÎÔS*õ[Í€Õ¢ü…
ª¬Ë+y†Æó<Ïû∑2rK]§≤ãJe¨&ΩP6≤ö bå/©¸dçë;$ 3çëÚ∞}å˚£é≤YaèrﬁÆ˜*ÿ>ΩjrﬁPyÿ9b£ˆ™ÈÚ—a√ˆ™È
€≈ÈYsﬁ≠∞i<◊Ê˚=·{[€˜•∑k¸{±Ñ
~üäüÁt˝\uúﬂ™˚yñ|ÛyWn”˚Û∫‚Õø±◊ÚÒtXºK'ÁÒä∏9]*ÖbÕP6¿d,÷âå&£õÍÑåÓíqk"vN»X\2∫öå%;ë—’dÒqíå•%cÒJÁ±qzIFœJ!cŸNdP2ñSùê±ºdÙíËÂL∆Jí±¢…X•$cni>æ]â;I∆™í±íd@€d|O2æk2VÎDÜœ«Í™2zK∆˜$#‚ËÑåµ$cMì±v'2|>˙®N»Ë+kIFƒ∆ÎJF?ì±^'2|>ä∏7I∆˙í±n•Ûò7<˜<ß¸ÓÚ}‚5ÌõTtüP)ˆçw¥oPª-|Õbﬂ ^Âóiﬂàx8±ol*:bb{¨lˇx¶Ò/ø ˆÏ#¡˝9'n˚Ìh„GLmèÿV¸¯=Xƒq~ÿRRwÇÈ˚≈›§˚±ï˘˜ç=T'tè›#ø''J˜≥%dÏ≠2ﬂ7&w"√◊iƒe	˚J∆ﬁí1ZB∆4…}cøNd¯:ù°:!c…ò&–3L∆Åí·˚∆ÃNd¯:çÿ+!„ …8P2"K»8D2|ﬂ8¨$£ºoÆ:!„…8D2"M»8J2|ﬂ8¶>«%d'GIF9ÆÀ	í·˚∆Iù»˘àx.!„íqÇdDlóêq™d¯æqz'2|>ä¯-I∆ôíqj•Ûÿ-<˜<ßú[¯>¡sÌ6/Á[ﬁs¯nø¿0ﬁãxn)>óàˇ∆~Û±ˆxè®&{ÕÿoàOHyÿÙ[äÚäˆ ±˜ºT|#9WW
; êÛπ‰P[ΩÎLqx(˚èkUr(õM∑ÈªπRÿQÜúÖZ
õ>Ïo19¯áRv∑™<‰‹)˙÷Jao˚ÿı—Ô“ÔØ$ûû◊•l”˚∞⁄∫ç
6ó‘-€gñmT˛ï}¶À˝WˆôWãµáÊ7Yaü…˙t˚Lﬁ◊±«‰Â˛ ÇÌ3ëÔÎ1∑j^Æ}ùµy^:à6±FÆ≠,ÿ>Û≠ôéX›’¬>ìπƒ˛íÚ{≥ˇ{˚ÃzKaüâﬁÎ&˚K Ô 
˚Ã◊MNgˆô1'Ô´èwŸ|Fû§∫Õ6zú‹akÊµ˝ÿt¯i%’˝ƒd`OπC÷,„ãJ™˚πµ≈ÜÚãí‹∞≠¸ ÍÖm•Øôyï¥_˝”÷árÛlÕ`S…9€ﬂµf†3≥•@Øu[3ˇ{AÊ¸[3e{¡6ŸcoÃÂ?¥f®É˝«¬’b.…%Ù[3©<ÊírÏ=ﬂ.≤È&∫õ…˘Fr®É-◊‚&€Ãol?Î°ÚêC96°=ƒ∑ª‰,#zì3Or®3¨örÖl0ÁUãµŸKÂ!árÚ˙ÙﬂûíÛh{p©ä¥ktw˜ùN7î¨Ç(E3¢(Ê 
à¢("QQ¡Ñ9bŒ9Î(éiÃc≥ŒåiGıÔu÷˚ûΩ∫œÒøﬂ˜‹{yûMüZo¨∑j◊Æ]ªB7Kw;ª¿Ésg∫ãùU≥§{ªŸ√ËngUK˜0Ω›•èπö≈\Î'ŒZÕ|w>ú|M¡˙Xµ=ƒ<<ˆë∫µ^ñ8|tlC„ÊuÁ°]≠•OüMœj> ÍÒ¬Éπ[ÉÖÛÄõ]Á¡ºF‡ò≥ãÙÊŸtŒ.l@xpoÄosÒKÛ”ÎπóO+Ø-Ω¢»lmÒsØ;ùLfK/#2€X<]∆Îu{ì)Z∫(2√≠¸\∆ÔπÇ…\g˜‰urﬂ¢ÒoëÒ~˙	ç˝–1∆Ú˚uõ¡XåœŸı1†7§çƒπbçsv1ósæ—tNß∑Ø:ßÛz£˘‹Ë,«‡ˆ…¶cpò[6Zta>e’ñ≥*≥AÀ˘]>ŒåÛ°Œ÷c¿‹∂CDs!{®ƒÛﬁ`„0ãÔ·Ô√Â^˝õµ	à≈Îµø'»Ω:1K∫∑q„çÓ˜*Ë„≤ú
Ω„ÃŒdKOŒ∂^Ã)?ZÏ`>&Ëﬁ∆M1∫€ΩqﬁßÁ˚ì’˛Ê¢ÏN>Ïó—ÿ¬ﬁ‡ù!|ßXûıYâ9ò(„SÑÛ4üïòß	ﬁ”-göøgJﬁ≥8 ò'?W‚Äyò†{|ñ—=†œ…r^'ÙŒ…÷üÂ~ûÿ˘¿ÏÄsÎÁãùã≤§{|Å—›Ëò˚yÅÈ=_ÍÊcûdÚÆÔÚ,qü≥{e6h˛]†a^Êï¶Î
—ÖyîgXû˝æπ÷Óõó•ÆcÓ‰µbÔ˙,eØ≥¸ªÓ+-ˇ‡π!Kø‡˚ıÊ|[$æÅk‚ô¸ç‚€]m¯vè˘ÜÔéÓ€ΩY‚^/ÓÀRˆ^—uñ˜‚}ÇaÌ˝K«Œˇ@Ù=jıQÎŸ„Y‚Ô	÷[B∞ß≥È∫Có}&Kﬁß≈Ó≥Y‚d”Á÷Ã-6ö?ó∞&
8÷ü‡{*÷_,Œr/æ≥æêÂ7⁄~ñóÊ}åØyï≈yë•Á[zæ¯Úí˘·ÌΩ◊ÌLfÆ•ÁäÃ+óÒ˚Ó,ì9⁄“GãÃ´óÒ6kä…L∞Ùëy› ¬eº=E˚˜G˚Ü.∞É≤˛ﬂùÔ÷zÔÊøÌ·ˆ˚@ôaÏ„jXèÉ6q¯øÕ„Ì‹êˆ3€≥ñ∆˘3qêŒÌ›ÑY©õ€Îs‡VπMMnôÄsáÈ\«!&ÎÛ,á4Ë‹⁄Œ⁄Úyì¯ªGçÈûí‘ü7∂«∂·„·>é«5¯8ÆA'¯'àè|ú–‡# HÁKœñòŒn√ﬂŸ‚o(X6®ü/¨qæÙÏ†ı|i`çÛ•g≠ÁKkú/=;h=_X„|i`:_˘~6®ü≥ã1¡8HÁ¿‚ªÄ«ºª1˙XOkÃQø},˛Ó!Ââ¥∆‹˜(ÕˇˇÔQä˚MÁn„ﬁ”π›gfÎÁ„˘°qπ'˚ø;≥shÚñˆπºyã´œ˚Ú{Û~∫Ω≥–ª
s>∫~_ÿ\~®›Œ\›l“sÔ⁄ﬂ¯Ás†µÿa€103∞BôK¡y?h#6	8ÔgH¿æ
lo∞.	8ÁÈÕÉ›-Ç˙y¿H?∂ÿv:¸⁄6HÁ-˚yzÖéπUëﬂ-HÁ‹!ΩßÂÀ”£Éth~3¯wh–˙<¿√ÇÙ<@¥WáÜ∏åµ∏å±∏†]kqAªs∏˘=ﬁlé≥∏ =!HÁ˙9}æ"|8⁄¸@ô‘œ˜>ﬁb4ÕÙ!}BC‹¶[¸'È|oßœ2˝]kœ9oO˛ßt‚,-‘›ŸÊ“skﬁ€/®ü”çÿcFQ“óÈ‹`§17"ë4Ê)DíæÀÙ˘}l¿˙Ñ≤yŒ ÓYK˚yJù-ç˝îÈ}Ú´'œõˇæShÙWÉtç“oÕÎÏcﬂù7àÔÛßò€Zù@ªô∑:ÅviË√˛åÕÂü°}§{f“:±é˝≠ˆ∏ﬂ$ÎæØ“yî~Œƒˇf/I◊ãπõûÔ}ç∂}&≠[æ>‹Ûπ\÷ÊïZ^ùÔÙl:«È3≥ı˜:˙Å9)?oK1øum)∞ÈV◊™ï Í«ŸeﬁßzπÔÁ‘hˇ˝˝˜ﬂ=}n-˝[-˝ˇ4_Ì‰⁄≈t~ “∑≈ıÈ{“˜7§lHnH?ñ≠O?”ê~Æ!˝º•ÒÆsØΩÎ‡|Hƒ˙>ÎØﬁg˝¸]sòæ”Ã∂wÁôc}IÂAﬂzéÃ5=€
÷ÒÕï˜ës≤î;[˙‘xßÖΩsÑo^ñ˜‹π¬á˜8«amﬁÊXùpõXã¸éÄÁ
c-"dÅ#&[L˛ﬁuZ\{ã…]iˆ\ÓjëÎØ6π´Ïù·^K˜πã7öéy´GbﬁœGc‚Œ3,a{<]x∂Ià/2á'ƒfYyê§>Ç∂]Ìü∑«máÑq€Stˇ)!ÓﬂÓw4›¿}Æ‡ÆÇπÆ›M◊Ö¢kDB‹uÌëPﬂë€”‰.πΩ‚.7*°ÕΩDnìªZ‰F'ƒΩ˛Ïõ–&pØ?˚'ƒ°≥y-®≈ø>fÚCë±D˘ÌoÒsªô››ƒÓ¡	q∑{HBã‹a&w´»çIàª‹XãÎëgrwâ‹¯Ñ∏«ÁÈò6˝|ÙgbÊ	øûß%ñ'‰ÛÌfÃq‘üÁb“Ò<√8–ﬂåÓ„@†/Æ]3Ω¯vû∑ÙÛbgﬂÌÄÁı⁄ıíÿy1&Ω≥Ÿy√ËnÁEKøaz_ä9¶ÄÁÁ_c∂©:0¶ }õñ˜r”è~ü˙˜Ü˘˚¶•ÒÎ2oõNóÒÿ˝-NÀ‡ùòe0T ‡›ò∏ó¡{1±Â§˝˙ &Ægº~V∞èåÁQÒÎ„òºI¸>ãâ√ÓÛØ‚Ù>ÌÛ⁄ıï˘ˇπË˙“¸<:œWRnKã‰Aæø4]~NÀ∑1Èx>6ÔˇaÚﬂâ¸èVø†sx≠äIÍ˜íòÙf=5_K	ÈÓ;ËKkW…Ó≈•V^?öù≈tCx¢,˜Ì0´{†ÂçÊ>¸7&˝ìÊÔtF˜∫˙Øµ´`>‡Ôñ}`⁄dÂè˜°L¬˙àzàg{∆⁄ì”L˛4Òk;Û:;‘:aÀÂSøf'§˚Ω∑Ç—›/–œ¨]¿õ«ê•Ωòì–∑gÂòõGΩÒˆ˙úÑ8⁄ØØÁ&ƒÒúˆg‘∆wéÿ∏»¸#mË%	Ò±Ç-Là_ ÿÂ	Òs•≠∫"!ér¿Ωç>‚ï	˚ëCç>ÿ˙§W%§M≤w€´bÆˇ6”Öw(◊{B\ıﬂ!˙o˝w&§π˛ªb;’t°Ø|OBõ¯Áÿ}	˘{¿¯2Ç=d|¿v¥æÁ√	uBd[èöé¨Ëx‹t(ˆ§ÒÂ{⁄¯rbÎôÑ:°2OKô>ó∞ÚÆ›gã≠Œ.ñ:ª[â|®oo‘ÆÖ∂ã’g–ñ…ìÊı˘ÖÑtÙwPüó5∫◊ÁL◊≤Vü_îÚ|%°›πR_˛ö◊yáoﬂª“∆u…Û9¯WëÌñg›„Zç|Û;˜<«ÜöÃ0„Cù¿X@è<y¸úØûyb-ÁDÊâa¨‡{ø^5O‹œ∫Ím<Ë#∏‹jy‚*∑zû∏À≠ir{ä‹Zy‚*∑vû∏À≠cr£Ög›<qØÎÂÈ'lBÙô5y–6»ìéw#èÁªI;èÁ¿<qçÁ†6‚9P‚98OèÁ&ybûø!yböøÕÚƒ=[è∆shû∏ mô'Ór[õú∆sXû∏ mì'Ór√MN„π]û∏«s˚<˝ÑM»o'Ò¸SûtƒgßcLf∑<«i<Nﬁó¿{˜Óy“'ô≠ybÁŸ˝˝s¬∂c¡~Mxè√÷√~O»⁄…Ü%y‚–È}©rûÔ£h◊qØ6ªMy“\_%O:úXÀ˜<ÂΩ_·ÌÓm§ó≥{|9ë¡Ûo;ëÒÁÂ
˘ÙŸöKËl‚õì6"≤g±À«&û˝√Ñ«˚{FM¶ò‘˜g–ˇz“>aüÁ\ÎÛ,c2ÀH;¯së}»mP≥∑¶¥É“õı‘ÚµVBz`Ì Ë+‘Æµ<ˇÊKGKw;–]‡ÈUªzm]kãA[›hÓCóÑt‹ØÕ{	›€b–ª÷Æ5ÃfWyFÙ∞<iüßgíˆy0~—”|>“ øÓW_Û:Ø·øÊSø&ÁI˜>n–›/–èB,ÿw˛|Í◊î<}{6HÀ˚ò<qÌÛõ'Æ}û„Úƒµœ3›¯é3Õ?ÌÛúú'Æ}ûSÛƒßK˝>=O∂‹Óy‚⁄'ôùO˚$g‰”>…ôy“ºO2'O¨eØ%”•}ûãÚƒUˇ≈¢ˇ"—Iû4◊iûò˜%.À”&˛9vEû|ä]e|⁄Áπ∆¯¥œsmû:°2◊à≠ÎMáˆon4ä›d|⁄Áπ≈¯¥œskû:°2∑HôﬁëØÔÛ‹iuˆN©≥ÉK‰C}{¥v›+¥ÅVüA˚≈h^üÔ…ìÓ}ûˇ›ÎÛ=ñ˛ØŸºW ÛÅ<Ì#ıÂ¡<qÌÛ<j|⁄ÁâÏÛ<(≤˘Îû>£ÖÙôa∆ÁœËbÅ<˛å.ày[ÿT ¶œÃJÅ∏?3€è>£€à´‹2‚.∑ú…È3z˘qïÎP ÓrMNü—ù
ƒΩ>¨X†ü∞	y–˝›π@∫ˆyûŒß±ÛxÆR ÆÒ\µçxÆ"ÒÏU è«≥wÅòÁoı1Õﬂ‚ûøµåG„πvÅ∏ ı)o9„€‰4ûÎà´‹˙‚.◊◊‰4û˝
ƒ=ûË'lBæüƒ≥ÅtÌÛlRH˚<àìˆy6-êÓ}û!bﬁø˘8œ∂£≥`üÂyè√ñ˜Qæ»ì4ÔÛ|õ'ùﬁÁYíÁò;⁄ıÅ“ÁYö'Õı˝ò'xŒÅˆ£‹ØøÿΩé2◊v˜6“øZ˙Wë˘›û'.„œÀ†ê>[WIËü˜yVëÁL/{ª|o{^˜û’ÌYÔ<ﬁèX√û—kZzÕ§æ?≥ñ•◊∂Ù⁄“∑¯oë˝®]•o±^B:˙HhÛ=∞6Ùık◊ ”ªæÙ-˙ô¨ˆ-6îææÖlh~Ìi} ¸∫_Ì≠-ÜŒ/j¯gÖ‘ØΩ§{ﬂ‚K£{[˙>µÎK”ãø›Ø—˙ˆlê∆uøqÌ[P Æ}ãƒµoq®Ò 67ˇ¥o1æ@\˚GàCácƒaÀÌN*◊gˇ‰B˙ÏüTHü˝GHÛgˇî±ñyê¶Î0iˇfà´˛Y¢¶Ë?π@öÎ?•@ÃüŸßh3êÁ¯Ú)v¶Òiﬂ‚,„”æ≈‹uBdŒ[ÁòÌGÃ3äùo|⁄∑òo|⁄∑XP†NËÄÃ|)”ãı}ãK¨n]"u∂Gâ|®o◊◊ÆÀÖ÷ÕÍ3hüÕÎÛe“ΩoÒ©—Ω>_fÈOÕÊÂRûWhw?©/Wàkﬂ‚z„”æ≈7ˆ-ÆŸÔ¨ÓÈ≥˚B˙,ÑÃ0„Ûg·ø‰Òg·b˛lZZ ¶œ¶ƒ˝ŸÙìÒË≥Áqï˚•@‹Â~59}˛V Ærøàª\¶H9}fãƒΩ>‰äÙ6!∫?£"È⁄∑∏EbÁÒl*◊xVä≠„	>ègµHègª"1œﬂ2Eböøeãƒ=Àè∆≥Cë∏ ≠P$ÓrùLN„πbë∏ ≠T$Ór]LN„ŸµH‹„Ÿ≠H?aÚ]%û=ä§kﬂ¢w1Ì[ N⁄∑X≠H∫˜-V/Û~ƒ_
l;"¡^*á-ÔºR /hﬁ∑xª@:ΩoÒ~ÅﬂÔ—Æwìæ≈“\ﬂáb–ÅÁh ˝˙â›Î˛˜v˜6“üY˙3ë¡ÛØΩ»¯ÛÚÀB˙lÌü–?Ô[ÙóÁÃ {ª¸@{^lË‡9Ó˙€≥ÙæE“ÒÎÌYhÌdÜ◊mäi{∂Qët>ogtoœ@Ô_ª∂3Ω¯v6∂Ù∆bßjv¿≥5Ó±3®H∫∑õ√åÓvYzòÈ≈ﬂàÊq ^∂õ9∑>W•l∑(íÜ˙à˘<Cã6Á«¯µxoÀÛÀ„Ì˘f˘‹∆“€àÃp≥Ô2sƒk_–~‡z◊Ë€}{âUT‚ú"»L©]ìãÿﬂÖ±⁄±H˙,+ì£çÓ±}ß⁄u¥È›I‚ºKëyÖ<æIN*6? õÂ@€˜°…Ìjy‹Õ“ªâ≥û#qoãç=ä§{ùôht˜Ùëµk¢Èivˆ¥Ùûbßlv¿3ÆvÌ#vˆ.íÓufº—[˙éñoz˜ë2:P‚‡u‚ ´z,¶ıÁ‡"ÈŒ{H/t9Ô°E“Ω9¨HÏ`´≥†&æå≥|¥¥	ÊÔxãÀKOô#-∆.„e4—dº'˝Aùõlt¸zª?≈ÍïÎÙzâzt£≈¸ãõœ]πPÍhSk◊Ö&7’|9÷“«Jπ∆VÆ‡ô_ªŒór=æH∫◊üF˜r˝Ñ⁄µ¿Ùû`v¶[z∫ÿIÃxÊ’ÆôbÁ§"È^Œ3∫€9…“Áôﬁôˇye˙∏çº'ùV‰\èy“è8ΩH|ûÃâö]$ûH›;ÀÍt˜Á#Íœ‹"Èh„07Ï"Á5]Õ{…◊‚üÈ˜≤Ùÿúg±:ﬂ“ÁãÃ|ãªÀxπ-0/◊-}±Õõ∫HÊHΩòm=G
kC^û=r≠ÁHçÃ˜9R{Âày=õîKÎh£j0ÿïìyFπ÷s§FÁà{?n_”‹ﬂÃuúk=GÍêq◊uhé˙π1π÷s§∆Êàª‹·9⁄+r„s≠ÁHM»˜:vDé6'»:◊â9‚–Ÿ|Ô[\Î˜¡˛v†¨&Z¸‹ÓQπ÷s§¶‰àª›£s‘1E‰¶ÊZœë:6G‹Âé≥∏+r«ÁZœë:!G‹„É5;∞Ès§ﬁ∞∫Ü_œ”ñ'‰{Ï|ûMÔm¨=@⁄êØåÓ˜6ËXÙïÈ˝õÕ|«“ÔàùÕx>Õ¶kË`Á˝,È>GÍ3£ªù˜-˝ôÈÂZ-ˆU>™˝˝ò˘˘¢Õë¶s§>5˝~O∫üôøü[˙si_æ4ù.„±˚*õñ¡?≤≠ÁH˝3K‹À†yü∞l˝©o≤ƒué‘∑Y‚œ
ˆΩÒº$~a=0xøó¯-ÕˇßÕ◊¸YÊkÇÜ˝"~6ˇ]?ôûGÁ˘Y Ì¿yêÔüLóøa∞ tü#ï±{&#˜ÃAVÓ–yÌÔs©ﬂQétËAπØî#›}{¨dzcª7K'b∫°<À◊ÆBª«| ≠£—‹árétü#’…Ë^˜@o™]ùÃfì‹óÌr¥´czÌs¨è®áòØ‹ﬁ|^`ÚƒØÃ/ËÏ¡*aÍ◊≈9“˝ﬁÎmt˜ÙKjÊqÒÎ“}”1ΩÀrƒQoºΩæ"G\«ÙÆÃG?««ÙÆ5æ+ƒ∆çÊﬂ±“Üﬁî#~ú`∑‰à_+ÿm9‚WJ[u{éx›¶úÃa …¶i-sòrƒ\ˇc¶Î∞ ’ˇxé∏ÍBÙ?.˙üÃëÊ˙ü Û±≤gr¥âé=õ#übãçO«Ù˛b|:¶˜Bé:°2[/ôø{≈t(ˆ™ÒÂ{›¯rbÎçuBd^ó2};«>÷?≠]¸õ’ŸøIù}≤D>‘∑œj◊˚B{‹Í3h=C“º>øó#›€¯ïçÓı˘=”µ≤’Á˜•<ˇû£›À§æ|î#Æczüﬂ?•ç[;‰s#ë]'d›C˜1®u√t
2√åœ«†÷…„cPÎáƒº-Ï”1°~!q7ÿ»xt™H\Â6âª‹@ì”1®A!qïwπMMN«†ÜÑƒΩ>l“OÿÑ<Ë>µEH∫éÈ˝3ó∆Œ„9<$ÆÒ‹Æçxóxní«„πCHÃÛ∑cHLÛ∑SH‹Û∑ãÒh<wâ´‹n!qóarœ=B‚*72$Ór{ôú∆sTH‹„πwH?aÚ£$û£C“uLÔ†0”Cúº/Å1ΩÉC“}LÔêêòèﬂC∂[÷Úá-wÆÜ‰Õ«ÙVâCß˜•:á\cÉv˝q˜ÈíÊ˙∫Üƒ†œ9–Äy¡Ωˇ∏Ùùº¡ΩçÙ*vèØ"2x˛= 2˛ºÏ¶œ÷esÙ6Òå]V⁄àÂÌYÏÚLæÉt¥gΩÛx?¢ì=£W¥Ùäπ˙˛˙^Oz‰ÿÁÒ9R=çßß¥ÉáZ_rW‡€´¥ÉΩr§COÛ7ƒÈÅµÉ†˜Æ]É<ˇÊÀjñ^MÏ@7tÅg√⁄µë–Z[⁄∆Fs÷Œëæ≠µ≈åÓm1Ë}j◊ ≥ŸGûÎYû¥œ≥~.ÌÛ`M÷˙ÊÛ+g¸∫_Wö_–Yçju2J˝öíÓ}ûvFwø@?πvá^¸›≤wIHﬂ¥œsZH\˚<gÑƒµœ3;$Æ}ûπ∆wÜÿòg˛iüÁ¸ê∏ˆyÊáƒÁJ˝æ0$[-sòB‚usòBô√ ¶ê¥ñ9L!1◊ÉÈ“>œç!q’øHÙﬂ(˙o
Is˝7áƒº/qkHõ¯ÁÿÌ!˘ª”¯¥œs∑ÒiüÁûê:°2wã≠˚Láˆo0ä=d|⁄Áyƒ¯¥œÛhHù–ôG§LüÎ˚<OZù}RÍÏ¢˘Pﬂ^™]⁄VüA+E§y}~&$›˚<e£{}~∆tï≠>ˇY sqHªßI}y>$Æ}ûóåO˚<"ˆyûŸéÎû>£;EÈ32√åœü—+F‰ÒgÙJ1oªDƒÙôŸ5"ÓœÃÓ∆£œËqïÎwπULNü—´FƒUÆWD‹ÂV39}FØ˜˙∞FD?aÚ†˚3z≠àtÌÛº¶±Ûxˆçàk<˚µœæœ#Úx<7äày˛6éài˛Dƒ=ÉåG„98"ÆrõDƒ]nà…i<7ãà´‹Êqójrœ-#‚œ≠"˙	õêﬂR‚9,"]˚<;Diüq§}û?E§{üg«àò˜o˛≤ÌXK∞•!ÔqÿÚ> BÚÇÊ}û "ùﬁÁâ"Æ#Fª~ÉÙy‚à4◊óDƒ†œ9–Äy¡ΩÉÙ-º¡Ωçtì›„M"ÉÁﬂï"„œÀvQ˙lÌõ£ﬁÁÈ+œôÌYÏÚŸÛz#·ŸÿûıŒ„˝àˆåhÈÅπ˙˛Ã K∂Ù`È[å±~x∂≠]√•o±YétÙëöøu=∞6ÙÕk◊v¶wsÈ[li≤⁄∑ÿJ˙XﬂΩï˘5∆‚â_˜k∫µ≈–˘üæT˙„"“ΩoÒì—Ω-}<  Ù‚o˜kBDﬂ¥oqdD\˚ì"‚⁄∑ò◊æ≈1∆7IlL3ˇ¥oqBD\˚'FƒèëztRD∂ZÊ0EƒÎÊ0E2á)í9Li-sò"b-Î‘Móˆ-ÊEƒUˇy¢ûË??"Õı_ÛgˆÇà6Òœ±ã"Ú)vâÒiﬂb°Òiﬂ‚≤à:°2≈÷¶C˚Wô≈Æ1>Ì[\g|⁄∑∏>¢NËÄÃuR¶ã¢˙æ≈MV∑ní:;∑D>‘∑˚P_Ö6«Í3h?ÕÎÛ≠Èﬁ∑XbtØœ∑∫.≥yõîÁùÌ)ıÂÆà∏ˆ-Ó3>Ì[¸±oqó»fb÷=}f„ÙYôa∆Áœ¬\LÜ116≈11}6%1q6åGüÖ≈ò∏ ïb‚.◊dr˙,¨ƒƒUÆwπˆ&ßœ¬eb‚^ñçÈ'lBt.ìÆ}ãG¢4vœ.1qçg◊6‚ŸE‚Ÿ-&è«≥{LÃÛ◊3&¶˘[9&Ó˘[’x4ûΩb‚*◊;&Ór´õú∆sçò∏ ≠wπµMN„Ÿ'&ÓÒ\'¶ü∞	˘>œıb“µo±Qúˆ-~oË[ÙèI˜æ≈∆11ÔGº±ÌX^∞"ﬁ„∞Â}ÅøG‰Õ˚_Fƒ°”˚_G‹ìÌ˙È[|ëÊ˙æçà}i}–æï˚ıª◊˝ÓÌÓm§óZz©»¸«û'.„œÀü¢ÙŸ:,Gˇºo1Lû3€⁄≥ÿÂá€ÛzxCø œq◊∑Ω=´Aìé_oœ&Z{ôΩj¿»8mœ∂éI˜ÁÛ(£{{˙∞⁄5 Ù‚ÔÊπCñﬁFÏov¿3¢vm/v∂ãI˜vs£ªùÌ,ΩáÈ≈ﬂàˆ¶A˛ºlwéπ_|>^ vóò4üì∞kÃ9	Œ˜í≈8x=ﬁ#Ã/è∑ÁkÀÁHKèôΩÃæÀxÃ£∂Ê´ÏmÙΩ%VìlédN©]≥‚té‘æ1È≥,Vß›c˙~µÎT”ªüƒ˘Äòyùds§f¬ò…Åv Ócì;–Úxê•ˇé6˚‡ôQª¶ãçCc“ΩŒúdt˜Ù√j◊I¶˜0≥3∆“cƒŒ±f<«◊ÆÒbg\L∫◊ôåﬁ“w¥Ù	¶wºî—dâÉ◊â£¨N¿wËè◊ü)1ÈŒ{t/t9Ô11ÈﬁéLçâM±:⁄TÒÂxÀGKõ`˛û`qônÈÈ"3√bÏ2^F'ôåó·Ã?®s≥åé_o˜O±zÂ:Ω^¢˘©”,n(‘ü§˛ÄvzÌ∫¡‰N7_Œ∞ÙRÆì≠\¡s]Ì∫F uNL∫◊üÎçÓÂ
˙YµÎz”{ñŸôkÈπbÁ(≥û´j◊<±snL∫◊ü´çÓvŒµÙ’¶wûƒ~ô>éî˜§1ÁzÃó~ƒÖ1qù#uqL¸(©{≠>AÁQs§.ãI˜9Ró«È©ã≠NªL¸ª Ù{YzlÆ∂X]cÈkDÊ:ãªÀxπ]o2^Æ7ƒıs§.Œ÷Ô5Ö_ﬂ{V˜ù˝≥≠…˘£}gÒ;ÈºˇlØ¸Ü9}ˇŸûœ•¡y232ºœlª
||{ÓÅÿºÔgêÓ⁄ùn÷Ì⁄=hΩˇ©À ÀñÍ˜?Ì¥ﬁˇX‘Ô
,Í˜?ñı˚üvZÔäﬂBPøˇ)∞bêÓÍX…∞µ+∂Æ`MÜı¨bX¡™Ü¨ùaCkoÿP¡ñ1lò`À∂ù`À∂£`À∂´`€C0?£vî`€W∞NÜ(ÿäÜ*ÿJÜ.Xg√é¨ãaìÎjÿ1Çu3{bÔUú´áz¨õ8kèu3l˛;“˙·iØ´‡«=‡˚∫‚Ô-4¶{Jzp¶~Ø‚MÙ9Êu?krõfˆSáòﬂ7wH>‚ı}s7œ‘ÔeªyÉè∏óKA∫wÌôˇ˝ﬁ¥›,›µ¶øÒˇGW7ª˛∑rÕ{eæØ®Ìï0ﬂÀÉﬂﬂàÀöñ∆Ω›ﬁ‰WÍ˜"ı˚º]¿}\◊{N«=∫ú§ºè<ΩMêûıéÙˆSOÔ‘‡œ»Ä˜úßÒÆπÇ§èX==— Õ”ßÈ^†Hcø’D“Á6¯èÛo#I_nı¬”Wº?=çsbKíæ=H˜jE˙Ó ›´ÈáﬁÀû~$‡}ÏÈ◊ﬁ√û~√ ﬂ”8W±*iúZë4Œ¶j≤tsΩ±{√ÈEKcècúµâ=P—t∏™üªâÚ_!√vÿ@KwÃ§{≠v±øªâΩµ©ˇqO˜kNü∏iÛ^ ŸK9”zœ‡Aôtœ`¥‡÷ºórÌÚÉÕg¥õdl/Â⁄Ô¶ÊÛfÊ”Ûy3{^ªœ[Ÿﬂ–Âvwñ¡ÁCö”˘Õ<f8o04˘cMæa?ŸÈô˙=ÜO¥∂l∫Ÿ?—˙
…ÁIôtoÊôô÷{ü“l?lIü÷ ?;√õ∆”ggxØUK¡.⁄Ø”‰jŸì9IÔ=§±.7î4÷‰Fí><©˜˚0&í∆|˝º§'$i]G˙à$Ωê>2©øW&&ı˚ÈNjHON“∫‹‹◊N“∫éÙî$Ωê>:a€ÂÈ©	üû>.·≥ﬂ””í¥≠B˙¯$m´ê>!I€§ß'i€ÉÙâI⁄ˆ =#I€ûÊrN“∂ÈôI⁄v =+I€§ON“∂†π$i[ÄÙ©	Ôµˇ€Ωxg∫”Í3ˆ¿E›÷s˛0áunñ’K‘Eü√|≤·˛æqjÜÿ)"w∫…ù&r~é§À·ÏG`®ßﬁ˜üì°æ3E◊Y¶kg—ÂÁI∂Ïüõ!v∂Ë¬πè–wéÈ¬sÍ<{¶Eóüâ˝m—÷·úH»GúXú.⁄¸⁄µ¿bÖøõ˜<∞Ù±ıºŸ∫<Hm·Ï¿ÁÖÁ„πBxpñ ˘5<;qV¸ÅÏNñ7úQ’—Ê¿∑Ï˜ñ%^ó∆W¿_õØòÕõ≈¶üMËÒƒ