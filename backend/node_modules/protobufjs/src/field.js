"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    if (json.edition)
        field._edition = json.edition;
    field._defaultEdition = "proto3";  // For backwards-compatibility.
    return field;
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    if (rule === "proto3_optional") {
        rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is required.
 * @name Field#required
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "required", {
    get: function() {
        return this._features.field_presence === "LEGACY_REQUIRED";
    }
});

/**
 * Determines whether this field is not required.
 * @name Field#optional
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "optional", {
    get: function() {
        return !this.required;
    }
});

/**
 * Determines whether this field uses tag-delimited encoding.  In proto2 this
 * corresponded to group syntax.
 * @name Field#delimited
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "delimited", {
    get: function() {
        return this.resolvedType instanceof Type &&
            this._features.message_encoding === "DELIMITED";
    }
});

/**
 * Determines whether this field is packed. Only relevant when repeated.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        return this._features.repeated_field_encoding === "PACKED";
    }
});

/**
 * Determines whether this field tracks presence.
 * @name Field#hasPresence
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "hasPresence", {
    get: function() {
        if (this.repeated || this.map) {
            return false;
        }
        return this.partOf || // oneofs
            this.declaringField || this.extensionField || // extensions
            this._features.field_presence !== "IMPLICIT";
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "edition" , this._editionToJSON(),
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringFiÊÚLº1õçoŒŞ‡¾úÊ´I½ÍğóĞÛs~>ôöÚç„ß‡?÷¦·HlGÏÛ‰áô¦ö—:ê|T#º®¼"ÛÖ
K[„ş?kÜíĞ^®ï/qƒ 2¿÷ç~d1v+E{4V—bJ75¡FRO¸i¹fÌÑ+¾í"­Ø*¥X¼Rì)\>9,v+rÑZÁJA£R0Im‹MÖŠ¹”båÇy±6ş|9"ÛÛÌR´‚ã•‚¹JÁ?ùËxh¸ÚO˜ÅTçèBß@+:O>z´XÁÎç-Hì“8àg¨"$å—Fô-DL	»OùÌ,^„·ĞHéÃãJıg¼êobx×o¡Ôïç]ïF^¿ƒR¿‹ZÿÂ:Ú»şîJ^¿	y(‹İùlîØw^îãZº§©,ù~Ñ¼|¥m¤ºXp¦éùpETU]Ç7£=YÔDWnSB~æ5PWÁFUÓc¦gxó¼rYÆzá| ñ½4™@z°‘-9(c”•59ğixé¸`÷Í'A:2Œw±OÚ«ã˜
¯m˜^¸„µSêvàu3Î¿‚©$ƒÂ…ÌĞˆ=nìĞŒÆg´Áµ­67ñÖ0½¶%‡uà=b¥-x“;´ÜúN¬í8×ŒÊuİº¾.XĞvmU’¸à}[©õ¯evœ×C›©À:’t–Ÿl˜pÊMoW1±>–}Ø”¶D£]Ô m*2í~¾°V1€­ÏóíÃ‡s^VòÜî†©2PMg|›ÃËìûÊ8ÿ–ùm€¯ÿOQ¢E¶q<¿Æò”«Töõx²1É™»`şîÌÍ_uÆZ´cş+-àÿÿùÿŸÿ½?Êşï@îÀ(ÚOÖqş¹×û—ZÕ~¯×ûO®ı¾‹×û¸ ï÷õ‹¿?P;~ú}uÿ‹µı/ŞñÓjÉæCëØÿKù©ÿÅËÿµób(Ÿ@Õš™ÂœÜ§Æ¨ù©ëÿĞ %:9—ï?îñqÕßwW]JêPã×àšÍNö‰Nşì	%:9ŠÇSÖ±R‚¶i½öX+ãï_{ƒŠµ±óßü½÷7¨%¿|1üvñ¿¶ø]îW¿ûãù
vb²ßX¸f16üÚ¿(~¿ĞÕ¿~¿šğo¸fùÏ)lHv­éU¯àÊ‚–^ùúĞ	»G	(¤dé8ÛØ”B"?ÑGÂ…Î*ûm´J]ÂzkacöHoä!P…lÓ£%ÊIq½ùbKŒš°ï»íhZ>„½9ÕˆoŞUõ¹…"!âÌ#®(J§ÖzÑG:Ú,í¶‚‚øÚSõX,b5 &öúV‹4şÇ?j‘M£ èğF>aÕš0¦ÁÕxQY–«Ğì¸»X©Fë•‘J2Ú¤É¹{äR“¥ÓÌìf–ªñ>S™¸ÌÆ$ -X”ÌiR+üçœÔ*­+ûiM€Çağ	0ƒ7:[}&@ßG)$à[2YP¸e“Ãè—ñØµ½¸æş´|mì0YÚfğ:•RÉÓ+J=6)%.Ù¹Õ~‹…GÁBïñÆØ"³{kUÏfzòàØ;±?q‰)‚¾fŠ@R
ó”-r—R¹Š@î°‚ï:?ÂYÿ„QpbsEC[<À.8_Ñ);zøvC4Hk QÈZx·ovoQ]Ii)ØjZ7h$ÓŞ½V#1—¬ÛëÚƒÙ- MÅ0q+í­ÿî®î¦`6 DŞIÄõÜÖ¢´ÍÀáK¨Şß¹S†Ñ8V„cñë”â)X<ÈS<ı€ö`şû¬n“šàÈÈDçÚXà5cı¸y½p[e:Š`¦04I0=xXĞü†åàsÁ¨nµDŒ¢Q¸59ı„`4EœB“f'K:6÷l±;IîLé
¡æ¹!:ÁÈ[„2s©Vhò"­V6;Œ[Üµ–“r•†Kµ"eìÔXô¸ÿ€¥Æc©Ğ$¦4T­•2˜İ;-Ê†ùr _îÃTD¬>ŠˆˆA²\l@ƒb=X'[1Ùˆ\åŒ†ËX‹“J±zàÿ”-q‘üŠ³ÏkQ‚ÇEÉj°J»l˜ªÎj`CŸ5¤İˆó±Tğ"ëV›´^°l±JMÜ¥êŠ×•¤9Tö¿ñîX¥<ŠÊÙ`“·"ÃÙ,m%ÖùGëº¥¯ºßkõ™b5Î^
a‹Cqæ•jI¢>¾X’(eÿë™ZßotOïÛ/óı5¾«Ï÷/.ı}}íïQşV—ÿt±z¾Õ-(<¤¾©4ïŒã >crøë”+vÍev¤iûŸO{ÃsŸ±&<UğöRğt9]G[Ô€'ò2ğ«öşşn¡æ÷»ú_ŸË«k}ÿúk|ÿƒêş¾bÿÔ®o8Tì]ôEêkù¿Ôş+	ÒJ«ŠÑ¡u‹O‚4äò±[3&…ó,ik¤5êó¾ğÜ19<ÈëáE­ï/=å¿·šÔÄ_å­ÃŸ6şZ}PbFÈb5Æ5”ƒÆĞ© i*ÄÓ»Ğ‹.ºDÃÅzÈõáyk×à|Níü·ªÚğ¤c0Ç#<ğ¸wÖ{«®+8¿[Ûÿûgmx–ığÌ9ïç•úÂ“ñçÀ£Øk™É^ÓÎü£6<e¿<ëÎyài[_x–ÿq­áé\<F„çÏ³x–î¨'<N^ëù3òdmxL¿<í½àéQ_xB¯«0^9Qñ¿ <ƒÏxà)Ù^OxÌ'®5½­>^?<ÎÓxFÖg_kxUÖ†§ã(¾ªöÀsì‡zÂó^åµ?më€G‡ğüzÊÏôúÂ³åØµ?ıÕ†'æ ÀæP_xôWBo/^½M?ZÔ2€'©ÊÏümõ„§ËÑkÏÒ#µá™q!izàé\_x:r­çÏşÃµáÉÅ@‘ÿğÀ³zk=áù×ák=„:à©Ä8Ší'=ğô¯/<yWNoÎ+¢·µá‰@x½àÙ¿¥ğ?t­áyúPöÏ^´NxÙ?õ…çÆ+çêØ?åuØ?{Ğş9îeÿ”Ö×ş)¿Öó§„ÕaÿüˆöO¥—ıS_x2Øµ÷ïuØ?X±î˜—ıS_x–ÿ~­Ç§sğ?zÙ?%õµ~»Öã3ò·:ì\¢mïOúÂzeğ\ûç×:ì\|ÄËş)®¯ıóëµŸÕ¿Ôaÿì@ûç°—ıS_xùåZÏ±Ÿë°¶£ıSáeÿl®¯ıóóµŸ¶uÀ£Cx~=äeÿÔ-¯õøô?X‡ıóÚ?^ğõ…Geğ\…ñ™~ ûgÚ?å^öÏ¦úÚ?®õø,-«ÃşÙŠöó²êÏCeW®ú_‘>ºöÏ´~÷²6Ö×şÙ­áê€§²íŸß¼ìŸúÂ“÷Óµ?=~ªÃşAx½àÙ¿¡¾öÏ¾k5ùçóı¼Zß¯¼d‘ú´ŠÍı»â—†(gûîİ«Åœzß“íË*UÆº1Šg³Úb•Êc‹Ø6°ãgˆ‰Jú.KdDRlnìVxë¢Ì"öÛx©kæYJD©—!!%VmÂÆ İ*•ò3ÀİÛE~ í'ñi–¼ËâOQKâ_NİåŸàìuÍiˆïŒİ"¨‰}ÿ3'£`Ñ'º†ê¤å¿æ-C³·@›ÃJ”x$ûïµ–qy<m%Åx¤Ù©]ñÚ³À©ï©ñH)¢äÌÕaÈÿn›ôy!Ò&Vh„‰uèĞe'Æ¡ğü_ å0v½µÄ[$”Šgká)íüDûjŒOiŸÍ×ş@:Ùx–ÍõAä2J^2ØdÅ]À·ÕF{Ö4‘b™~e.#ƒ‰5®Ù¨HŠe2Ë)Sä>³X+ïŒ¹QîÃìÃr’)Ç¨ô'IÂ"âæpíÎÑ"š)c¸3‘’ˆI’Xµ‘NKœU}‘E¦&Åş"J½×D£s«=Ğg¯ğwÄ	ÎÕ”5šÚ°°Ø-ÅP»»n¶^÷Üíl¤™º|vÙÁ»¼–-kWâÎI×aPW®ÜÇÅ6C¹òç´Ì_0VŸmÆ—™¤B5Sót¥İÎó·oÆóèx‹Øâˆv<ïP¿ü<º)Øb'ÏÎmKŞ}F?!Š§ç@[.lKæmuÅ¶š¶«Ğlj7vÖYe2cš¢Ç-ñ£#Mi£#¶øÔpû}”±8Všk•¶¡¸„?“„Ğ¤,öÅ/Å=öoŠÑéMG”§p¬‚ÁŞ¹SÂiã°(â‡!ÕÁ0Ü&|§·úy?{ª‰©+’”DØ¨!>ŒÔZ„wkØZ¸Hé6°†dŠR¬vR€©9›d—Ãºl¢Ô¬|k¡çˆµGÚ 'ÅºÅx Z!ÏDúô<L‰µºk	µË~8†QgØÛ“µX«±<"jµL‹uÊM–LÖqÆZÙ")Ø
È½2E¶\&*1R»´zŒMoÎƒ­”¦+•¦uZ#{	ñìÄ‰ròm®´¥‹so³HeèÔÖxäÚQû<Mm"²!i(Eb‰î1fi­MR&ª”LéÖºà‚zÆÚT½ºãÿZÈÕôs±óo·_,>ËÈÑØş§â³€Ç5ò>C„¾W}MÿQ;ÌãŸ×ˆ7I¾\¼‰û/ıé&ÅŸWˆş¯½^önÁeõ'Mÿ¯£½Tl/Í«½—oÏ[>?ğƒ—|¾‰ËçF…\>·Ù{%òYÿƒ·|T¤Èçö×’Ï¾ùPH—òÈo·©Bzç[ª )<[ÍÉxHı<ÜàBÚ&}¸@•Ï$&§ÃPqšr+
5uÈ;Cå™ßê8ë¶ÅO
2— ]ÍEÖ#ÒŞğmÈìEü3Œx?[ıgù<,S¥‘Ö€‚©(igr”£åE0İ‰ıÇ±µ!¨¤MŠ•
óN·Í8 Ó¥OÏÈs»§ëÚ¶Ç›îğ' ­™ãôXÂ§Ia‹Ï»Ë(ã”(Zbò5˜|1ßñÆŞGV|<ÎÃÇM¨—(|üéEœ‹¬Ñ!o ñq‘3Ût…ÙÎÖ¸èâã£K‘÷'6›Ó46JZ¤0ßl­Z!Ëål\i¹Ti¹L+RÉò»s6R69³ñj¥%ƒV,ÜìŞnA•µ˜­@É °ì8÷€(Úv—¬z&í¡|'2o¹‹Ñÿ÷m¹»ÿ\VzqşéWöÏòÏ ÇA½´¦çä?ÿ+ñæŸå¿ÕäŸ&¿ËñÏÕ%µù]Ì:ôîôò¯­­7ÿ|ºöÊÖâú—W{#/ß³hrP6N§ü¼òæ>{¿ğGÚ"å	9'Ú¶Ç™6£¸¦foş»§¸6ÿµ­åü÷İÿjş¯b/xƒe7«ÏFx“”†ıĞÚ@*ç¿«ü;í«µ
ÿnöcö•¶Ûã³HãY·;»2Ğ©Ÿ¼á* @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};
