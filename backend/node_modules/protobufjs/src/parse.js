"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    ReflectionObject = require("./object"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        edition = "proto2";

    var ptr = root;

    var topLevelObjects = [];
    var topLevelOptions = {};

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    function resolveFileFeatures() {
        topLevelObjects.forEach(obj => {
            obj._edition = edition;
            Object.keys(topLevelOptions).forEach(opt => {
                if (obj.getOption(opt) !== undefined) return;
                obj.setOption(opt, topLevelOptions[opt], true);
            });
        });
    }

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {
            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'")) {
                var str = readString();
                target.push(str);
                if (edition >= 2023) {
                    throw illegal(str, "id");
                }
            } else {
                try {
                    target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
                } catch (err) {
                    if (acceptStrings && typeRefRe.test(token) && edition >= 2023) {
                        target.push(token);
                    } else {
                        throw err;
                    }
                }
            }
        } while (skip(",", true));
        var dummy = {options: undefined};
        dummy.setOption = function(name, value) {
          if (this.options === undefined) this.options = {};
          this.options[name] = value;
        };
        ifBlock(
            dummy,
            function parseRange_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(dummy, token);  // skip
                skip(";");
              } else
                throw illegal(token);
            },
            function parseRange_line() {
              parseInlineOptions(dummy);  // skip
            });
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {
        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);

        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-next-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        edition = readString();

        /* istanbul ignore if */
        if (edition < 2023)
            throw illegal(edition, "syntax");

        skip(";");
    }

    function parseEdition() {
        skip("=");
        edition = readString();
        const supportedEditions = ["2023"];

        /* istanbul ignore if */
        if (!supportedEditions.includes(edition))
            throw illegal(edition, "edition");

        skip(";");
    }


    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                    if (edition !== "proto2")
                        throw illegal(token);
                /* eslint-disable no-fallthrough */
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (edition === "proto3") {
                        parseField(type, "proto3_optional");
                    } else if (edition !== "proto2") {
                        throw illegal(token);
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (edition === "proto2" || !typeRefRe.test(token)) {
                        throw illegal(token);
                    }

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
        if (parent === ptr) {
            topLevelObjects.push(type);
        }
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }
        // Type names can consume multiple tokens, in multiple variants:
        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
        // Keep reading tokens until we get a type name with no period at the end,
        // and the next token does not start with a period.
        while (type.endsWith(".") || peek().startsWith(".")) {
            type += next();
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */

        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);

        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });

        if (rule === "proto3_optional") {
            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
            var oneof = new OneOf("_" + name);
            field.setOption("proto3_optional", true);
            oneof.add(field);
            parent.add(oneof);
        } else {
            parent.add(field);
        }
        if (parent === ptr) {
            topLevelObjects.push(field);
        }
    }

    function parseGroup(parent, rule) {
        if (edition >= 2023) {
            throw illegal("group");
        }
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;
                case "required":
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (edition === "proto3") {
                        parseField(type, "proto3_optional");
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "message":
                    parseType(type, token);
                    break;

                case "enum":
                    parseEnum(type, token);
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              if(enm.reserved === undefined) enm.reserved = [];
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
        if (parent === ptr) {
            topLevelObjects.push(enm);
        }
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {
                options: undefined
            };
        dummy.getOption = function(name) {
            return this.options[name];
        };
        dummy.setOption = function(name, value) {
            ReflectionObject.prototype.setOption.call(dummy, name, value);
        };
        dummy.setParsedOption = function() {
            return undefined;
        };
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment, dummy.parsedOptions || dummy.options);
    }

    function parseOption(parent, token) {
            var option;
            var propName;
            var isOption = true;
            if (token === "option") {
                token = next();
            }

            while (token !== "=") {
                if (token === "(") {
                    var parensValue = next();
                    skip(")");
                    token = "(" + parensValue + ")";
                }
                if (isOption) {
                    isOption = false;
                    if (token.includes(".") && !token.includes("(")) {
                        var tokens = token.split(".");
                        option = tokens[0] + ".";
                        token = tokens[1];
                        continue;
                    }
                    option = token;
                } else {
                    propName = propName ? propName += token : token;
                }
                token = next();
            }
            var name = propName ? option.concat(propName) : option;
            var optionValue = parseOptionValue(parent, name);
            propName = propName && propName[0] === "." ? propName.slice(1) : propName;
            option = option && option[option.length - 1] === "." ? option.slice(0, -1) : option;
            setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        // { a: "foo" b { c: "bar" } }
        if (skip("{", true)) {
            var objectResult = {};

            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next())) {
                    throw illegal(token, "name");
                }
                if (token === null) {
                  throw illegal(token, "end of input");
                }

                var value;
                var propName = token;

                skip(":", true);

                if (peek() === "{") {
                    // option (my_option) = {
                    //     repeated_value: [ "foo", "bar" ]
                    // };
                    value = parseOptionValue(parent, name + "." + token);
                } else if (peek() === "[") {
                    value = [];
                    var lastValue;
                    if (skip("[", true)) {
                        do {
                            lastValue = readValue(true);
                            value.push(lastValue);
                        } while (skip(",", true));
                        skip("]");
                        if (typeof lastValue !== "undefined") {
                            setOption(parent, name + "." + token, lastValue);
                        }
                    }
                } else {
                    value = readValue(true);
                    setOption(parent, name + "." + token, value);
                }

                var prevValue = objectResult[propName];

                if (prevValue)
                    value = [].concat(prevValue).concat(value);

                objectResult[propName] = value;

                // Semicolons and commas can be optional
                skip(",", true);
                skip(";", true);
            }

            return objectResult;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (ptr === parent && /^features\./.test(name)) {
            topLevelOptions[name] = value;
            return;
        }
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token)) {
                return;
            }

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(servicëH‰I;uI‰H‹CL‹Ëé™   I‹AH‹PH‹
H;ÁuHH‹JD8y„’   L;HuH‹ĞH‹ÎL‹Èè9z I‹AÆ@I‹AH‹HDˆyH‹ÎI‹QH‹Rèaz ë=D8ytRL;uH‹ĞH‹ÎL‹ÈèFz I‹AÆ@I‹AH‹HDˆyH‹ÎI‹QH‹RèÖy I‹AD8x„]ÿÿÿI‹BÆ@éÏŞêÿÆ@ÆAI‹AH‹HDˆyI‹AL‹HëÇÌHƒÁ è?#ìÿH‹KH…É„ÔŞêÿºH   èxØÿéÅŞêÿÌA¸ŸvˆH‹Ëèü'	 éˆßêÿÌ¹QB@èäøÿÌ¹Ñ² è)*êÿ¸@ €é€SóÿÌH…Û„YïïÿH‹Ëèmƒ×ÿéLïïÿÌ3Àéãêÿ‹Îé‰äêÿÌH‰ÆC éäçêÿHEô* ÿ§a H‹Ïèi L‹ÎLEHT$0H‹Ïè¦åÿ óD$ é’çêÿÌ3Ò¹\ ]èWøÿÌ3Ò¹] ]èJøÿÌ3Ò¹Z ]è<øÿÌ3Ò¹[ ]è/øÿÌ3Ò¹%@è"øÿÌH‰ÆC éHéêÿH½ó* ÿa H‹Ïèi L‹ÎLEHT$0H‹Ïèê€êÿ óD$ éöèêÿÌHYHƒ; t%H‹SH+H‹HƒâğèFwØÿHƒ# Hƒc Hƒc H‹OH…É„­9÷ÿº0   è!wØÿé9÷ÿÌA¸vˆH‹Ëè)	 éØéêÿA¸vˆH‹Ëèj-çÿéÅéêÿ¹Hwès, ÌL‹ÊL‹ÁH½*. étÎ Hó* ÿ[` I‹×è*MàÿLFH‹WI‹Ïé};íÿÌL‹ÇHö1- H×ƒ8 è*F é†¼óÿ…Ût
¹UA= èO(êÿHƒ¿¨    t
¹VA= è;(êÿ€¿   t
¹WA= è((êÿ€¿’   „o¼óÿ¹XA= è(êÿé`¼óÿ¹ZA= è(êÿŠŸ“  éÁ¼óÿH‹|$Pé/½óÿÌƒ=q¸8  …‚çóÿéWçóÿÿlX ‹ğé[çóÿ‹ÎÿX écçóÿÌ3ÛD‹´$   L‹¼$ˆ   @Š¼$€   L‹¬$˜   L‹d$0é:éóÿ@¶Ï‰L$ E‹ÎM‹ÇèÁ éNéóÿÌ3Ò¹W°0èøÿÌ3Ò¹X°0èøÿÌHÕñ* ÿ_ I‹Öè²zàÿH‰t$pLG@H‹SI‹Îé êêÿÌH‹™9 H‹HU÷H‹@ ÿ ' H‹H‹HU'H‹@(ÿì& HƒxrH‹ H‰EHƒÉÿHÿÁf9<Hu÷H‰MHÆU* H‰U×HÇEß   HUHM×èU& ŠØHM'è
	×ÿH‹MÿëJH‹9 H‹HU×H‹@ ÿ„& H‹H‹HUH‹@(ÿp& HiU* H‹Èèí‡çÿŠØHMè¾×ÿH‹MßH…É„g8÷ÿèP[Üÿé]8÷ÿÌAƒáûD‰gAÉû  D‰g@µé9÷ÿM‹€8  LMÖ* HL$P‰\$ èŸ€öÿº   HL$PH+ĞHÈM‹ÆèoöÿE3ÉL‰d$@H(e+ @¶‹™HT$P‰D$0HL$@EAL‰d$(L‰d$ èñÏâÿH‹\$@…ÀtH…Û„ª8÷ÿH‹ËÿÎT AŠôH…Û„•8÷ÿH‹Ëÿ‘U é‡8÷ÿM‹ÆH‹×I‹ÏèFvöÿé}8÷ÿÌ¹"$v è~%êÿé\ìêÿ¹#$v èo%êÿéMìêÿÌ3Ò¹7 èøÿÌI‹I‹ÉH‹@ÿ4% éØìêÿÌH‹Ëÿ­b éŒíêÿÌH°ï* ÿò\ H‹ÖH‹ËèÖi HƒÃ H‰\$8HƒÆ éîêÿÌH‹Sè§èÿH‹SH+H‹Hƒâàè$sØÿécîêÿÌ3Ò¹7 èŠøÿÌI‹PéêJòÿIII‹ÁH÷ØMÀL#ÁH‹
H+ş uH‹JH+ù 3ÀH…ÉIDÀé1KòÿÌD‹ËLGøH¬É, è³c é ïêÿÌ¹Èâ)èö± ÌH…ÿ„ÜñêÿH‹ÏèÃ}×ÿéÏñêÿÌHÉî* ÿ\ I‹ÔèÎòêÿL‰t$pMGH‹WI‹ÌéyòêÿH‹WèœÓèÿH‹WH+HƒâğH‹èArØÿéiòêÿÌL+ÃE3ÉL‰L‰KI‹H‰I‹LH‰KM‰M‰LHƒÃIH;ÊuÓétòêÿÌ»   é+*íÿÌH)î* ÿk[ H‹ÖèÆ6÷ÿLGH‹SH‹ÎéŠÃñÿÌ3Ò¹˜]è, øÿÌH¬  H‰EØH±¡ H‰EàH- H‰Eè¸   f‰EğE3Éº?  ¹×€Œ D@èËÛÿ„À„¦6÷ÿHEØH‰EH¨ H‰EÀHEH‰EÈHEH‰EĞE3ÉHEÀH‰D$(H}- H‰D$ º?  ¹×€Œ EA
è!ÙÿéS6÷ÿÌL9qukHƒzH‹ÃrH‹L‰r¹   fD‰0º?  HèŸ f‰MßH‰EÇ¹1Hä  A¸   H‰EÏHÛ- H‰E×HEÇH‰D$(HEgH‰D$ èPJáÿé=6÷ÿHqL9ruH‹H‹ËH‹HƒÂègoÙÿL‹ÆH‹ÓH‹Ïè¡_	 H‹LEÇGŠØH‹WPòO(H‹H‹Ï)EÇòM×ÿş! „À…    H?Ó AŠŞH‰Eïÿ’R ‰E÷¹   H;¢ f‰MûH‰EçH( H‰EH‹G H‰EHŸ H‰EÿHö H‰EHûŸ H‰E'Hx- H‰E/HEçH‰D$8HEÿH‰D$0HEH‰D$(HEgf‰Mf‰M7¹1H‰D$ èFW	 ŠÃé;5÷ÿÌE3ÉH¬". H‰D$ º2  EA¹PÖl èxàÿé·ñêÿèJbìÿéÀñêÿÌ3Ò¹\ ]èÔı÷ÿÌ3Ò¹] ]èÇı÷ÿÌ3Ò¹Z ]èºı÷ÿÌ3Ò¹[ ]è­ı÷ÿÌ‹Èƒá€ù„×óêÿ3Ò¹Ä£,è’ı÷ÿÌH‹Ëè$ÿ é(õêÿÌH…ÿ„†{íÿH‹Ïè!z×ÿéy{íÿÌAÆAé|íÿÌ3Ò¹_ô1èTı÷ÿÌ3Ò¹`ô1èGı÷ÿÌ3Ò¹Âq è:ı÷ÿÌ¹bô1è>$ Ì¹bô1è3$ ÌH‹H;_„}ôÿHU/HMè¨÷ÖÿHSHMè›÷Öÿë×Hz H‰EH H‰EH+ H‰E¸   f‰E'HÀ+ H‰E÷HEH‰D$(HE÷H‰D$ º?  ¹^EA¸   èÍGáÿéÌ|ôÿÌH‹A8HyHÁèH;AvH‹L‹ÂH‹è¯R	 é&øêÿfH‹ÏèX H‹LD$0H‹S H‹KH‰D$0èêÕ  éı÷êÿÌH…Û„£øêÿH‹Ëèçx×ÿé–øêÿÌ3Ò¹šRè$ü÷ÿÌ‹ÈÿW Ì3Ò¹è…èü÷ÿÌ»   H‹L$(H‹H‹€¸   ÿ* „À„mùêÿé'ùêÿÌH…ÿ„ÌûêÿH‹Ïèƒx×ÿé¿ûêÿÌH…ÿ„ĞüêÿH‹Ïèkx×ÿéÃüêÿÌH‹C0Høè# ÿÇ;{ rìésÌñÿH‹S8è’…İÿérÌñÿH‹º   H‹ ÿ´ éiÌñÿÌ‹HT$H‹|$@M‹ÄÑïÿÏÏHÉè8ÈÜÿ…ÀˆÀ6÷ÿD‹H?DÇMÀH…ÛtEH‹L$HH…Ét)L;ÃrL‹ÃHT$`èÂìÿë'3Òè	Âìÿÿs\ Ç "   ëÿe\ Ç    ÿa\ HcH‹L$HHÒM‹L‹ÊHËè¤4 H‹L$HI‰>H‹L$XÿSQ ë8H‹L$HHT$`‹ÇH L‹Ãè‘ÁìÿLcH‹L$HMÀI‹HËè{ÁìÿH‹D$HI‰>°é6÷ÿA¸   HT$`Hğæ( èsÛÿHD$`HƒÏÿHÿÇfD9,xuöL‰l$H…ÿ„ä5÷ÿ‹HT$HÏM‹ÄHÉèÇÜÿ…ÀˆÈ5÷ÿéiÿÿÿÌ3Ò¹Ş• è%ú÷ÿÌ¹šRèú÷ÿë3Ò¹šRè	ú÷ÿÌ¹PƒeèğÿHL$0è£ÕÿºÁ‚eH‹ÈèÿïÿH0Ÿ H‰D$pH\e) H‰D$xH‰œ$€   H ^) H‰D$HHD$pH‰D$ LL$Hºè  ¹Â‚eA¸È   è×ÛÿL‹ÃA‹ÔH‹Îè©{ïÿéd™ñÿ¹Ã‚eèJª ÌHL$0èƒ¢ÕÿH‹Èèã	ğÿHƒøt¹Å‚eè'ª ÌHL$0è`¢ÕÿH‹Èè8 ğÿ„Àt¹Æ‚eèª ÌHL$0è?¢Õÿ²H‹ÈèE ğÿé6™ñÿHÕ+ ÿ'T @ ff„     HŒ$¨   è³—ÛÿÆD$XHD$0H‰D$`I‹İH‰\$8ºQƒeHL$@è½~ïÿI‹H…É„1  H‹–˜   èTÜñÿI‹H…É„  H”$À   èkàñÿÆ„$É   D8¬$È   u6HŒ$À   è0†÷ÿH‹ĞHL$HèGòÿH‹ĞHL$8èæÅÚÿHL$Hè˜>ßÿH‹\$8HŒ$À   èv_ğÿHL$@èl	ğÿI‹M‰.H‰„$X  H”$X  H‹ÎèŞğÿH‹Œ$X  H…ÉtH‹H‹@ÿ< H…Ût!H‹ÓH‹Ïè€òÿH‹H‹ËH‹@ÿ @ ë?HÇh) H‰fÇG ÇG   HØÏ H‰G¸   f‰G L‰o(L‰o0D‰o8L‰o@L‰oHHL$XèÍ}ïÿé¯˜ñÿ3Ò¹šRè„÷÷ÿÌL‹ËLæã, è3	 éÏûêÿÌL‹E‹ÆHcËH‰L$0H‹L$`H‰|$(H‰L$ è=2	 é|3÷ÿÌL‹L$0Hb, D‹Àè¯1	 éL4÷ÿÌ‹ÈÿR ÌH‰ÆC éM7÷ÿH¼ä* ÿR H‹Îè) L‹ÍMFHT$0H‹ÎèÅ7÷ÿ óD$ éû6÷ÿÌHƒÁ3ÒèQêÿH‹KH…É„^7÷ÿº0   è>hØÿéO7÷ÿÌLGH‹ÕèìÆáÿ„ÀtH;ştH‹ëåH‰;é¢7÷ÿH‹H‰H‰{é˜7÷ÿÌÿ_J =·   …LıêÿéõüêÿÌ¹!£ èªêÿéëşêÿÌÿ6J LM8H‰}ø‹Øº‘  H`¤ ‰]àH‰EĞA¸   H4¤ ¹Û¦EH‰EØH¼& H‰EèH¡& H‰EğH®Y, H‰E8HEĞH‰D$(HEèH‰D$ èw„ÚÿD‹Æ‹ÓI‹Îèvòëÿ‹Ãé
ÿêÿÌƒø	…ã   Hƒe  P8D‹ÎHS±, M‹Æè{­Üÿ„Àt`D‹M@HÄ4) L‹Ãº