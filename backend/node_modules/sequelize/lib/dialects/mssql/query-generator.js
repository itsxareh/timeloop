"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const _ = require("lodash");
const Utils = require("../../utils");
const DataTypes = require("../../data-types");
const TableHints = require("../../table-hints");
const AbstractQueryGenerator = require("../abstract/query-generator");
const randomBytes = require("crypto").randomBytes;
const semver = require("semver");
const Op = require("../../operators");
const throwMethodUndefined = function(methodName) {
  throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};
class MSSQLQueryGenerator extends AbstractQueryGenerator {
  createDatabaseQuery(databaseName, options) {
    options = __spreadValues({ collate: null }, options);
    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : "";
    return [
      "IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =",
      wrapSingleQuote(databaseName),
      ")",
      "BEGIN",
      "CREATE DATABASE",
      this.quoteIdentifier(databaseName),
      `${collation};`,
      "END;"
    ].join(" ");
  }
  dropDatabaseQuery(databaseName) {
    return [
      "IF EXISTS (SELECT * FROM sys.databases WHERE name =",
      wrapSingleQuote(databaseName),
      ")",
      "BEGIN",
      "DROP DATABASE",
      this.quoteIdentifier(databaseName),
      ";",
      "END;"
    ].join(" ");
  }
  createSchema(schema) {
    return [
      "IF NOT EXISTS (SELECT schema_name",
      "FROM information_schema.schemata",
      "WHERE schema_name =",
      wrapSingleQuote(schema),
      ")",
      "BEGIN",
      "EXEC sp_executesql N'CREATE SCHEMA",
      this.quoteIdentifier(schema),
      ";'",
      "END;"
    ].join(" ");
  }
  dropSchema(schema) {
    const quotedSchema = wrapSingleQuote(schema);
    return [
      "IF EXISTS (SELECT schema_name",
      "FROM information_schema.schemata",
      "WHERE schema_name =",
      quotedSchema,
      ")",
      "BEGIN",
      "DECLARE @id INT, @ms_sql NVARCHAR(2000);",
      "DECLARE @cascade TABLE (",
      "id INT NOT NULL IDENTITY PRIMARY KEY,",
      "ms_sql NVARCHAR(2000) NOT NULL );",
      "INSERT INTO @cascade ( ms_sql )",
      "SELECT CASE WHEN o.type IN ('F','PK')",
      "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'",
      "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END",
      "FROM sys.objects o",
      "JOIN sys.schemas s on o.schema_id = s.schema_id",
      "LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id",
      "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ",
      quotedSchema,
      "ORDER BY o.type ASC;",
      "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;",
      "WHILE @id IS NOT NULL",
      "BEGIN",
      "BEGIN TRY EXEC sp_executesql @ms_sql; END TRY",
      "BEGIN CATCH BREAK; THROW; END CATCH;",
      "DELETE FROM @cascade WHERE id = @id;",
      "SELECT @id = NULL, @ms_sql = NULL;",
      "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;",
      "END",
      "EXEC sp_executesql N'DROP SCHEMA",
      this.quoteIdentifier(schema),
      ";'",
      "END;"
    ].join(" ");
  }
  showSchemasQuery() {
    return [
      'SELECT "name" as "schema_name" FROM sys.schemas as s',
      'WHERE "s"."name" NOT IN (',
      "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'",
      ")",
      "AND",
      '"s"."name" NOT LIKE',
      "'db_%'"
    ].join(" ");
  }
  versionQuery() {
    return [
      "DECLARE @ms_ver NVARCHAR(20);",
      "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));",
      "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"
    ].join(" ");
  }
  createTableQuery(tableName, attributes, options) {
    const primaryKeys = [], foreignKeys = {}, attributesClauseParts = [];
    let commentStr = "";
    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        let dataType = attributes[attr];
        let match;
        if (dataType.includes("COMMENT ")) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace("COMMENT", "").trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          dataType = commentMatch[1];
        }
        if (dataType.includes("PRIMARY KEY")) {
          primaryKeys.push(attr);
          if (dataType.includes("REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace("PRIMARY KEY", "")}`);
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
          }
        } else if (dataType.includes("REFERENCES")) {
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }
    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(", ");
    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== "string") {
            indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
          }
          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(", ")})`);
        }
      });
    }
    if (pkString.length > 0) {
      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
    }
    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
      }
    }
    const quotedTableName = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,
      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(", ")})`,
      ";",
      commentStr
    ]);
  }
  describeTableQuery(tableName, schema) {
    let sql = [
      "SELECT",
      "c.COLUMN_NAME AS 'Name',",
      "c.DATA_TYPE AS 'Type',",
      "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',",
      "c.IS_NULLABLE as 'IsNull',",
      "COLUMN_DEFAULT AS 'Default',",
      "pk.CONSTRAINT_TYPE AS 'Constraint',",
      "COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',",
      "CAST(prop.value AS NVARCHAR) AS 'Comment'",
      "FROM",
      "INFORMATION_SCHEMA.TABLES t",
      "INNER JOIN",
      "INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA",
      "LEFT JOIN (SELECT tc.table_schema, tc.table_name, ",
      "cu.column_name, tc.CONSTRAINT_TYPE ",
      "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ",
      "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ",
      "ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ",
      "and tc.constraint_name=cu.constraint_name ",
      "and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk ",
      "ON pk.table_schema=c.table_schema ",
      "AND pk.table_name=c.table_name ",
      "AND pk.column_name=c.column_name ",
      "INNER JOIN sys.columns A;@i º§  ¹8tt3èüûÿH‹}wH…ÿt+L‰uw‹ÃğÁGÃuH‹3ÒH‹ÏH‹@8ÿb• H‹Ïÿ™ ‹ÆLœ$Ğ   I‹[ I‹s8I‹ãA^_]ÃL‰2ºH  eH‹%X   H‹D94
†ˆ   H‚! H‰E¿¾Í€‰uÇfD‰uËH	0 H‰E·HE·H‰D$ LE8f º§  ¹wfj2A¸
   èœ3ÿH‹}wH…ÿ„sÿÿÿƒËÿ‹ÃğÁGÃ…aÿÿÿH‹3ÒH‹ÏH‹@8ÿ§” H‹ÏÿŞ é@ÿÿÿH‹F(H‹H H‰M§L‰u¯ÿ¢‹ …Àt	‹Èÿ‹ ¸   ğÁE¯ÿÀƒøuD9u³…¯  ÿ¼‹ ‰E³‹F Ñè$„À   ¾ Ê€Hh/ H‰EHb! H‰E'H’È" H‰E/fD‰u7Hz! H‰E×‰ußfD‰uãH/ H‰EÏHEH‰D$(HEÏH‰D$ LŠãh º§  ¹xfj2èCûÿë(‹ÃğÁE¯Ãuÿ(‹ 9E³…&  D‰u³H‹M§ÿÁŠ ‹E¯…ÀuÑD9u³„şÿÿÿúŠ 9E³…ë   éøıÿÿLEwH‹Ö‹Ëèh ‹ğ…À‰‚   HÍ€! H‰Eï‰u÷fD‰uûHZ. H‰Eç¹2   DAØş@ €DDÁHEçH‰D$ Lk4i º§  ¹yfj2è  zÿë$‹ÃğÁE¯ÃuÿqŠ 9E³usD‰u³H‹M§ÿŠ ‹E¯…ÀuÕéHÿÿÿH‹EwL‰uwH‰‹E¯…À„2ÿÿÿ‹ÃğÁE¯Ãuÿ+Š 9E³u-D‰u³H‹M§ÿÈ‰ ‹E¯ëÏ3Ò¹Äô1èë¾ÿÌ3Ò¹Ãô1èŞ¾ÿÌ3Ò¹Åô1èÑ¾ÿÌH‹I(H‹H‹@ Hÿ%n’ H‰\$H‰t$H‰|$ UAVAWH‹ìHƒìpE3ÿI‹ğL‰}0L‹òH‹ùM…ÀuvHY- »@ €H‰EØLéVf Hò_! ¹zfj2H‰EàH’f H‰Eèº§  HZ! fD‰}ÔH‰EÈHê, H‰EÀHEØH‰D$(HEÀH‰D$ ‰]ĞfD‰}ğè/‹ûÿé  è]  „Àt3HÚ, »ÿÿ €H‰EØLÚ4i Hs_! ¹23n8H‰EàHóÅ" é|ÿÿÿH‹O(H‹AH…ÀtH‹PëI‹×H‹ILM0A°èŒÄşÿ‹Ø…ÀyRH³~! ‰]ĞH‰EÈL3i H>, fD‰}ÔH‰EÀû@ €¸2   º§  ¹qdj2D@ØDDÀHEÀH‰D$ èæzÿëQM…öt)H‹G(M‹ÆD‹H‹U0H‹HH‹H‹@0ÿÜ …À¹W €DÙH‹G(A¸   H‹U0H‹HH‹H‹@ ÿ³ ÿÀ‰L\$p‹ÃI‹[ I‹s(I‹{8I‹ãA_A^]Ã@USVWATAUAVAWH¬$øïÿÿ¸  è¡É H+àH‹×®€ H3ÄH‰…ğ  L‹µp  L‹úH‹½x  3ÒE¶áL‹éA‹ğH‰T$`M…ÿ„·  M…ö„¹  H…ÿ„»  A¹$  I‰H‰A;ñ‚•   HD= ˆT$xHÙf H‰L$hH‰D$pLX3i Hif f‰T$zH‰Eˆ»pÊ€H4}! H‰M€H‰D$H¹teaxH¿* ˆUH‰D$@HD$hH‰D$0HE€H‰D$(HD$@f‰U’f‰T$Tº§  H‰D$ ‰\$Pè{‰ûÿéĞ  LE ‹ÖI‹Ïè¨´ÿLD$`HT$XHM èÏşÿ3É‹Ø…ÀyZf‰L$TLQ3i ¹ueaxA¸
   ‰\$PH“|! û@ €H‰D$Hº§  H* H‰D$@A@(DDÀHD$@H‰D$ èÜ›zÿéM  H‹T$`H…ÒtR‹D$XHM HÀH+ÂHÈH‹ÆHÑù‹ÉH+ÁIGH‰HE H+ĞHÑú‹ÂHÀ‹ÊH=H  ƒ(  3ÿf‰| …Òu‹ßéñ   ‹L$X3ÿfƒ} /ubQHM è²×şÿ‹Ø…À‰   Hz! ‰\$PH‰D$HLU2i H®) f‰|$TH‰D$@º§  HD$@¹Òvˆ A¸2   H‰D$ èñ,ÿé‚   I‹E(H‹PH…ÒtH‹BëH‹ÇD‹ÁHU H‹Èè—Ñşÿ‹Ø…Àyf‰|$TL3i ¹yeaxé«şÿÿHM è6‡ÿI‹M(E‹ÌL‰t$ D@ÿH‹IH‹L‹RHHU¡I‹Âÿ¶ ‹Ø¸Ë€û €DØ‹ÃH‹ğ  H3Ìèµ· HÄ  A_A^A]A\_^[]ÃèäÁ Ì¹qeaxè½¹ÿÌ¹reaxè²¹ÿÌ¹seaxè§¹ÿÌHƒì(H‹A(H‹@H…Àt"H‹@H…Àt€xT ”ÀHƒÄ(Ã3Ò¹ Rèr¹ÿÌ3Ò¹šRèe¹ÿÌH‰\$UVWATAUAVAWH‹ìHƒìpL‹âL‹ñE3íA‹õE‹ıL‰mPA‹ıA‹İè‹ÿÿÿ„ÀuL‰d$ LMPE3À3ÒI‹Îèı  ‹ğ…ÀyTH$z! H‰EÈ‰uĞfD‰mÔH±' H‰EÀAE2EE
ş@ €DDÀHEÀH‰D$ L1i º§  ¹2gj2èX™zÿéõ  ş ¡Ì …Ş   A‹õ‹ÎÁù…öytáÿ  ùŒ   t-ùË   t%‹Îá  ÿ  tÿ©ÿÿüÿuù   uşÍ€u9I‹N(H‹H‹@0ÿŒ ö@Hu"I‹N(H‹H‹@0ÿô‹ ‹HH÷Á   uƒÉ‰HHH…ÛtH‹H‹ËH‹@ÿÎ‹ H…ÿtH‹H‹ÏH‹@ÿ¹‹ H‹MPH…ÉtL‰mPH‹H‹@ÿŸ‹ ‹ÆH‹œ$°   HƒÄpA_A^A]A\_^]ÃI‹N(H‹H‹@0ÿt‹ HUXH‹ÈèœÃûÿH‹8L‰(H‹MXH…ÉtL‰mXH‹H‹@ÿH‹ I‹N(H‹H‹@0ÿ7‹ ‹HHá   ù   @”Æ¹H   ÿa… H‹ØH…À„  3ÒH‰P@ˆp Ç@(   H}ÿ H‰H3ô H‰CHXô H‰CL‰s0I‹F(H‹HH‰K8‰S@ˆSDƒy•ÀˆCDH…ÿ„²  H‹H‹ÓH‹ÏH‹@Pÿ Š ‹ğ…ÀyYL31i ¹6gj2E3íHìw! H‰EÈH% H‰EÀA¸
   ş@ €A@(DDÀHEÀº§  H‰D$ fD‰mÔ‰uĞè*—zÿéo  H‹HSH‹ÏH‹@pÿ-Š ‹ğ…ÀyLP0i ¹7gj2ë‹I‹N(H‹H‹@0ÿŠ ‹HHá   ù   u1H‹HSH‹ÏH‹€°   ÿà‰ ‹ğE3í…ÀyL€;i ¹oo25é;ÿÿÿE3í¸   f‰EÀH‹EPH‰EÈAƒN H‹EÀ)EàòMĞòMğHUàH‹ÏH‹€˜   ÿ„‰ D‹ø‹ğAƒf ÷D‹àAÁü…ÀyA‹Ìáÿ  ƒùtaE…ÿyOA‹Ä%ÿ  =Œ   tM=Ê   tFA‹Ç%  ÿ=  Ë t7=  Œ t0=   t)=   t"AÿÍ€t  4ÿ©ÿÿşÿtAÿ@ €…æ   I‹N(H‹H‹@0ÿïˆ ‹HHá   ù   …‚   A‹õAƒf ûH‹3ÒH‹ÏH‹@PÿÀˆ H‹3ÒH‹ÏH‹@pÿ®ˆ H‹3ÒH‹ÏH‹€°   ÿ™ˆ I‹N(H‹H‹@0ÿˆˆ E‹ÇH‹×H‹Èè®Âûÿ…ö‰üÿÿ‹ÎÁù‹Á%ÿ  ƒø„AüÿÿéıûÿÿE…ÿ‰xÿÿÿA‹Ä%ÿ  ƒøtE…ÿ‰bÿÿÿAäÿ  AüŒ   u¹7ax6èÓ-…ÿ¾ ‘Ë€…ö‰;ÿÿÿL# f ¹9gj2évıÿÿ¹šRèC´ÿÌ¹HwèÌ´ÿÌH‰\$H‰t$H‰|$ UAVAWH‹ìHƒì0I‹ñM‹ğL‹úH‹Ù3ÿH…Ét-ğÿAH‹H‹€    ÿ¦‡ H‹ÈH…ÀtH‹ H‹@ÿ‘‡ ğÿCH‹C(H‹H H‰Mğ!}ø!}üÿ•~ …Àt	‹Èÿ‘~ ¸   ğÁEøÿÀƒøuƒ}ü …ã   ÿ¯~ ‰EüöC ta‹C Áè¨t
¹cgj2èŞ,…ÿL‹ÎM‹ÆI‹×H‹ËèÉ   ‹ø‹K ƒáû‰K öÁt,ƒáş‰K H‹K(H‹H‹B ÿò† „ÀuH‹K(H‹H‹@ÿİ† ‹Eø…Àt+ƒÈÿğÁEøƒøuÿ+~ 9Eüuaƒeü H‹MğÿÈ} ‹EøëÑƒ}ü tÿ~ 9Eüu#H‹Ëèşÿ‹ÇH‹\$XH‹t$`H‹|$hHƒÄ0A_A^]Ã3Ò¹Ãô1è·²ÿÌ3Ò¹Äô1èª²ÿÌ3Ò¹Åô1è²ÿÌH‰\$L‰D$UVWATAUAVAWHl$ÙHìĞ   I‹ùM‹àL‹êH‹ñE3öL‰uÇA‹ŞH‹I(H‹H‹@0ÿ† ‹HHá `  ù    ”EgL‹OH‹NH…É„°  A‹Ö‹A,…ÀtH‹I0D‹ÀH‹€   HIIƒèuí…ÒA•ÀL‰L$ LMÇº   H‹ÎèØ  ‹ø= ¡Ì upH‹FH…À„Z  A‹ÎD9p,v#H‹P0D‹@,H‹ˆ€   HRIƒèuí…É…  H‹MÇH…ÉtL‰uÇH‹H‹@ÿH… 3ÀH‹œ$  HÄĞ   A_A^A]A\_^]Ã…ÿyL8f ¹fgj2é  A¿   fD‰}§H‹EÇH‰E¯I‹E E§)E×òM·òMçHU×I‹ÍH‹@8ÿÜ„ ‹ø…ÀyL?7i ¹pgj2éÂ  I‹ÕHMèaHÿÿH‹L‰0H‹MH…ÉtL‰uH‹H‹@ÿ™„ H…Û„\  H‹H‹ËH‹@ ÿ€„ ‹ø…ÀyL“6i ¹xgj2éf  I‹D$I‰D$I‹T$0I‹L$(èpÉ®ÿI‹D$(I‰D$0HÇ, H‰EÇE<   Hxf H‰E×ÇEß   H=ç H‰}§D‰u¯LMLE×HU§I‹ÌèÂ®ÿH‹IL$@H‰L$8D‰|$0H‹‘m H‰L$(D‰t$ L‹ÏE3ÀH‹×H‹ËH‹@@ÿÆƒ ‹ø…ÀyLé6i ¹0hj2é¬  WÀóE§L‰u·H‹FH…À„U  A‹ÎD9p,vH‹P0D‹@,H‹ˆ€   HRIƒèuí‹Ñ…Ét	HM§èKÿH‹NH…É„  HƒÁHU×èİP  L9v„ş  H‹U¯L‹uóH‹}çL‹}ßH…ÿu
fE…ö„‡   M¿æJ‹DçH‰EH;U·tH‰H‹U¯HƒÂH‰U¯ëLEHM§èK¾{ÿH‹U¯3ÀH9E×t;f9E÷|5M…ÿt0H…ÿt+fAƒşw$J9Dçt²HM×èÚ0¯ÿH‹U¯L‹uóH‹}çL‹}ß3ÀH9F„]  éjÿÿÿH‹N(H‹H‹@0ÿˆ‚ ‹HHÁé€átH‹U¯L‹ÂH‹M§L+ÁIÁøDŠMgèšR  M…ÿtƒÊÿH‹%   I‹G@ÿH‚ H‹u§L‹u¯I;öt0L‹ewDŠ}gEŠÏM‹ÄH‹ÓH‹è!¬şÿ‹ø…Àˆ…   HƒÆI;öuÜH‹u§E3öH…ötH‹U·H+ÖHƒâøH‹ÎèÛvÿWÀóE§L‰u·H‹ÇD$0   H‹	m H‰L$(D‰t$ LŒ  E3ÀH‚  H‹ËH‹@Hÿ© ‹ø…Ày~LÌ5i ¹2hj2é   Hón! H‰Eß‰}çE3öfD‰uëH} H‰E×AF2EF
ÿ@ €DDÀHE×H‰D$ L4i º§  ¹1hj2è$zÿH‹M§H…ÉtyH‹U·H+ÑHƒâøèvÿëgH‹H‹ËH‹@(ÿ ‹ø…ÀyQLğ4i ¹3hj2Hdn! H‰E¯Hù H‰E§A¸
   ÿ@ €A@(DDÀHE§H‰D$ ‰}·fD‰u»º§  è¢zÿWÀ3ÀH‰EçI‹E )E§òEçòE·HU§I‹ÍH‹@8ÿ’€ …Ày
¹ymj3è8&…ÿH…ÛtH‹H‹ËH‹@ÿo€ H‹MÇH…ÉtL‰uÇH‹H‹@ÿU€ ‹Çéûÿÿ3Ò¹egj2è¬ÿÌ3Ò¹šRè¬ÿÌ3Ò¹šRèt¬ÿÌH‰\$H‰t$UWAVHl$¹Hìğ   H‹òH‹ùH‹A(H‹H H‰M—E3öL‰uŸÿw …Àt	‹Èÿw »   ‹ÃğÁEŸÃ;ÃuD9u£…  ÿ$w ‰E£‹G Ñè„Ãtv» Ê€HÔ H‰EHyM! H‰E'Hş³" H‰E/fD‰u7Hæl! H‰E¯‰]·fD‰u»Hs H‰E§HEH‰D$(HE§H‰D$ LöÎh º§  ¹4hj2è¯xûÿé$  D9w0   »qÊ€Hd, H‰M¿Hùñe H‰EÇDˆuÏfD‰uÑH‰M×H‰òe H‰EßDˆuçfD‰uéHUl! H‰E÷‰]ÿfD‰uHâ H‰EïHE¿H‰D$0HE×H‰D$(HEïH‰D$ L¤8i º§  ¹5hj2è¥xûÿéŠ   „_ t¹p1p2èE$…ÿƒg ûëu3ÒH‹Ïèñ   H‹ÖH‹Ïè^ñÿÿ‹Ø…ÀyZ3ÒH‹ÏèÖ   HÇk! H‰E‰]fD‰uHT H‰E¸2   D@Øû@ €DDÀHEH‰D$ L=f º§  ¹7hj2èúŠzÿ‹EŸ…Àt+ƒÈÿğÁEŸƒøuÿdu 9E£uXD‰u£H‹M—ÿu ‹EŸëÑD9u£tÿ@u 9E£u‹ÃLœ$ğ   I‹[(I‹s0I‹ãA^_]Ã3Ò¹Ãô1èù©ÿÌ3Ò¹Äô1èì©ÿÌ3Ò¹Åô1èß©ÿÌH‰\$H‰t$WHƒì@H‹Ù@ŠòH‹IH…É„ˆ   E3ÀD9A,vL‹I0D‹Y,I‹ÑE‹ÓH‹HRD€€   IƒêuìE…ÀtXHƒÁ3ÿI‹MI¸€   IƒëuíL!\$(H‰ÿÿLD$ H‰D$ HÇD$0   è!¯ÿ;øt
¹cd45è§"…ÿ@„ötH‹ËèÆ  H‹t$XÇC4   H‹\$PHƒÄ@_ÃH‰\$H‰t$UWATAVAWH‹ìHƒìPH‹I(AŠğD‹úLE0E3ä@ŠÖM‹ñL‰e0èW;şÿH‹]0‹ø=Ë€u@„öt
¹pfaxè+"…ÿ¿ ¡Ì é  …ÿyUHÊi! ‰}ğH‰EèLlf HU fD‰eôH‰Eàÿ@ €¸2   º§  ¹ahj2D@ØDDÀHEàH‰D$ èıˆzÿé¶   L‹MPHK0M‹ÆA‹×èÉ^ ‹ø…À‰™   HXi! ‰}ğH‰EèL1i Hã fD‰eôH‰Eàÿ@ €¸2   º§  ¹8ot2D@ØDDÀHEàH‰D$ è‹ˆzÿ‹Ç¹  ÿ#Á=  Ê t4‹Ç#Á=  Ë t)=  Œ t"=   t=   tÿÍ€t  4ÿ©ÿÿşÿu¿ Ê€H…ÛtH‹KøƒÈÿğÁAƒøuH‹H‹@ÿ;{ L\$P‹ÇI‹[8I‹s@I‹ãA_A^A\_]Ã@SHƒì öA H‹Ùu3è´íÿÿ„Àu*H‹K(ƒK H‹H‹@ ÿóz „ÀuH‹K(H‹H‹@ÿŞz HƒÄ [ÃL‹ÜSHƒì@H‹Ù‹I ‹ÁÑè¨uaƒÉ‰K H‹KH…Ét"IƒcØ HçÿÿIƒcè MCØHƒÁI‰Càè‰
¯ÿöC t*H‹K(ƒc şH‹H‹@ ÿvz „ÀuH‹K(H‹H‹@ÿaz HƒÄ@[Ã@USVWATAUAVAWH¬$xıÿÿHìˆ  H‹¥˜€ H3ÄH‰…p  I‹ùL‰D$XL‹úL‹éL‹¥  E3öA‹öA‹ŞM…ätHAN8ÿFt H‹ØH…À„Ò  Ç@   Hdí H‰L‰{M…ÿtğAÿ‡ˆ   L‰sL‰s L‰s(ÆC0I‹E(H‹H H‰L$@L‰t$HÿÈp …Àt	‹ÈÿÄp ¸   ğÁD$HÿÀƒøuD9t$L…i  ÿàp ‰D$LA‹E Ñè$„å   ¾ Ê€Hš& H‰D$xH.ìe H‰M€DˆuˆfD‰uŠH‰EH¾ìe H‰E˜Dˆu fD‰u¢HŠf! H‰E°‰u¸fD‰u¼H H‰E¨HD$xH‰D$0HEH‰D$(HE¨H‰D$ LÈh º§  ¹94k3èÙrûÿë.ƒÈÿğÁD$Hƒøuÿ+p 9D$L…r  D‰t$LH‹L$@ÿÁo ‹D$H…ÀuÊD9t$L„ü  ÿøo 9D$L…L  éç  ‹…ğ  L4GI;şƒs  ·ƒÁ÷÷Áàÿÿÿu¸   Óà© € t	HƒÇI;şrÛH‹×I;şƒB  ·ƒÁ÷÷Áàÿÿÿu¸   Óà© € u	HƒÇI;şrÛH;×„  L‹ÇL+ÂIÑø3öH‰u`f‰uhHM`èÏ,şÿ„À„"  9u`u
¹lkb3è…ÿI‹MH…É„U  HƒÁH‰t$`LD$`HUhèü¯ÿL‹D$`M…À„0  H‰t$hHD$hH‰D$0Š…   ˆD$(Š…ø  ˆD$ E3ÉH‹T$XI‹Ïè'rÿÿ‹ğ…ÀxMH…Û„ñşÿÿH‹D$hö@t¹tnn5è…ÿë(HKH‰D$pH‹S H;S(t
H‰HƒAëLD$pè†²{ÿé­şÿÿH…d! H‰EÈ‰uĞE3öfD‰uÔH H‰EÀAF2EF
ş@ €DDÀHEÀH‰D$ Lq-i º§  ¹xai5è¶ƒzÿë.ƒÈÿğÁD$Hƒøuÿ$n 9D$L…ª  D‰t$LH‹L$@ÿºm ‹D$H…ÀuÊD9t$L„õ  ÿñm 9D$L…R  éà  ¾ Ë€H H‰E8HCD! H‰E@H(,i H‰EHE3öfD‰uPH­c! H‰Eà‰uèfD‰uìH: H‰EØHE8H‰D$(HEØH‰D$ Lµ+i º§  ¹wai5èvoûÿë.ƒÈÿğÁD$HƒøuÿXm 9D$L…Ş  D‰t$LH‹L$@ÿîl ‹D$H…ÀuÊé/ÿÿÿ¾ Ë€Hı" H‰EğH’èe H‰MøÆE E3öfD‰uH‰ where[Op.or].filter((clause) => {
      let valid = true;
      for (const key in clause) {
        if (typeof clause[key] === "undefined" || clause[key] == null) {
          valid = false;
          break;
        }
      }
      return valid;
    });
    const getJoinSnippet = (array) => {
      return array.map((key) => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };
    if (clauses.length === 0) {
      throw new Error("Primary Key or Unique key should be passed to upsert query");
    } else {
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.includes(keys[0])) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
      }
    }
    const filteredUpdateClauses = updateKeys.filter((key) => !identityAttrs.includes(key)).map((key) => {
      const value = this.escape(updateValues[key]);
      key = this.quoteIdentifier(key);
      return `${targetTableAlias}.${key} = ${value}`;
    });
    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(", ")}` : "";
    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }
  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }
  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    const whereClause = this.getWhereConditions(where, null, model, options);
    return Utils.joinSQLFragments([
      "DELETE",
      options.limit && `TOP(${this.escape(options.limit)})`,
      "FROM",
      table,
      whereClause && `WHERE ${whereClause}`,
      ";",
      "SELECT @@ROWCOUNT AS AFFECTEDROWS",
      ";"
    ]);
  }
  showIndexesQuery(tableName) {
    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;
  }
  showConstraintsQuery(tableName) {
    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
  }
  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;
    if (typeof indexName !== "string") {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
    }
    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
  }
  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }
    if (attribute.references) {
      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
        this.sequelize.log("MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query");
        attribute.onDelete = "";
        attribute.onUpdate = "";
      }
    }
    let template;
    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values && !attribute.values)
        attribute.values = attribute.type.values;
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {
        return this.escape(value);
      }).join(", ")}))`;
      return template;
    }
    template = attribute.type.toString();
    if (attribute.allowNull === false) {
      template += " NOT NULL";
    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.default5ƒc\¿‹„$˜   Hƒ  …ítH«  L‹ÅM…öt‹K`I‹Öè—ÿ‹ø‰{`HL$0èØüÿL\$`‹ÆI‹[ I‹k(I‹s0I‹ãA_A^_Ã@USVWATAUAVAWH¬$Xğÿÿ¸¨  èUî H+àH‹‹Ó~ H3ÄH‰…  M‹éM‹øH‰T$`H‹ÙL‹¥  D‹qI‹øE3ÀE‰HEH‰CHÇC   E8D$tA‹$ëº   E…öAEĞH‹Ëè>œ—ÿ‹Èƒø‡Ç   E3ÀA‹ğD‹KE…Ét<D‰D$XH‹L$`H‹L‰D$(HT$XH‰T$ LEH‹×H‹@ ÿw´ ‹ğE3À…Àx(‹KHùD9C‡oÿÿÿE…ö…Z  D9C‡P  éWÿÿÿH§¡ H‰D$H‰t$PfD‰D$TH1O H‰D$@¸2   D@Øş@ €DDÀHD$@H‰D$ L@h º¨  ¹8xj2èÕÀxÿéñ   E3äƒùû…˜   A‹ôD9ct
¹80s5èYƒÿE…ö…É   ¾ÿÿ €HèN H‰D$hHŒ H‰D$pHxh H‰D$xfD‰e€H÷  H‰D$H‰t$PfD‰d$THN H‰D$@HD$hH‰D$(HD$@H‰D$ L	h º¨  ¹axj2èº¬ùÿëMH©  H‰D$H‰L$PfD‰d$TH3N H‰D$@HD$@H‰D$ Lh º¨  ¹ÆˆA¸   èÄQÿ¾	DË€L;ÿw6I+ÿ¸ÿÿÿÿH;øw)A‰} ‹ÆH‹  H3ÌèôÜ HÄ¨  A_A^A]A\_^[]Ãè¿µtÿÌ@SHƒì ƒ¹€    H‹ÙtE3ÀHƒÁhAPèæÜŸÿHƒ£ø    Hƒ£    ƒc` HƒÄ [ÃH‰\$WHƒì H‹ÙƒÈÿğÁA0ƒøtPH‹H‹@PÿI² H‹øH…Àt;ƒÉÿğÁK(ƒùuH‹H‹AH3ÒH‹Ëÿ"² H‹ËÿY¬ H‹H‹ÏH‹@ÿ² ë)ƒÈÿğÁC(ƒøuH‹3ÒH‹ËH‹@Hÿç± H‹Ëÿ¬ ¸   H‹\$8HƒÄ _Ã@SHƒì H‹ÙğÿA0H‹H‹@Pÿ¦± H‹ĞH…ÀtH‹H‹AH‹Êÿ± ğÿC(¸   HƒÄ [ÃH‹ÄH‰XH‰pH‰xL‰p AWHƒì 3ÿM‹øH‹òL‹ñM…À„‰   H‹H;™  uH‹BH;”  uI‹XëH‹ŞH‹H;— uH‹CH;’ uI‹ÆëH‹ÓèO   I‰H…Àu¿@ €ëH;óuI‹H‹AI‹Îÿ×° H‹\$0‹ÇH‹|$@H‹t$8L‹t$HHƒÄ A_Ã3Ò¹7 èúÜÿÌH‰\$H‰l$H‰t$WHƒì H‹H‹òH+›>  H‹ùuH‹BH+“>  3ÛH…À‹ÓHD×kH…Ò…ö   D‹ÅHZ>  H‹ÎèÛ HWH‹ÏH÷ÙMÀL#Â‹Ó…ÀIDĞH…Ò…Ã   D‹ÅHWh H‹Îè¨ HWH‹ÏH÷ÙMÀL#Â‹Ó…ÀIDĞH…Ò…   D‹ÅH4|! H‹Îèu HWH‹ÏH÷ÙMÀL#Â‹Ó…ÀIDĞH…ÒuaD‹ÅHh H‹ÎèF HW H‹ÏH÷ÙMÀL#Â‹Ó…ÀIDĞH…Òu2HG(H÷ßHÉH#ÈH‹H;© h uH‹FH;¤ h u	H…ÉtHYØH‹ÓH‹\$0H‹ÂH‹l$8H‹t$@HƒÄ _Ã@SHƒìpE3Éº¨  ‹ÙEAè#¨´ÿ„Àt}H‹„$    E3ÉH‰D$Hº¨  H‹„$¨   ‹ËH‰D$PH‹„$°   EAH‰D$XH‹„$¸   H‰D$`H®1 H‰D$0HD$HH‰D$8HD$hH‰D$@HD$0H‰D$(H\İg H‰D$ èŠ¬´ÿHƒÄp[ÃHƒé éçüÿÿHƒéé'ıÿÿHƒééüÿÿHƒéé·üÿÿHƒéé÷üÿÿHƒééçûÿÿHƒéé‡üÿÿHƒééÇüÿÿHƒé é·ûÿÿHƒééWüÿÿHƒé é—üÿÿHƒéé‡ûÿÿH‰\$DˆL$ UVWATAUAVAWHl$éHì   H‹3ÿL‹êH‰}ÏH‹ñ‰}oHUÏH‰}ŸH‹@8I‹ÍEŠøH‰}§‰}¯f‰}³ÿ­ ‹Ø…ÀyRHùš û@ €H‰E¿DG
H„H ¹coj2H‰E·LŒh G2DDÀf‰}ËHE·‰]Çº®  H‰D$ è/ºxÿé™  H‹UÏHƒús9¹doj2èæRƒÿH“š »ÿÿ €H‰E¿LkØf HH ¹eoj2H‰E·A¸
   ëHƒÂêH‰|$(H‰HMoI‹E LEŸH‰L$ A¹   I‹ÍH‹@ÿÓ¬ E3Û‹Ø…Ày>H+š fD‰]ËH‰E¿EC
H·G û@ €H‰E·Lşh AC2¹foj2DDÀé+ÿÿÿƒ}oA¼Í€„ª   Hıd ÆEÇH‰EH¦Y AŠÇH‰M·4fD‰]ÉˆE—H.d H¯™ H‰U¿H‰D$H¾sxo2H:G D‰d$PH‰D$@HE·H‰D$0HE‡H‰D$(HD$@fD‰\$TfD‰]™H‰M‡A‹ÜL¨d º®  H‰D$ ‹Îèç¥ùÿE„ÿ…1  ‹Îè‹Qƒÿé%  }ŸPK¿  ÿtbLEŸI‹ÕH‹ÎèÉ  E3Û‹Ø…ÀyJE„ÿ„ö  #Ç=  Ê t5‹Ã#Ç=  Ë t*=  Œ t#=   t=   tA;Üt  4ÿ©ÿÿşÿ…¸  A‹ÛE„ÿ…´   D8]w…ª   ·M³HƒÁHH;MÏ„•   HsX ÆD$PH¯d H‰L$@H‰EH÷d Hx˜ H‰M‡H‰E¿L1h HF H‰T$HH‰E·»BË€HD$@fD‰\$RH‰D$0¹uxo2HE‡Dˆ]—H‰D$(HE·fD‰]™‰]ÇfD‰]Ëº®  H‰D$ èª¤ùÿéø  D·E£¿
   L‹6D‹M¯D‹U«·U©·M§·E¥ÇE_ÿÿ  fD;E_t"f;E_tf;U_tf;M_tAƒúÿt
Aƒùÿ…v  Hƒe· Hƒeã L‰]¿D‰]ÇD‰]×L‰]ÛD‰]ëL‰]ïL‰]÷L‰]ÿL‰]Iƒş‚>  I‹E HMoL‰\$(LE·H‰L$ IƒÆìA¹   I‹ÖH‹@I‹Íÿì© E3Û‹Ø…ÀyIHD— ‰\$PH‰D$HL<h HÍD fD‰\$TH‰D$@û@ €AC2D‹ÇDDÀ¹goj2HD$@é@üÿÿƒ}otzHd ÆD$PH‰EH½V AŠÇH‰L$@4fD‰\$RˆE—HCd HÄ– H‰T$HH‰D$`¾vxo2HND D‰d$hH‰D$XHD$@H‰D$0HE‡H‰D$(HD$XfD‰]ƒéıÿÿ}·PKt'E„ÿ…ê   D‹M¯D‹U«·U©·M§·E¥D·E£é  E„ÿ…Ã   D9]»„¢   LĞh ¿wxo2A¸PË€A‹ØD‰E—H÷U ÆD$hH‹d H‰L$XH'd H‰T$`H‰D$Hº®  Hñ• H‰L$@H‰E‹ÏHC fD‰]H‰E‡HD$XH‰D$0HD$@H‰D$(HE‡H‰D$ ÆD$PfD‰\$RfD‰]›è<¢ùÿ‹ÏéYüÿÿƒ}ÇtLèh ¿xxo2éSÿÿÿH‹U¿I;Ö‚“   H’d ÆD$hH‰D$HH9U AŠÇH‰L$X4fD‰]ˆD$PH¿d H@• H‰T$`H‰ELÈh HÉB H‰L$@H‰E‡A¸ @Ë€HD$XfD‰\$RH‰D$0A‹ØHD$@D‰E—H‰D$(¾yxo2HE‡fD‰]›é†ûÿÿI‹E HMoL‰\$(LE×H‰L$ A¹8   I‹ÍL‹òH‹@ÿR§ E3Û‹Ø…ÀyHHª” ‰\$hH‰D$`Lrh H3B fD‰]ƒH‰D$Xû@ €AC2D‹ÇDDÀ¹hoj2HD$Xé§ùÿÿƒ}o8„ƒ   Hxd ÆD$hH‰D$HHT AŠÇH‰L$X4fD‰]ˆD$PH¥d H&” H‰T$`H‰E¾zxo2H±A H‰L$@H‰E‡HD$XH‰D$0HD$@H‰D$(HE‡fD‰\$RD‰e—fD‰]›érúÿÿ}×PKtE„ÿu»@Ë€Lh ‰]—¿0yo2éıÿÿL‹MM;Î†“   HÁd ÆD$hH‰D$HHhS AŠÇH‰L$X4fD‰]ˆD$PHîd Ho“ H‰T$`H‰ELWh Hø@ H‰L$@H‰E‡A¸ @Ë€HD$XfD‰\$RH‰D$0A‹ØHD$@D‰E—H‰D$(¾1yo2HE‡fD‰]›éµùÿÿL‹UÿH‹U÷E„ÿ…wrapSingleQuote(table.tableName || table);
    return Utils.joinSQLFragments([
      "SELECT K.TABLE_NAME AS tableName,",
      "K.COLUMN_NAME AS columnName,",
      "K.CONSTRAINT_NAME AS constraintName",
      "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C",
      "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K",
      "ON C.TABLE_NAME = K.TABLE_NAME",
      "AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG",
      "AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA",
      "AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME",
      "WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'",
      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
      `AND K.TABLE_NAME = ${tableName}`,
      ";"
    ]);
  }
  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      "ALTER TABLE",
      this.quoteTable(tableName),
      "DROP",
      this.quoteIdentifier(foreignKey)
    ]);
  }
  getDefaultConstraintQuery(tableName, attributeName) {
    const quotedTable = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      "SELECT name FROM sys.default_constraints",
      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,
      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,
      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,
      ";"
    ]);
  }
  dropConstraintQuery(tableName, constraintName) {
    return Utils.joinSQLFragments([
      "ALTER TABLE",
      this.quoteTable(tableName),
      "DROP CONSTRAINT",
      this.quoteIdentifier(constraintName),
      ";"
    ]);
  }
  setIsolationLevelQuery() {
  }
  generateTransactionId() {
    return randomBytes(10).toString("hex");
  }
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "BEGIN TRANSACTION;";
  }
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }
    return "COMMIT TRANSACTION;";
  }
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "ROLLBACK TRANSACTION;";
  }
  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });
    const dbVersion = this.sequelize.options.databaseVersion;
    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, "11.0.0");
    if (isSQLServer2008 && options.offset) {
      const offset = options.offset || 0;
      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
      let orders = { mainQueryOrder: [] };
      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }
      if (orders.mainQueryOrder.length === 0) {
        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
      }
      const tmpTable = mainTableAs || "OffsetTable";
      if (options.include) {
        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;
        const mainTable = {
          name: mainTableAs,
          quotedName: null,
          as: null,
          model
        };
        const topLevelInfo = {
          names: mainTable,
          options,
          subQuery
        };
        let mainJoinQueries = [];
        for (const include of options.include) {
          if (include.separate) {
            continue;
          }
          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);
          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);
        }
        return Utils.joinSQLFragments([
          "SELECT TOP 100 PERCENT",
          attributes.join(", "),
          "FROM (",
          [
            "SELECT",
            options.limit && `TOP ${options.limit}`,
            "* FROM (",
            [
              "SELECT ROW_NUMBER() OVER (",
              [
                "ORDER BY",
                orders.mainQueryOrder.join(", ")
              ],
              `) as row_num, ${tmpTable}.* FROM (`,
              [
                "SELECT DISTINCT",
                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,
                mainJoinQueries,
                where && `WHERE ${where}`
              ],
              `) AS ${tmpTable}`
            ],
            `) AS ${tmpTable} WHERE row_num > ${offset}`
          ],
          `) AS ${tmpTable}`
        ]);
      }
      return Utils.joinSQLFragments([
        "SELECT TOP 100 PERCENT",
        attributes.join(", "),
        "FROM (",
        [
          "SELECT",
          options.limit && `TOP ${options.limit}`,
          "* FROM (",
          [
            "SELECT ROW_NUMBER() OVER (",
            [
              "ORDER BY",
              orders.mainQueryOrder.join(", ")
            ],
            `) as row_num, * FROM ${tables} AS ${tmpTable}`,
            where && `WHERE ${where}`
          ],
          `) AS ${tmpTable} WHERE row_num > ${offset}`
        ],
        `) AS ${tmpTable}`
      ]);
    }
    return Utils.joinSQLFragments([
      "SELECT",
      isSQLServer2008 && options.limit && `TOP ${options.limit}`,
      attributes.join(", "),
      `FROM ${tables}`,
      mainTableAs && `AS ${mainTableAs}`,
      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`
    ]);
  }
  addLimitAndOffset(options, model) {
    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, "11.0.0")) {
      return "";
    }
    const offset = options.offset || 0;
    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;
    let fragment = "";
    let orders = {};
    if (options.order) {
      orders = this.getQueryOrders(options, model, isSubQuery);
    }
    if (options.limit || options.offset) {
      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {
        let primaryKey = model.primaryKeyField;
        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;
        const aliasedAttribute = (options.attributes || []).find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));
        if (aliasedAttribute) {
          const modelName = this.quoteIdentifier(options.tableAs || model.name);
          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);
          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);
        }
        if (!options.order || !options.order.length) {
          fragment += ` ORDER BY ${tablePkFragment}`;
        } else {
          const orderFieldNames = (options.order || []).map((order) => {
            const value = Array.isArray(order) ? order[0] : order;
            if (value instanceof Utils.Col) {
              return value.col;
            }
            if (value instanceof Utils.Literal) {
              return value.val;
            }
            return value;
          });
          const primaryKeyFieldAlreadyPresent = orderFieldNames.some((fieldName) => fieldName === (primaryKey.col || primaryKey));
          if (!primaryKeyFieldAlreadyPresent) {
            fragment += options.order && !isSubQuery ? ", " : " ORDER BY ";
            fragment += tablePkFragment;
          }
        }
      }
      if (options.offset || options.limit) {
        fragment += ` OFFSET ${this.escape(offset)} ROWS`;
      }
      if (options.limit) {
        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
      }
    }
    return fragment;
  }
  booleanValue(value) {
    return value ? 1 : 0;
  }
  quoteIdentifier(identifier, force) {
    return `[${identifier.replace(/[[\]']+/g, "")}]`;
  }
}
function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}
module.exports = MSSQLQueryGenerator;
//# sourceMappingURL=query-generator.js.map
