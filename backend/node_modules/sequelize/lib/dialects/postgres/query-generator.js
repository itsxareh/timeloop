"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const Utils = require("../../utils");
const util = require("util");
const DataTypes = require("../../data-types");
const AbstractQueryGenerator = require("../abstract/query-generator");
const semver = require("semver");
const _ = require("lodash");
const POSTGRES_RESERVED_WORDS = "all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with".split(",");
class PostgresQueryGenerator extends AbstractQueryGenerator {
  setSearchPath(searchPath) {
    return `SET search_path to ${searchPath};`;
  }
  createDatabaseQuery(databaseName, options) {
    options = __spreadValues({
      encoding: null,
      collate: null
    }, options);
    const values = {
      database: this.quoteTable(databaseName),
      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : "",
      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : "",
      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : "",
      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ""
    };
    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
  }
  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
  }
  createSchema(schema) {
    const databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);
    if (databaseVersion && semver.gte(databaseVersion, "9.2.0")) {
      return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;
    }
    return `CREATE SCHEMA ${this.quoteIdentifier(schema)};`;
  }
  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;
  }
  showSchemasQuery() {
    return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
  }
  versionQuery() {
    return "SHOW SERVER_VERSION";
  }
  createTableQuery(tableName, attributes, options) {
    options = __spreadValues({}, options);
    const databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);
    const attrStr = [];
    let comments = "";
    let columnComments = "";
    const quotedTable = this.quoteTable(tableName);
    if (options.comment && typeof options.comment === "string") {
      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
    }
    for (const attr in attributes) {
      const quotedAttr = this.quoteIdentifier(attr);
      const i = attributes[attr].indexOf("COMMENT ");
      if (i !== -1) {
        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
        attributes[attr] = attributes[attr].substring(0, i);
      }
      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
      attrStr.push(`${quotedAttr} ${dataType}`);
    }
    let attributesClause = attrStr.join(", ");
    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns) => {
        if (columns.customIndex) {
          attributesClause += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(", ")})`;
        }
      });
    }
    const pks = _.reduce(attributes, (acc, attribute, key) => {
      if (attribute.includes("PRIMARY KEY")) {
        acc.push(this.quoteIdentifier(key));
      }
      return acc;
    }, []).join(",");
    if (pks.length > 0) {
      attributesClause += `, PRIMARY KEY (${pks})`;
    }
    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, "9.1.0") ? "IF NOT EXISTS " : ""}${quotedTable} (${attributesClause})${comments}${columnComments};`;
  }
  dropTableQuery(tableName, options) {
    options = options || {};
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? " CASCADE" : ""};`;
  }
  showTablesQuery() {
    const schema = this.options.schema || "public";
    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;
  }
  tableExistsQuery(tableName) {
    const table = tableName.tableName || tableName;
    const schema = tableName.schema || "public";
    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;
  }
  describeTableQuery(tableName, schema) {
    schema = schema || this.options.schema || "public";
    return `SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;
  }
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== "string") {
      return false;
    }
    const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
    const jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;
    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf("(");
        hasJsonFunction = true;
        continue;
      }
      const operatorMatches = jsonOperatorRegex.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }
      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === "(") {
          openingBrackets++;
        } else if (capturedToken === ")") {
          closingBrackets++;
        } else if (capturedToken === ";") {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }
      break;
    }
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }
    return hasJsonFunction;
  }
  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);
        return conditions.join(" AND ");
      }
      if (smth.path) {
        let str;
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }
        if (smth.value) {
          str += util.format(" = %s", this.escape(smth.value));
        }
        return str;
      }
    }
    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }
  addColumnQuery(table, key, attribute) {
    const dbDataType = this.attributeToSQL(attribute, { context: "addColumn", table, key });
    const dataType = attribute.type || attribute;
    const definition = this.dataTypeMapping(table, key, dbDataType);
    const quotedKey = this.quoteIdentifier(key);
    const quotedTable = this.quoteTable(this.extractTableDetails(table));
    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;
    if (dataType instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType) + query;
    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType.type) + query;
    }
    return query;
  }
  removeColumnQuery(tableName, attributeName) {
    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
    const quotedAttributeName = this.quoteIdentifier(attributeName);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
  }
  changeColumnQuery(tableName, attributes) {
    const query = (subQuery) => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
    const sql = [];
    for (const attributeName in attributes) {
      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
      let attrSql = "";
      if (definition.includes("NOT NULL")) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);
        definition = definition.replace("NOT NULL", "").trim();
      } else if (!definition.includes("REFERENCES")) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
      }
      if (definition.includes("DEFAULT")) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);
        definition = definition.replace(/(DEFAULT[^;]+)/, "").trim();
      } else if (!definition.includes("REFERENCES")) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
      }
      if (attributes[attributeName].startsWith("ENUM(")) {
        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
        definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, { schema: false }));
        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
      }
      if (definition.match(/UNIQUE;*$/)) {
        definition = definition.replace(/UNIQUE;*$/, "");
        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace("ALTER COLUMN", "");
      }
      if (definition.includes("REFERENCES")) {
        definition = definition.replace(/.+?(?=REFERENCES)/, "");
        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace("ALTER COLUMN", "");
      } else {
        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
      }
      sql.push(attrSql);
    }
    return sql.join("");
  }
  renameColumnQuery(tableName, attrBefore, attributes) {
    const attrString = [];
    for (const attributeName in attributes) {
      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
    }
    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(", ")};`;
  }
  fn(fnName, tableName, parameters, body, returns, language) {
    fnName = fnName || "testfunc";
    language = language || "plpgsql";
    returns = returns ? `RETURNS ${returns}` : "";
    parameters = parameters || "";
    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
  }
  truncateTableQuery(tableName, options = {}) {
    return [
      `TRUNCATE ${this.quoteTable(tableName)}`,
      options.restartIdentity ? " RESTART IDENTITY" : "",
      options.cascade ? " CASCADE" : ""
    ].join("");
  }
  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    let whereClause = this.getWhereConditions(where, null, model, options);
    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : "";
    let primaryKeys = "";
    let primaryKeysSelection = "";
    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }
    if (options.limit) {
      if (!model) {
        throw new Error("Cannot LIMIT delete without a model.");
      }
      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(",");
      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
      primaryKeysSelection = pks;
      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
    }
    return `DELETE FROM ${table}${whereClause}`;
  }
  showIndexesQuery(tableName) {
    let schemaJoin = "";
    let schemaWhere = "";
    if (typeof tableName !== "string") {
      schemaJoin = ", pg_namespace s";
      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;
      tableName = tableName.tableName;
    }
    return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;
  }
  showConstraintsQuery(tableName) {
    return [
      'SELECT constraint_catalog AS "constraintCatalog",',
      'constraint_schema AS "constraintSchema",',
      'constraint_name AS "constraintName",',
      'table_catalog AS "tableCatalog",',
      'table_schema AS "tableSchema",',
      'table_name AS "tableName",',
      'constraint_type AS "constraintType",',
      'is_deferrable AS "isDeferrable",',
      'initially_deferred AS "initiallyDeferred"',
      "from INFORMATION_SCHEMA.table_constraints",
      `WHERE table_name='${tableName}';`
    ].join(" ");
  }
  removeIndexQuery(tableName, indexNameOrAttributes, options) {
    let indexName = indexNameOrAttributes;
    if (typeof indexName !== "string") {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
    }
    return [
      "DROP INDEX",
      options && options.concurrently && "CONCURRENTLY",
      `IF EXISTS ${this.quoteIdentifiers(indexName)}`
    ].filter(Boolean).join(" ");
  }
  addLimitAndOffset(options) {
    let fragment = "";
    if (options.limit != null) {
      fragment += " LIMIT " + this.escape(options.limit);
    }
    if (options.offset != null) {
      fragment += " OFFSET " + this.escape(options.offset);
    }
    return fragment;
  }
  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }
    let type;
    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {
      const enumType = attribute.type.type || attribute.type;
      let values = attribute.values;
      if (enumType.values && !attribute.values) {
        values = enumType.values;
      }
      if (Array.isArray(values) && values.length > 0) {
        type = `ENUM(${values.map((value) => this.escape(value)).join(", ")})`;
        if (attribute.type instanceof DataTypes.ARRAY) {
          type += "[]";
        }
      } else {
        throw new Error("Values for ENUM haven't been defined.");
      }
    }
    if (!type) {
      type = attribute.type;
    }
    let sql = type.toString();
    if (Object.prototype.hasOwnProperty.call(attribute, "allowNull") && !attribute.allowNull) {
      sql += " NOT NULL";
    }
    if (attribute.autoIncrement) {
      if (attribute.autoIncrementIdentity) {
        sql += " GENERATED BY DEFAULT AS IDENTITY";
      } else {
        sql += " SERIAL";
      }
    }
    if (Utils.defaultValueSchemable(attribute.defaultValue)) {
      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
    }
    if (attribute.unique === true) {
      sql += " UNIQUE";
    }
    if (attribute.primaryKey) {
      sql += " PRIMARY KEY";
    }
    if (attribute.references) {
      let referencesTable = this.quoteTable(attribute.references.model);
      let schema;
      if (options.schema) {
        schema = options.schema;
      } else if ((!attribute.references.model || typeof attribute.references.model == "string") && options.table && options.table.schema) {
        schema = options.table.schema;
      }
      if (schema) {
        referencesTable = this.quoteTable(this.addSchema({
          tableName: referencesTable,
          _schema: schema
        }));
      }
      let referencesKey;
      if (!options.withoutForeignKeyConstraints) {
        if (attribute.references.key) {
          referencesKey = this.quoteIdentifiers(attribute.references.key);
        } else {
          referencesKey = this.quoteIdentifier("id");
        }
        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;
        if (attribute.onDelete) {
          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
        }
        if (attribute.onUpdate) {
          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
        }
        if (attribute.references.deferrable) {
          sql += ` ${attribute.references.deferrable.toString(this)}`;
        }
      }
    }
    if (attribute.comment && typeof attribute.comment === "string") {
      if (options && ["addColumn", "changeColumn"].includes(options.context)) {
        const quotedAttr = this.quoteIdentifier(options.key);
        const escapedCommentText = this.escape(attribute.comment);
        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
      } else {
        sql += ` COMMENT ${attribute.comment}`;
      }
    }
    return sql;
  }
  deferConstraintsQuery(options) {
    return options.deferrable.toString(this);
  }
  setConstraintQuery(columns, type) {
    let columnFragment = "ALL";
    if (columns) {
      columnFragment = columns.map((column) => this.quoteIdentifier(column)).join(", ");
    }
    return `SET CONSTRAINTS ${columnFragment} ${type}`;
  }
  setDeferredQuery(columns) {
    return this.setConstraintQuery(columns, "DEFERRED");
  }
  s@  èöóÿCÿƒø‡´   >>>>>>D‹OAùı  u.º   ë>>>>>>>D·xD‰|$XE…ÿ„ÓüÿÿHHH‰L$`éÊüÿÿf„     Aùü  u-º   A¹   H¢  A¸   èª¸f‰…   H•   ë(D‹GHMH‹T$0ÇD$    èĞ’ˆ 3É…Àˆe  H‹UH`  è6óÿƒûw!¸ì  £Øs>>‹O3Ûƒù…   ‹Óé‚   Cóƒøvnƒûti¸   3ÛB8(uè59 ¸   >>>>J‹(H‹H(9™˜  t	H‹  ëH‹Ø  >H‹€ğ  9XvH‹@ëH‹ÃH…Àtö@HEÃ·@‹O;Èë‹O3Û…É‹Ó•Â…ÒtAA¸  H•   è(7 f9   tH…   HÇ…˜     H‰…€  ëHÇ…˜  ‚   A¹ €  H•€  A¸	   ¹R  è\
ûÿ…À„³  H‹\$XHƒÇ@ÿÆH‰|$@I;ü‚ùüÿÿL‹D$HfD  E…ÿ„y  A·HE3ÿA·P‹Á¯ÂI‹ŞA‹ÿH‰\$@HcğIöH‰t$PL;ösBƒ{4ÿtH‹L$0D‹ÏD‹Çºşÿÿÿè?÷……À„6  HƒÃ@ÿÇH‰\$@H;ŞrÍL‹D$HA·PA·H·Â·É¯ÁL‰t$@H˜IÆH‰D$PL;ğƒé  D‹d$8I‹ÆH‹L$PAƒ~0ÿ„  Ic~0A‹NM‹~ HÁçH|$`‹w;ñtKI+À‰OH‹L$0LEH‹×LHøIÁùèä‘ˆ AƒÈÿE‹È…Àx>H‹UI‹N ëH‹O I‹×è²Êºÿ…À‰w•ÃëH‹O AƒÉÿEÁI‹×è•Êºÿ3Ò…Àt³ë=ŠÚ„Ûu7>A‹F9Gu-A‹F9Gu$A‹F9Gu>>>>>A‹F9GuA‹F9G„Ê  ¹   H…Ü  HÇ@ü€   H@ ƒéuïH‹t$0HÀ  H‹–@  èYóÿH‹ÎèÁşÿH‹ĞH…Àt3H‹H‹   H‹Êÿ¾¾¡„ÀtH‹E€H…Àt#>‹E3ÀH‹Èè;:øÿH‹ĞëH‹W Hà  èóÿ„ÛtI‹×H   èóóÿA‹NE3ÿ9OtAGHÇ…X     Óà‰…@  A‹v9wu:Fÿ¹   ;ÁvFõ;Áw	A‹F9GuFÿƒøw	A‹F9GuA‹F9G„5  ¸   F8<(ufè¿9 ¸   H`  »€   ‹ÓJ‹(D‹€È	  èhïËÿ…À„ä  CƒHÇ…x  @   f‰…l  K„H‹…`  HƒÀD‰½h  H‰XüH@ HƒéuòH‹`  ;wtW¸   HÇC   F8<(uè89 ¸   >VJ‹(H‹‰0  è%²ÿ¸   F8<(uè9 ¸   J‹(H‹ˆ0  H‹H‰Fÿ¹   ;ÁvFõ;ÁwU‹GA9FtLFÿHÇC8   ;ÁvFõ;ÁvfD‰½   H…   ëA‹VE3ÀH‹L$0è8øÿH‹ĞHK èeËºÿ…Àˆ©  Fÿƒø‡©   ‹GA9F„œ   FÿHÇCX   ƒøv
fD‰½   ëeA‹F=ı  uº   ë=ü  u&º   A¹   H¢  A¸   èˆ¸f‰…   ë&E‹NH   L‹D$0º  ÇD$(   ‰D$ èÅ…ˆ H•   HK@èµÊºÿD  …Àˆ
  ‹GA9Ft7HÇCx   H•   A‹NA¸  è!7 H•   HK`èqÊºÿ…ÀˆÒ   >>E3ÉH•À  ¹9  AqD‹Æèkûÿ½x  €   D‹à‰D$8t:H‹`  ~şöC€uH‹Ëè°4ÍÿHƒÃ HƒïuèH‹`  HÇ…x  €   ÿa-E…ä„~   HÀ  ‹şÿÏöC€uH‹Ëèl4ÍÿHƒÃ …ÿèH‹L$PIƒÆ@L‰t$@I‹ÆL;ñs0L‹D$HéJûÿÿA¸6 Hç«À‹Èè@bTë"A¸6 ëèA¸6 ëàA¼   D‰d$8ëD‹d$8¾   >>>HMècHÔÿ3ÿE…äu!HÀ  ÿÎöC€u
>>H‹ËèÛ3ÍÿHƒÃ …öæH‹\$h¸   @8<u è_9 ¸   H‹H‹EˆH‰P  A‹ÄH‹°  H3Ìè%²ÿHÄÈ  A_A^A]A\_^[]Ã¸   B8(uè9 ¸   º   A¸¦,J‹(H‹‰P  èi§óÿÌ‰T$USVWAUAVAWH¬$`ıÿÿHì   H‹¬ë	H3ÄH‰…  eH‹%X   A½   H‰L$@L‰D$XH‹D‰L$0BŠ+„Òu	è˜9 BŠ+¿   H‹;H‹P  H‰D$P„Òu	èv9 H‹;>H…€  ºD’DH‰P  H€  èf(µÿH‹ÈH‹ÔèC²ÿ …Àt#B€<+ uè49 H‹D$PH‹;H‰P  3Àé»  èÄ“ºÿL‹t$X¹ÿ   …ÀtH‹|$@ƒg ƒÿÇG   ë'I‹–@  H…ÒtD  f9
‡>  H‹|$@H‹ÏèŠóÿ‹t$0A¿ıÿÿÿƒşşuƒg< ƒO ÿÇG8   é¬   }v>I‹ø   A‹Ç+Æˆì  ;Aã  H˜I‹ÖLkèXLiI‹Íèô  „ÀtI‹E ëI‹Îè’şÿL‹ÀI‹Íè2‡ H…Àt¹ÿ   f9‡Ó  >HO H‹Ğè÷óÿA½   ë4ƒşÿt/>>E3À‹ÖI‹Îèû3øÿH…Àt¹ÿ   f9‡È  >HO H‹Ğè»óÿ½è  ;  …®   >I‹–  HL$`èÕöÿ>D‹   HL$`D‹ÆÇD$    I‹Öèùˆˆ …Àˆ  H‹T$`H…Òt>>¸ÿ   f9‡½  HO@èNóÿHL$`èLEÔÿB€<+ uè|9 H‹D$P¹   H‹H‰P  ¸   H‹  H3Ìè?²ÿHÄ   A_A^A]_^[]Ã½è  Ì  u­ƒşş}D+şëD‹½   I‹ø   E…ÿxnD;y}hIcÇI‹ÖHkğXHqH‹Î‹Fƒg| ÇGx   ‰G`èg  „ÀtH‹F ëI‹ÎèşÿL‹ÀH‹Îèz0‡ H…Àt¹ÿ   f9‡
  HO@H‹Ğèkóÿé"ÿÿÿfD  ÿBI-ÌB€<+ uè‘9 H‹;º   A¸³,H‹‰P  èê£óÿÌ¸   €< uèe9 ¹   º   A¸³,H‹H‹‰P  è¹£óÿÌB€<+ uè89 ¹   º   A¸³,H‹H‹‰P  èŒ£óÿÌHL$`è™Œ8 B€<+ ufèÿ9 ¹   º   A¸³,H‹H‹‰P  èS£óÿÌB€<+ uèÒ9 ¹   º   A¸³,H‹H‹‰P  è&£óÿÌB€<+ uè¥9 ¹   º   A¸³,H‹H‹‰P  èù¢óÿÌH‰\$H‰t$WHƒì H‹ñH‹úH‹Êè“şÿH‹ÏH‹Øè¸ùıÿ…Àt*H…Ût%€»¨   tHcNH‹ƒ¸   HiÑ  ŠD öĞ$ëH‹Ïè‚ùıÿ…À”ÀH‹\$0H‹t$8HƒÄ _ÃH‰\$H‰t$H‰|$ AVHƒì H‹ÙI‹ğH‹I`L‹òHƒÁhH‹H‹€0  ÿµ¡3ÒA¸   H‹ÈèZ†ÓÿH‹øH…ÀtUDŠH‹ÈI‹è$ÌÿÿHKH‰|$0HT$0èQ   H‹\$0…À@˜ÆH…ÛtH‹3ÒH‹ËH‹@ ÿ·´¡H‹ËèÓ„Óÿ@„öuH‹Çë3ÀH‹\$8H‹t$@H‹|$HHƒÄ A^ÃSUVWAVAWHƒì8>>>>>HcqH‹ùE3öL‹ú‹Î;7…  D!t$pH‹Ïè«¢Óÿ>‹ĞLD$pH‹ÏèK¬Óÿ‹Ø…Àyº‘„(#‹ÈèÍïÕÿé2  >‹l$pHD$x‹ÕH‰D$ LŒ$€   H‹ÏL„$ˆ   è{ªÓÿ‹Ø…ÀyºÄ7X#‹ÈèïÕÿë~>>>>‹G…ÀtN>>>>L‹Œ$ˆ   H‹W‰D$(‹D$x‰D$ èËe€ ‹Ø…Ày'ºÃ7X#‹ÈèMïÕÿH‹OH‹”$ˆ   H‹H‹@hÿ˜³¡ë%H‹OH‹WH‹H‹@hÿ³¡H‹„$ˆ   3ÛH‰G‰/…Ûyº†L‹Ëé+ÿÿÿ‹O;ñtMD‹DNA@ÿD;Èw6f…öx0;ñ},H‹GE+ÁD¯G+Î‰L$(H‹ŞHğLJD‰D$ è!e€ ‹Oë
ÿnE-ÌH‹ŞA‰GH‹GL4Ø3Û…ÛyºÒ…L‹Ëè†îÕÿfëI‹Iƒ' 3ÛI‰…ÛyºĞ…L‹ËèfîÕÿ‹Ãë3ÀHƒÄ8A_A^_^][ÃH‰\$UVWATAUAVAWHl$ÙHìà   H‹ä	H3ÄH‰EH‹ùE3ÿD9y\tK>>>>>¹J‚!ÿ’X-ºK‚!»ÿÿ €‹ËèîÕÿ‹ÃH‹MH3Ìèë²ÿ6H‹œ$0  HÄà   A_A^A]A\_^]ÃDˆ¹ˆ   H‹Êè şÿ>>>>>>L‹èH‰|$0D‰|$8H‹ˆ   H‹H‹B(LL$0L“  I‹Õÿâ±¡‹\$8…ÛyºL‚!‹ËèjíÕÿéxÿÿÿHO0HşØÀH‰E‡WÀfE—WÉfM§L‰}·×™ºóE¿L‰}ÏfD‰}×H2ÙÀH‰]D‰}ßL‰}çfD‰}ïDˆ}ñóEóL‰}HU‡èK  ‹ğH‰]L‹eçM…ätvI‹\$ A‹L$A¯L$LcùLûI;ßtHKHèˆˆîÿ>>>HKè£>ÔÿHƒÃ`ëŞE3ÿE‰|$IL$èÓÿ>>>>>IT$øH‹
H‹â	H3ÈH‰H‹H‹@hÿâ°¡L‰}çHMè~îÿ…öy>>ºM‚!‹Îè_ìÕÿ‹Æémşÿÿ‹G4…À~@ÿÈ¯G8HcĞHW@DŠ‰   L‹‡€   I‹Íè*   I‹MH…ÉtH‹H‹@`ÿ|°¡3Àé&şÿÿÿÏB-ÌH‰\$H‰l$H‰t$WHƒì0H‹éAŠùIHhI‹ØH‹H‹òH‹€0  ÿ4°¡L‹‹(  HSPL‹ƒ0  HNH‰D$ è|îÿHM@„ÿtH÷İHÒH#ÑH‹ÎèB   ëH‹H÷İHÒH#ÑH‹ÎH‹@Xÿß¯¡H‹ÎH‹\$@H‹l$HH‹t$PHƒÄ0_é[÷÷ÿÌH‰\$WHƒì Hƒz H‹ÚH‹ùt!¹ŠØ5ÿÆU->H‹H‹ÓH‹ÏH‹@Xÿ‚¯¡ëHƒÁÆAbèK}îÿH‹\$0>HƒÄ _Ã@SHƒì >H‹ÚH‹ÑH‹è   3É‰C…À™Á‹ÁHƒÄ [ÃH‰\$UVWATAUAVAWHl$ÙHìĞ   H‹à	H3ÄH‰EL‹âL‹ùHƒÁH-ÖÀH‰E‡WÀfE—WÉfM§E3öL‰u·—ºóE¿L‰uÏfD‰u×H^ÖÀH‰]D‰ußL‰uçfD‰uïDˆuñóEóL‰uHU‡èw  ‹øH‰]L‹mçM…ítmI‹] A‹MA¯MLcñLóD  I;ŞtHKHè²…îÿHKèĞ;ÔÿHƒÃ`ëÜE3öE‰uIMè1›ÓÿIUøH‹
H‹Âß	H3ÈH‰H‹H‹@hÿ®¡L‰uçHMèB{îÿf…ÿy5ºG‚!‹Ïè”éÕÿ‹ÇH‹MH3Ìè’
²ÿH‹œ$   HÄĞ   A_A^A]A\_^]Ã>>>A‹G…À   E8·‰   A•ÀÿÈA¯GHcĞIWI‹ÌèçCûÿº   I‹ÌèªAûÿIOXL‰t$ LD$ ‹Qèÿÿ‹Ø…ÀyºÓ…L‹ÈèéÕÿfëH‹D$ L‰ A‹Ş…ÛyºÑ…L‹ËèçèÕÿëA‹Ş…ÛyºH‚!‹ËèÒèÕÿ‹Ãé9ÿÿÿ>>>>>3Àé-ÿÿÿÿ}?-ÌH‰\$H‰l$VWAVHƒì0Hcq3íL‹òH‹ùD‹Æ;1uN!l$PèB›Óÿ‹ĞLD$PH‹Ïèã¤Óÿ‹Ø…Àyº‘„(#‹ÈèeèÕÿé™   >‹T$PH‹Ïè¾Åÿÿ‹Ø…Àyº†LëÙD‹GA;ğt_D‹DNABÿD;ÈwB…öx>@ A;ğ}5E+ÑD+ÆD¯WH‹ŞHiÖˆ   D‰D$(HWD‰T$ LŠˆ   èL_€ D‹GëfD  ÿ¢>-ÌH‹ŞHiëˆ   A@Ho3Û‰Gf…ÛyºÒ…L‹Ëè´çÕÿëI‹ÖH‹Íè3   3Û…ÛyºĞ…L‹Ëè”çÕÿ‹Ãë3ÀH‹\$XH‹l$`HƒÄ0A^_^ÃH‰\$H‰t$WHƒì HyH‹ñHZH÷ÒÀH‰H-ÔÀH‰H‹CH‰GH‹CH‰GH‹CH‰GH‹C H‰G H‹C(H‰G(C0óG0H‹C@H‰G@ŠCHˆGHŠCIˆGIHÓÀH‰‹CP‰GPH‹CXH‰GXŠC`ˆG`ŠCaˆGaŠCbˆGbCdóGdH‹CXH‰GXHƒcX H‹C(H…ÀtH9XuHƒ` Hƒc( >H‹H‹ËH‹€¸   ÿøª¡>Hƒc Hƒc Hƒc Hƒc  H‹G(H…ÀtHƒx uH‰xHƒ¦€    H‹ÆH‹t$8H‹\$0HƒÄ _ÃH‹ÄH‰XH‰hH‰pH‰x ATAVAWHƒì0>3Û…Ò~H‹	öA€uH‹	è›õøÿéû   èÑ„ºÿ…Àt
ègÎÿ éç   H‹s6H…À„Ú   ƒx½   uReH‹%X   H‹88/uèå9 ¹   ‹ñH‹9H‹A ö€Œ  …   D  8/u	èº9 H‹>H‹A0H‹˜ 5  ë}L‹xeH‹%X   H‹8Š/„Àuè9 Š/¹   ‹ñH‹9D‹a`„Àuèr9 H‹>Š/>>>D‹q`„Àuè[9 H‹>Š/‹i\„Àu	èH9 H‹>‹I\E‹ÌE‹ÆL‰|$ ‹Õè+   H‹ØH‹l$XH‹ÃH‹\$PH‹t$`H‹|$hHƒÄ0A_A^A\Ã@SHƒì0H‹D$`D‹ÙD·P
fAƒâu>>€xuH‹€ˆ   H‹€ 5  ë3>>>>>H‹j¬3ÛfE…Òu€xvH‹Ã6666H‰L$(A‹ËH‰D$ èK9ÂÿHƒÄ0[ÃH‰\$H‰l$ VWAVHƒì0H‹òH‹éH‹RL‹ñH‹Š   H‹H‹€    ÿ¢¨¡3ÿ9=ºÁã   >>>>>>9=¬Á…Ñ   L;vu>H‹FI9†h  uH…ÀLEğI‹Îè×Cşÿ>>>>HT$XHHhH‹H‹€(  ÿB¨¡…Àˆ‚   H‹\$XH‹Íè¥CşÿHHhH‹H‹€   ÿ¨¡I‹–¨  LL$PL‹ÀH‰\$ I‹Îèİñüÿ…ÀxAH‹D$PH‰¨h  H‰½h  H‹FH‰EhH‹Fğÿ@@H‹L$P3ÒèrıÿH‹L$P…À@™Çèğıÿë$>‰>3ÀëH‹EhğÿH@H‹FH‰EhH‹Fğÿ@@¿   ‹ÇH‹\$`H‹l$hHƒÄ0A^_^Ã@USVWATAUAVAWH¬$ûÿÿHìè  H‹íØ	H3ÄH‰…Ğ  H‹…X  I‹ÙH‰EhM‹èH‹…`  L‹úH‰E@3ÀH‰L$h3É‰…˜   H‰]L‰D$xè·ò±ÿH‹`:E3ÛA‹ÃL‰]àH‰E˜A‹ÓH‰EØA‹óI‹‡à  ECH…ÀDˆ\$`‰U°HEÈH:H‰MPH÷ÙH‹L$hH‰EHÀ%   @‰EXL‹‰¨   L‹‘   L‰MÀL‰UÈD9™¤   —  A‹ÃAxpH‰D$pL‹ñ>>>>>>Lià¨   H€MáHÉL‰e¸fE9$°   L‰]¸I‹û…öˆ  I‹L$HU¸M‹è  E3ÀD‰\$(H‰T$ 3ÒH‹H‹€°   ÿ¦¡E3Û‹ğ…ÀˆÌ  I‹D$ HM`M‹ÅI‹×L‹H‹E¸H‰D$(D‰\$ è5ôŠ E3Û‹ğ…Àˆš  H‹M¸ECE3ÉD‰\$ I‹ÕH‹H‹€¸   ÿ½¥¡L‹MÀE3ÛL‹UÈéé  D  E„$…?
  M9\$(„Ù  fff„     M9\$0„Ã  …öˆY  Ic|$L‹÷‹»‰E¨ƒøÿ„•  M‹ÅI‹×‹ÈèiÙøÿ>>>>E3Û‹ğ…Àˆ$  >A€¿´  LcE¨I‹‡   Ûãô~ğÿÃ   K€HÉ9\È8  I‹×A‹Èè*÷ıÿ;Ã	  I‹…È   …ÿˆÈ   ;x¼  >>>L‹D$hM‹Ï‹U¨L‰l$XIkÎxA¾   HHH‹EhH‰D$PHED‰t$HH‰D$@HEàH‰D$8HEdH‰D$0HEØH‰D$(‰|$ èKQÿÿE3Û‹ğ…Àˆ?  >I‹  EF'3Òè»uÓÿE3ÛH‹øH…ÀtL‰L‰XL‰XL‰X L‰XH…ÿ„  >I‹T$0H‹Ïè¦Š[>>>E3Û…Àˆì  >>>‹_A‹ÃL‹EØH‹OHcÓL‰E˜…Û~Aƒ<€ÿuƒ	ÿHƒÁIÆH;Â|êI‹D$(LEpI‹  LcpH‹D‰u„Bµ    H‹@XÿÁ£¡E3Û…Àˆw  >>>>>>>>>>L‹epM…ä„­	  M‹Æ3ÒIÁàI‹Ìèâ²ÿH‹OE3Û…Û~"H‹ÓA[ƒ9ÿtHcA„>>>>HƒÁH+Óuçë»   >>>>D‹U„E‹óE‹ËI‹ÔE‹ÃE…Ò~.D9uDóƒÉÿëAAA‹ÈA+Î9AEÁD‹È‰
DÃHƒÂE;Â|Ò>>>>>>>>>C1A;Â	  HcM¨I‹—¨   D‹ÁHiÁ¨   ötLcDIiÀ¨   öuîE;‡    }#I‹…È   D;@|2E;‡¤   sC>IcÀHiÀ¨   ë1IcÀHiÈ¨   I‹…È   LcLD;H}I‹ÃëE;¤   sIiÁ¨   HÂëI‹ÃH‹@ H‹ H‹M@E3ÉH‰L$8I‹×HM¬H‰L$0I‹ÍH‰D$(D‰\$ è¤Ì‡ …ÀˆB  Hc]¬M‹Å‹Ë‰]€I‹×è8Öøÿ‹ğ…Àˆ$  3ÒH›HÁàI‡   HiË¨   DB(H‰E I¨   H‰MøI‹è  è7sÓÿE3ÛH‹ØH…ÀtL‰L‰XL‰XL‰X L‰XH‹EøH‰X0H…Û„T  ‹EA¹   I‹—è  D‹ÀL‰\$0H‹ËD‰\$(ÇD$    ‰E¤è¨›ÓÿE3Û…Àˆ  ‹E¤…ÀˆG  f;=  >>>>D)u„EC(‰C3ÒI‹è  è›rÓÿE3ÛL‹ğH…ÀtL‰L‰XL‰XL‰X L‰XH‹EøL‰p(M…ö„¸  D‹E„A¹   I‹—è  I‹ÎL‰\$0D‰\$(ÇD$    è›ÓÿE3Û…Àˆ‚  LcM„E…Éˆ®  f„     E;œ  >>>>>I‹FI‹ÉHÁáHÈE‰NH;Ásº€   f‰PHƒÀH;Áró>>H‹K3ÛH‹E¸L‹WH‰MğL‰U(H‹@(‰] L‹X‹ÃL‰]09]¤Å  H‹UàD‹E¤H‰U8ƒ:ÿt|HcAƒ<‚ÿ„B  >Ic‚H‹UğIcŒ‰…Àˆ  A;Fû
  >>>>>>H‹Ø¸€   HÁãI^f9C…6  HÁáM‹ÇIËH‹ÓèDÆˆ >E3Û…Àˆ
  ¸ÿíÿÿf!Céú  ‹U¨D‹ÀD‰	AÿÁHˆ   D‰M„H‰L$ LMxI‹Ïè‚óıÿH‹MxHU M‹ÇèòÅˆ E3Û…Àˆ.
  A‹FE‹ëD‰]èL‰]Ğ…Àu  E…íˆ
  €    D;è÷	  IcİI‹ÏHÁãI^è|÷ÿL‹ÈHM H…   E3ÀH‹ÓH‰D$ èvc÷ÿ…Àt¸   HEĞDèA‹FD‰mèD;è|™é	  3ÒH    A¸   èL²ÿ>>I‹—è  H    èÇ»öÿI‹ÏèÓ{÷ÿL‹ÈL…    ºæ  H‹H‹ˆ   I‹Éÿ¹¡E3í‹ğ…Àˆ˜  A€¿´  E‹İH‹    ‹] À% ÿÿü  D·D;ÀDCÀD‰E·AÿÃA;ĞD‰]H    ACĞèG(Ôÿ>>>>>A¸   H•Â  A‹Ë‹ğè;Óÿf‰…À  …öxD·ÀH•Â  H    èiÔÿ‹ğAŠÅˆEˆ…Û~o>>>>>>>>>H‹MĞH…Éˆ  ‹EèA;Fƒ  H‹ÙI‹ÏHÁãI^è§z÷ÿH‹H‹    H‰D$(ƒÈÿƒL$ ÿD‹ÈD‹ÀèÕsÓÿ…ÀtAÿÅD;m |›ŠEˆë°‹] E3í…öˆ‡   „ÀtH‹    D‹ED‹]éÿÿÿŠE»   I‹è  L‹É„Ãt%>>S~„ÂuH‹H‹U H‹@hÿS¡M‹è  L‰m H‹    LE ¸€   f‰E·HËè1p÷ÿ‹ğ…Ày¸   f‰Eëf‰]>>>>>H    èƒ*ÔÿH‹UğI‹ÎD‹HU è8Óÿ>>>>>E3Û…Àˆ  H‹EøL‰p(L‹]0L‹U(D‹M„D‹E¤‹E H‹U8ÿÀH‹MğHƒÂHƒÁ‰E H‰U8H‰MğA;ÀŒLüÿÿL‹l$x>H‹E¸E3ÛA‹óH‹@ H‹H;UHt$H…Òt
D·HƒÂëE‹Ã>>>>HMHè;Ôÿ‹ğE3ÛD‹u€…öˆú  LMHD‰\$ E‹ÆI‹ÕI‹Ïè3ÒşÿE3Û‹ğ…ÀˆÖ  H‹]øE3ÀH‹UHH‹Ëè³öÿE3Û‹ğ…Àˆ¶  H‹C(‹HH‹E ‰HëL‹l$xE3ÛL9]àt$I‹  H‹U˜H‹H‹@hÿØ›¡3ÛH‰]˜H‰]Øë3ÛI‹  H‹UàH‹H‹@hÿ²›¡I‹  I‹ÔH‰]àH‹H‹@hÿ—›¡H‹WH‹OH…ÒtH‹H‹@hÿ}›¡Hƒ' H‰_H‹Ïè‘kÓÿL‹t$hH‹]é¢õÿÿA;–    Œï  H‹L$hMcD$÷„    @ Nc4ƒt=Aƒşÿ„â  I‹‡   K¶HÉI‹Ö@„|Èt L‹t$h¸   DŠÀˆD$`H‹D$péF  I‹ÖëH‹D$pf„     Aƒşÿ„  H‹D$hK€HÉH’I‹—   A¼    HÁãH‹€   D·DÈ·LŠÁA2ÀA„Ä…  ŠÁA2À@„Ç…  fA3Èfºá
‚  >>A€¿´  ÿçô~ğÿÇ   9|‘  I‹×A‹Îè{ìıÿ;ÇŞşÿÿH‹E@3ÉH‰D$8D‹áHE¬‹ùH‰D$0E3ÉH‰L$(E‹Æ‰L$ I‹×I‹Íè€Ä‡ E3Û…ÀxM‹ÅI‹×D‹m¬A‹ÍèÎøÿ…À‰w  L‹l$xH‹U˜H…ÒtI‹  H‹H‹@hÿÕ™¡H‹UàH…ÒtI‹  H‹H‹@hÿ¸™¡M…ätI‹  I‹ÔH‹H‹@hÿœ™¡H…ÿ„  H‹Ïèƒ†ÓÿH‹Ë	HWøH‹
H3ÈH‰H‹H‹@hÿj™¡féé  Lc4ƒD‰u¬E‹îAƒşÿ„ì  >I‹‡   K¶A·TÊ¹    HÁãD·DŠÂA2À„Á…  ŠÂA2À@„Ç…  >fA3Ğfºâ
‚  H‹D$h÷€„    @ tf„     D„Ç…‰  L‹D$xI‹×A‹ÎM‹ãI‹ûèáÌøÿE3Û…ÀˆÇşÿÿA€¿´  I‹‡   ÿçô~ğÿÇ   9|$  I‹×A‹Îè´êıÿ@ ;Ç  I‹è  L…€   º    H‹H‹@Xÿ`˜¡>>H‹•€   E3Û…ÀE‹ãA‹ûIHÓH…Ò„HşÿÿL‹M¸Aº   I‹A0 HIcÅLiè¨   JI‹   H€M¯¨   HÁàHÁH‰E ·DfA…ÂuQ>öB<t,A¸   ÇD0q fAÀÇD(q ÇD4   ÇD,   ë3ÀH‰D(H‰D0·DfƒÈ fAÂf‰DD·B¸   D„ÀtH‹D(H‰¸   D„Àt	H‹D0H‰B>>>A·Àf3D‹M°fƒà@fA3Àf‰B¸   fA	E H‹D$hI‰U0;ˆ    |$E‰uE3ÀI‹A I‹ÍH‹èÂöÿf…Àˆ)ıÿÿL‹M¸A‹AH‹L$xA‰Eè‚2şÿL‹ÀI‹×I‹Íè´§‡ >>E3ÛI‰E(L‹l$xE‹ãA‹ûH…À„íüÿÿH‹M ‹@‰AL‹MÀL‹UÈH‹]L‹t$h¿€   H‹D$pDŠD$`‹M°º   ÊHÂ‰M°H‰D$pA;¤   ‚  >>>‹ÑA¸   é ğÿÿL‹l$xL‹t$hH‹]ë´L‹l$xë—L‹l$xéõúÿÿL‹l$xL‹t$hëœL‹l$xL‹ğëÓ>L‹ñëŒH‹}¸H…ÿ„¿   H‹E3É3ÒL‰]ĞH‹ÏD‰\$ H‹€¸   EAÿ–¡H‹LMĞ3ÒÇD$    H‹ÏH‹€¸   DBÿï•¡H‹3ÒL‹MĞH‹ÏÇD$    H‹€¸   DBÿÊ•¡H‹MĞE3öH…ÉtH‹è®ı„ H‹ËH…ÛuğH‹