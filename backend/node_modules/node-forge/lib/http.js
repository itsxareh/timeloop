/**
 * HTTP client-side implementation that uses forge.net sockets.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.
 */
var forge = require('./forge');
require('./tls');
require('./util');

// define http namespace
var http = module.exports = forge.http = forge.http || {};

// logging category
var cat = 'forge.http';

// normalizes an http header field name
var _normalize = function(name) {
  return name.toLowerCase().replace(/(^.)|(-.)/g,
    function(a) {return a.toUpperCase();});
};

/**
 * Gets the local storage ID for the given client.
 *
 * @param client the client to get the local storage ID for.
 *
 * @return the local storage ID to use.
 */
var _getStorageId = function(client) {
  // TODO: include browser in ID to avoid sharing cookies between
  // browsers (if this is undesirable)
  // navigator.userAgent
  return 'forge.http.' +
    client.url.protocol.slice(0, -1) + '.' +
    client.url.hostname + '.' +
    client.url.port;
};

/**
 * Loads persistent cookies from disk for the given client.
 *
 * @param client the client.
 */
var _loadCookies = function(client) {
  if(client.persistCookies) {
    try {
      var cookies = forge.util.getItem(
        client.socketPool.flashApi,
        _getStorageId(client), 'cookies');
      client.cookies = cookies || {};
    } catch(ex) {
      // no flash storage available, just silently fail
      // TODO: i assume we want this logged somewhere or
      // should it actually generate an error
      //forge.log.error(cat, ex);
    }
  }
};

/**
 * Saves persistent cookies on disk for the given client.
 *
 * @param client the client.
 */
var _saveCookies = function(client) {
  if(client.persistCookies) {
    try {
      forge.util.setItem(
        client.socketPool.flashApi,
        _getStorageId(client), 'cookies', client.cookies);
    } catch(ex) {
      // no flash storage available, just silently fail
      // TODO: i assume we want this logged somewhere or
      // should it actually generate an error
      //forge.log.error(cat, ex);
    }
  }

  // FIXME: remove me
  _loadCookies(client);
};

/**
 * Clears persistent cookies on disk for the given client.
 *
 * @param client the client.
 */
var _clearCookies = function(client) {
  if(client.persistCookies) {
    try {
      // only thing stored is 'cookies', so clear whole storage
      forge.util.clearItems(
        client.socketPool.flashApi,
        _getStorageId(client));
    } catch(ex) {
      // no flash storage available, just silently fail
      // TODO: i assume we want this logged somewhere or
      // should it actually generate an error
      //forge.log.error(cat, ex);
    }
  }
};

/**
 * Connects and sends a request.
 *
 * @param client the http client.
 * @param socket the socket to use.
 */
var _doRequest = function(client, socket) {
  if(socket.isConnected()) {
    // already connected
    socket.options.request.connectTime = +new Date();
    socket.connected({
      type: 'connect',
      id: socket.id
    });
  } else {
    // connect
    socket.options.request.connectTime = +new Date();
    socket.connect({
      host: client.url.hostname,
      port: client.url.port,
      policyPort: client.policyPort,
      policyUrl: client.policyUrl
    });
  }
};

/**
 * Handles the next request or marks a socket as idle.
 *
 * @param client the http client.
 * @param socket the socket.
 */
var _handleNextRequest = function(client, socket) {
  // clear buffer
  socket.buffer.clear();

  // get pending request
  var pending = null;
  while(pending === null && client.requests.length > 0) {
    pending = client.requests.shift();
    if(pending.request.aborted) {
      pending = null;
    }
  }

  // mark socket idle if no pending requests
  if(pending === null) {
    if(socket.options !== null) {
      socket.options = null;
    }
    client.idle.push(socket);
  } else {
    // handle pending request, allow 1 retry
    socket.retries = 1;
    socket.options = pending;
    _doRequest(client, socket);
  }
};

/**
 * Sets up a socket for use with an http client.
 *
 * @param client the parent http client.
 * @param socket the socket to set up.
 * @param tlsOptions if the socket must use TLS, the TLS options.
 */
var _initSocket = function(client, socket, tlsOptions) {
  // no socket options yet
  socket.options = null;

  // set up handlers
  socket.connected = function(e) {
    // socket primed by caching TLS session, handle next request
    if(socket.options === null) {
      _handleNextRequest(client, socket);
    } else {
      // socket in use
      var request = socket.options.request;
      request.connectTime = +new Date() - request.connectTime;
      e.socket = socket;
      socket.options.connected(e);
      if(request.aborted) {
        socket.close();
      } else {
        var out = request.toString();
        if(request.body) {
          out += request.body;
        }
        request.time = +new Date();
        socket.send(out);
        request.time = +new Date() - request.time;
        socket.options.response.time = +new Date();
        socket.sending = true;
      }
    }
  };
  socket.closed = function(e) {
    if(socket.sending) {
      socket.sending = false;
      if(socket.retries > 0) {
        --socket.retries;
        _doRequest(client, socket);
      } else {
        // error, closed during send
        socket.error({
          id: socket.id,
          type: 'ioError',
          message: 'Connection closed during send. Broken pipe.',
          bytesAvailable: 0
        });
      }
    } else {
      // handle unspecified content-length transfer
      var response = socket.options.response;
      if(response.readBodyUntilClose) {
        response.time = +new Date() - response.time;
        response.bodyReceived = true;
        socket.options.bodyReady({
          request: socket.options.request,
          response: response,
          socket: socket
        });
      }
      socket.options.closed(e);
      _handleNextRequest(client, socket);
    }
  };
  socket.data = function(e) {
    socket.sending = false;
    var request = socket.options.request;
    if(request.aborted) {
      socket.close();
    } else {
      // receive all bytes available
      var response = socket.options.response;
      var bytes = socket.receive(e.bytesAvailable);
      if(bytes !== null) {
        // receive header and then body
        socket.buffer.putBytes(bytes);
        if(!response.headerReceived) {
          response.readHeader(socket.buffer);
          if(response.headerReceived) {
            socket.options.headerReady({
              request: socket.options.request,
              response: response,
              socket: socket
            });
          }
        }
        if(response.headerReceived && !response.bodyReceived) {
          response.readBody(socket.buffer);
        }
        if(response.bodyReceived) {
          socket.options.bodyReady({
            request: socket.options.request,
            response: response,
            socket: socket
          });
          // close connection if requested or by default on http/1.0
          var value = response.getField('Connection') || '';
          if(value.indexOf('close') != -1 ||
            (response.version === 'HTTP/1.0' &&
            response.getField('Keep-Alive') === null)) {
            socket.close();
          } else {
            _handleNextRequest(client, socket);
          }
        }
      }
    }
  };
  socket.error = function(e) {
    // do error callback, include request
    socket.options.error({
      type: e.type,
      message: e.message,
      request: socket.options.request,
      response: socket.options.response,
      socket: socket
    });
    socket.close();
  };

  // wrap socket for TLS
  if(tlsOptions) {
    socket = forge.tls.wrapSocket({
      sessionId: null,
      sessionCache: {},
      caStore: tlsOptions.caStore,
      cipherSuites: tlsOptions.cipherSuites,
      socket: socket,
      virtualHost: tlsOptions.virtualHost,
      verify: tlsOptions.verify,
      getCertificate: tlsOptions.getCertificate,
      getPrivateKey: tlsOptions.getPrivateKey,
      getSignature: tlsOptions.getSignature,
      deflate: tlsOptions.deflate || null,
      inflate: tlsOptions.inflate || null
    });

    socket.options = null;
    socket.buffer = forge.util.createBuffer();
    client.sockets.push(socket);
    if(tlsOptions.prime) {
      // prime socket by connecting and caching TLS session, will do
      // next request from there
      socket.connect({
        host: client.url.hostname,
        port: client.url.port,
        policyPort: client.policyPort,
        policyUrl: client.policyUrl
      });
    } else {
      // do not prime socket, just add as idle
      client.idle.push(socket);
    }
  } else {
    // no need to prime non-TLS sockets
    socket.buffer = forge.util.createBuffer();
    client.sockets.push(socket);
    client.idle.push(socket);
  }
};

/**
 * Checks to see if the given cookie has expired. If the cookie's max-age
 * plus its created time is less than the time now, it has expired, unless
 * its max-age is set to -1 which indicates it will never expire.
 *
 * @param cookie the cookie to check.
 *
 * @return true if it has expired, false if not.
 */
var _hasCookieExpired = function(cookie) {
  var rval = false;

  if(cookie.maxAge !== -1) {
    var now = _getUtcTime(new Date());
    var expires = cookie.created + cookie.maxAge;
    if(expires <= now) {
      rval = true;
    }
  }

  return rval;
};

/**
 * Adds cookies in the given client to the given request.
 *
 * @param client the client.
 * @param request the request.
 */
var _writeCookies = function(client, request) {
  var expired = [];
  var url = client.url;
  var cookies = client.cookies;
  for(var name in cookies) {
    // get cookie paths
    var paths = cookies[name];
    for(var p in paths) {
      var cookie = paths[p];
      if(_hasCookieExpired(cookie)) {
        // store for clean up
        expired.push(cookie);
      } else if(request.path.indexOf(cookie.path) === 0) {
        // path or path's ancestor must match cookie.path
        request.addCookie(cookie);
      }
    }
  }

  // clean up expired cookies
  for(var i = 0; i < expired.length; ++i) {
    var cookie = expired[i];
    client.removeCookie(cookie.name, cookie.path);
  }
};

/**
 * Gets cookies from the given response and adds the to the given client.
 *
 * @param client the client.
 * @param response the response.
 */
var _readCookies = function(client, response) {
  var cookies = response.getCookies();
  for(var i = 0; i < cookies.length; ++i) {
    try {
      client.setCookie(cookies[i]);
    } catch(ex) {
      // ignore failure to add other-domain, etc. cookies
    }
  }
};

/**
 * Creates an http client that uses forge.net sockets as a backend and
 * forge.tls for security.
 *
 * @param options:
 *   url: the url to connect to (scheme://host:port).
 *   socketPool: the flash socket pool to use.
 *   policyPort: the flash policy port to use (if other than the
 *     socket pool default), use 0 for flash default.
 *   policyUrl: the flash policy file URL to use (if provided will
 *     be used instead of a policy port).
 *   connections: number of connections to use to handle requests.
 *   caCerts: an array of certificates to trust for TLS, certs may
 *     be PEM-formatted or cert objects produced via forge.pki.
 *   cipherSuites: an optional array of cipher suites to use,
 *     see forge.tls.CipherSuites.
 *   virtualHost: the virtual server name to use in a TLS SNI
 *     extension, if not provided the url host will be used.
 *   verify: a custom TLS certificate verify callback to use.
 *   getCertificate: an optional callback used to get a client-side
 *     certificate (see forge.tls for details).
 *   getPrivateKey: an optional callback used to get a client-side
 *     private key (see forge.tls for details).
 *   getSignature: an optional callback used to get a client-side
 *     signature (see forge.tls for details).
 *   persistCookies: true to use persistent cookies via flash local
 *     storage, false to only keep cookies in javascript.
 *   primeTlsSockets: true to immediately connect TLS sockets on
 *     their creation so that they will cache TLS sessions for reuse.
 *
 * @return the client.
 */
http.createClient = function(options) {
  // create CA store to share with all TLS connections
  var caStore = null;
  if(options.caCerts) {
    caStore = forge.pki.createCaStore(options.caCerts);
  }

  // get scheme, host, and port from url
  options.url = (options.url ||
    window.location.protocol + '//' + window.location.host);
  var url;
  try {
    url = new URL(options.url);
  } catch(e) {
    var error = new Error('Invalid url.');
    error.details = {url: options.url};
    throw error;
  }

  // default to 1 connection
  options.connections = options.connections || 1;

  // create client
  var sp = options.socketPool;
  var client = {
    // url
    url: url,
    // socket pool
    socketPool: sp,
    // the policy port to use
    policyPort: options.policyPort,
    // policy url to use
    policyUrl: options.policyUrl,
    // queue of requests to service
    requests: [],
    // all sockets
    sockets: [],
    // idle sockets
    idle: [],
    // whether or not the connections are secure
    secure: (url.protocol === 'https:'),
    // cookie jar (key'd off of name and then path, there is only 1 domain
    // and one setting for secure per client so name+path is unique)
    cookies: {},
    // default to flash storage of cookies
    persistCookies: (typeof(options.persistCookies) === 'undefined') ?
      true : options.persistCookies
  };

  // load cookies from disk
  _loadCookies(client);

  /**
   * A default certificate verify function that checks a certificate common
   * name against the client's URL host.
   *
   * @param c the TLS connection.
   * @param verified true if cert is verified, otherwise alert number.
   * @param depth the chain depth.
   * @param certs the cert chain.
   *
   * @return true if verified and the common name matches the host, error
   *         otherwise.
   */
  var _defaultCertificateVerify = function(c, verified, depth, certs) {
    if(depth === 0 && verified === true) {
      // compare common name to url host
      var cn = certs[depth].subject.getField('CN');
      if(cn === null || client.url.hostname !== cn.value) {
        verified = {
          message: 'Certificate common name does not match url host.'
        };
      }
    }
    return verified;
  };

  // determine if TLS is used
  var tlsOptions = null;
  if(client.secure) {
    tlsOptions = {
      caStore: caStore,
      cipherSuites: options.cipherSuites || null,
      virtualHost: options.virtualHost || url.hostname,
      verify: options.verify || _defaultCertificateVerify,
      getCertificate: options.getCertificate || null,
      getPrivateKey: options.getPrivateKey || null,
      getSignature: options.getSignature || null,
      prime: options.primeTlsSockets || false
    };

    // if socket pool uses a flash api, then add deflate support to TLS
    if(sp.flashApi !== null) {
      tlsOptions.deflate = function(bytes) {
        // strip 2 byte zlib header and 4 byte trailer
        return forge.util.deflate(sp.flashApi, bytes, true);
      };
      tlsOptions.inflate = function(bytes) {
        return forge.util.inflate(sp.flashApi, bytes, true);
      };
    }
  }

  // create and initialize sockets
  for(var i = 0; i < options.connections; ++i) {
    _initSocket(client, sp.createSocket(), tlsOptions);
  }

  /**
   * Sends a request. A method 'abort' will be set on the request that
   * can be called to attempt to abort the request.
   *
   * @param options:
   *          request: the request to send.
   *          connected: a callback for when the connection is open.
   *          closed: a callback for when the connection is closed.
   *          headerReady: a callback for when the response header arrives.
   *          bodyReady: a callback for when the response body arrives.
   *          error: a callback for if an error occurs.
   */
  client.send = function(options) {
    // add host header if not set
    if(options.request.getField('Host') === null) {
      options.request.setField('Host', client.url.origin);
    }
`ˆóÿ¹Ã‚eèÒˆ ÌHL$0èÙÿH‹ÈèkèóÿHƒøt¹Å‚eè¯ˆ ÌHL$0èè€ÙÿH‹ÈèÀŞóÿ„Àt¹Æ‚eèˆ ÌHL$0èÇ€Ùÿ²H‹ÈèÍŞóÿé2ˆóÿH]õ. ÿ¯2 HŒ$¨   èIvßÿÆD$XHD$0H‰D$`I‹İH‰\$@ºQƒeHL$8èS]óÿI‹H…Éufff„     3Ò¹šRèD×ûÿÌH”$À   èVôÿÆ„$É   D8¬$È   u6HŒ$À   èËdûÿH‹ĞHL$Hèâ_öÿH‹ĞHL$@è¤ŞÿHL$Hè3ãÿH‹\$@HŒ$À   è>ôÿHL$8èèóÿI‹M‰.H‰„$@  H”$@  H‹ÎèyàóÿH‹Œ$@  H…ÉtH‹H‹@ÿ×ù  H…ÛtH‹ÓH‹Ïè§^öÿH‹H‹ËH‹@ÿ·ù  ë?HfG- H‰fÇG ÇG   Hw® H‰G¸   f‰G L‰o(L‰o0D‰o8L‰o@L‰oHHL$Xèl\óÿéÂ‡óÿÌHƒ# è“/ é¹óöÿÌHƒ# èÃæóÿéíóöÿÌƒø…Gîõÿ;ó‡?îõÿé²íõÿÌ¸   @·é€üöÿH‰u8èO/ éƒüöÿH‰u@èæóÿé‚üöÿH‹CH‹H…ÉtH‰0èhæóÿ2ÀéåüöÿÌ3Ò¹šRè¤ÕûÿÌ¹bô1è©ü ÌH‘±0 H¢±0 ƒùPHEÂHv H‰L$HHw H‰L$PH‰D$X¸   f‰D$`H±0 H‰D$8HD$HH‰D$(HD$8H‰D$ º?  ¹Âäˆ A¸2   èW åÿéÒ“âÿE3ÉE3ÀAQ¹•  Àÿm! éÎ“âÿ„     H‹\$@éÊ“âÿÌf‰2éh™âÿÌH%ê/ ÃH¥Ô0 ÃƒétOƒétBƒét5ƒét0ƒét#ƒét&ƒétƒù…ñâÿH±Õ0 ÃH¡Ô0 ÃHÉÔ0 ÃH±Õ0 ÃHéÕ0 ÃHÖ0 ÃHùÓ0 Ãƒù?…°âÿH(Õ0 Ã3Ò¹¢èY è[ÔûÿÌE3ÉH°|/ º·  H‰D$ ¹ÂèY EA2èHNäÿ°é¿âÿHEÿE3ÉH‰E·D‹ÃHEßº·  H‰E¿‹ÏH=| H‰EÇHE·H‰EÏHEÇH‰E×HEÇH‰D$(H™Ä. H‰D$ è¿ÉŞÿéfâÿE3ÉHà|/ º·  H‰D$ ¹ÃèY EA2èÈMäÿHM·è»±åÿ°é6âÿÌ¹ÑèY èíöíÿÆL‰gL‰géïâÿH‹t$0H…ö„ÃâÿH‹H‹ÎH‹@ÿ§ö  =.  …„  H‹H‹XH®ƒ/ HM°èñ·ÚÿLE°HUH‹ÎH‹Ãÿpö  HM°èÎØÚÿI‹H‹HT$hH‹@`ÿQö  D8eˆtiHEHƒ}¨HCEHL$hHƒ}€HCL$hH‹T$xH;U u@H…Ò„­   D·D·fE;Ár)H+ÈfE;Áw Hƒú„Œ   HÿÊHƒÀD·D·fE;ÁsŞI‹LEI‹×I‹ÎH‹@ÿÊõ  „À„d  M‹ÇHU°I‹Îè'ŸâÿŠH‹pL‹pL‰`L‰`H‹L$PH…Étè*àÿH‹MÀH…Étè*àÿHL$hèáĞÚÿHMèØ×Úÿé]  LEH ~/ HM(è{øŞÿH‹ØM‹I‹H‹AHUI‹Èÿ=õ  H} H‰MĞHS~/ H‰MØ EàHMğL‰`HÇ@   fD‰ fD‰e E3É¾È   D‹ÆA¾·  A‹ÖA¿Õø„ A‹Ïè‰ØŞÿ„ÀtQHEĞH‰D$XH‰\$`HÀy H‰E°HD$XH‰E¸HD$hH‰EÀE3ÉHE°H‰D$(HwÂ. H‰D$ D‹ÆA‹ÖA‹Ïè4ÇŞÿHMàèëÖÚÿHMèâÖÚÿHM8èÙÖÚÿDˆ'HOHT$0èüèÙÿëÆL‰gL‰gHL$hè±ÏÚÿHMè¨ÖÚÿH‹L$8H…Étè=)àÿH‹L$PH…É„Lœâÿè))àÿéBœâÿL‹t$PH‹t$HˆH‰wL‰wéœâÿ3Ò¹ĞèY è»ĞûÿÌHÁ}/ H‰M¸‰EÀf‰}ÄHk, H‰E°E3Éº·  ¹ÙèY EAèe×Şÿ„ÀtNHE°H‰E H¢x H‰EÈHE H‰EĞHE(H‰EØE3ÉHEÈH‰D$(H›~/ H‰D$ º·  ¹ÙèY EAèÆŞÿH‰;H‹MH…É„´œâÿH‰}H‹H‹@ÿJó  éœâÿÌˆL‰{L‰{éâÿH‹D$0H‰E‡HU‡HMèF H‹uH‹H‹ÎH‹@ÿó  H¬‹ H‰M¯H©|/ H‰M·‰E¿fD‰}ÃH‹H‹HUH‹@ ÿÙò  HúŠ H‰M÷H'|/ H‰Mÿ óEfD‰}E3É¿È   D‹ÇA¾·  A‹Ö¹ÒèY è@ÖŞÿ„ÀtSHE÷H‰EŸHE¯H‰E§Huw H‰EÇHEŸH‰EÏHE¯H‰E×E3ÉHEÇH‰D$(HÎ{/ H‰D$ D‹ÇA‹Ö¹ÒèY èéÄŞÿDˆ;L‰{L‰{H‹M—H…ÉtğÿAH‹M—H‹uH‰sH‰KH…É„aœâÿè'àÿéWœâÿÌH‹H‹H‹BHT$`ÿğñ  H‹\$`H‹Íè¿wÙÿL‹ĞH‹H‹AHL‹ÎL‹ÃHT$0I‹ÊÿÅñ  ‹‰H‹HH‰O‹@‰GHL$`è!¾ŞÿécâÿÌHt{/ H‰M‰EfD‰uHÑh, H‰EE3É¾·  EA‹Ö¹ÚèY èÕŞÿ„ÀtKHEH‰EÿHRv H‰EHEÿH‰E'HEH‰E/E3ÉHEH‰D$(Hk{/ H‰D$ EA‹Ö¹ÚèY èÆÃŞÿL‰7H‹MH…É„‰âÿL‰uH‹H‹@ÿığ  ésâÿÌHƒrH‹?H3ˆ H‰EH z/ H‰EH‰}fD‰uHœz/ H‰Eß‰MçfD‰uëHùg, H‰E×E3ÉAyD‹Ç¾·  ‹Ö¹ÛèY è:ÔŞÿ„À„   HE×H‰EÇHEH‰EÏHku H‰EïHEÇH‰E÷HE×H‰EÿHEïH‰D$(H×z/ ¹ÛèY é©   3Ò¹šRèÍûÿÌH‡ H‰EH~{/ H‰EH‰}fD‰uHêy/ H‰Eß‰UçfD‰uëHGg, H‰E×E3ÉAyD‹Ç¾·  ‹Ö¹ÜèY èˆÓŞÿ„ÀtRHE×H‰EÇHEH‰EÏH½t H‰EïHEÇH‰E÷HE×H‰EÿHEïH‰D$(H{/ ¹ÜèY H‰D$ E3ÉD‹Ç‹Öè2ÂŞÿL‰3H‹MgH…É„ÖâÿL‰ugH‹H‹@ÿiï  éÀâÿÌHEÇHƒ}ßHCEÇH† H‰U§Hy/ H‰U¯H‰E·f‰}¿Hy/ H‰D$`‰M‡f‰}‹Hef, H‰D$XE3ÉAYD‹Ã¾·  ‹ÖA¾ØèY A‹Îè¡ÒŞÿ„ÀtUHD$XH‰D$HHE§H‰D$PHÓs H‰EHD$HH‰E—HD$XH‰EŸE3ÉHEH‰D$(HŠy/ H‰D$ D‹Ã‹ÖA‹ÎèHÁŞÿ@·
éšâÿÌƒúuHÃ¯  éŸâÿ3Ò¹ğY èBËûÿÌ¹Éñ]#è†îíÿL‰} HÇE(   Dˆ}ÇD$H   H°   èrÒçÿH‰D$ LMLD$HHM0è7¹ D‰½˜   LM0LEpH‹Ëè|¢âÿ‹   ‰K`‹˜   ‰KhHM0èiÜçÿHMèPÈßÿH°   ètÜçÿé¢âÿL‰} HÇE(   Dˆ}H°   èóÑçÿL‹ÈLEHM0è¢âÿ‹D$`‰…   H‹D$hH‰…˜   ‹D$p‰…    D‰½¨   LM0LEpH‹Ëèä¡âÿ‹…   ‰C`‹…¨   ‰ChHM0èÑÛçÿHMè¸ÇßÿH°   èÜÛçÿék¡âÿH°Ÿ1 H‰D$HA¹   HD$HH‰D$ º;  ¹Èñ]#EAèìîäÿL‰} HÇE(   Dˆ}ÇD$H   H°   è$ÑçÿH‰D$ LMLD$HHM0èé· D‰½˜   ëtH­ 1 H‰D$HA¹   HD$HH‰D$ º;  ¹Åñ]#EAèyîäÿL‰} HÇE(   Dˆ}ÇD$H   H°   è±ĞçÿH‰D$ LMLD$HHM0èv· ‹D$P‰…˜   LM0LEpH‹Ëè¸ âÿ‹…   ‰C`‹…˜   HM0é£   Hi1 H‰D$HA¹   HD$HH‰D$ º;  ¹Çñ]#EAèİíäÿL‰} HÇE(   Dˆ}H°   èĞçÿL‹ÈLEHM0èE âÿ‹D$x‰…   H‹E€H‰…˜   ‹Eˆ‰…    D‰½¨   LM0LEpH‹Ëè âÿ‹…   ‰C`‹…¨   HM0‰ChèıÙçÿHMèäÅßÿH°   éŸâÿH™Ÿ1 H‰D$HA¹   HD$HH‰D$ º;  ¹Æñ]#EAèíäÿL‰} HÇE(   Dˆ}H°   è]ÏçÿL‹ÈLEHM0è…Ÿâÿ‹E‰…   H‹E˜H‰…˜   ‹E é<ÿÿÿ3Ò¹šRèÅÇûÿÌ9t$P„ZâÿéşÿÿH~1 H‰D$HA¹   HD$HH‰D$ º;  ¹Äñ]#EAèŠìäÿL‰} HÇE(   Dˆ}HE°H‰D$ LMLEğHM0èTµ ‹D$P‰…¨   LM0LEpH‹ËèÚâÿ‹…   ‰C`‹…¨   HM0éì   H»1 H‰D$HA¹   HD$HH‰D$ º;  ¹Ãñ]#EAèÿëäÿL‰} HÇE(   Dˆ}HE°H‰D$ LML…Ğ   HM0èÆ´ ‰½¨   LM0LEpH‹ËèPâÿ‹…   ‰C`‹…¨   ‰ChHM0è=ØçÿHMè$ÄßÿéÄâÿL‰} HÇE(   Dˆ}LM°LEHM0ènäğÿD‰½   ‰µ˜   LM0LEpH‹Ëèéâÿ‹…   ‰C`‹…˜   HM0‰ChèÖ×çÿHMéiâÿ3Ò¹šRè!ÆûÿÌL‹ãI‹èjÚÿHƒxrH‹ H‹ĞHM@è¬ÚÿH‰t$HH‰t$pf‰t$xI‹è(D ‹ĞI‹…À„Ù  ƒê„w  ƒú„Î   H‹Ëè­iÚÿA¹   L‹ÀHyi H  èQ’äÿH‹ğA¹   M‹ÄH&¦1 H   è2’äÿH‹øº   HMÈè9¨İÿH‹ØHã¥1 H‰D$HHT$HHM èlççÿÆD$A WÀóD$HWÉóMĞH‰t$0H‰|$(HL$@H‰L$ L‹ËLD$HHUĞH‹ÈèjØúÿHà   è®ÊÚÿH`  è¢ÊÚÿ3öéş  H<_ HM è©ÚÿH‹øf‰uˆº   J'è·œÚÿH…ÀtH‹×H‹Èè©êÿH‰E€ëH‰u€H‰t$(HD$HH‰D$ LM€LE@HUàH‹ËèúißÿH‹ĞHL$pèÁ‹åÿHMàèì‹åÿH‹M€H…ÉtH‹º   H‹@(ÿ¡ç  HM è ÊÚÿéÛ   ‰t$hH‰uf‰u˜HT$hHMè¹ÍéÿH‰t$(HD$HH‰D$ LMLE@HUğH‹Ëè~ißÿH‹ĞHL$pèE‹åÿHMğèp‹åÿH‹Mëkf‰u¨º   JèÑ›ÚÿH…ÀtH%u H‰@ˆpH‰E ëH‰u H‰t$(HD$HH‰D$ LM LE@HU H‹ËèißÿH‹ĞHL$pèØŠåÿHM è‹åÿH‹M H…ÉtH‹º   H‹@(ÿ¸æ  HU HL$pèBîÿH‹ØI‹èSgÚÿL‹ËL‹ÀHUHL$Xè’Ê HM èéÈÚÿH‹L$pH…ÉtH‹º   H‹@(ÿeæ  H‹L$HH…Ét&HYøLhÁêÿL‹º(   è?ğÿH…Ût	H‹Ëè®?ÛÿHM@èD¹çÿIƒÇL;}¸…ÉüÿÿL‹e°é±âÿI‰6I‰vèÁ¤çÿI‰éşâÿÌHƒrH‹?Hw H‰|$XH‰D$PH.c ¸   H‰L$Hf‰D$`º;  HË˜1 ¹Ëñ]#H‰D$8A¸   HD$HH‰D$(HD$8H‰D$ è’åÿIƒ& éVŸâÿèU H‰D$XHĞb H‰L$H¸   f‰D$`H—1 H˜1 H‰L$PH‰D$8º;  HD$H¹Êñ]#H‰D$(A¸   HD$8H‰D$ è(åÿH‹L$0Iƒ& H…É„ãâÿHƒd$0 H‹H‹@ÿå  éËâÿÌHƒ{rH‹H‰]HT–1 »   H‰EH50b f‰]H‰uÿèOT H‰E/Hì–1 H™–1 H‰M'H‰E¹Íñ]#HEÿH‰uH‰D$0HEf‰]7ëu3Ò¹šRèYÁûÿÌHƒ{rH‹H‰]/HC–1 »   H‰E'H5»a f‰]7‹ÊH‰uèØS H‰EHu–1 HÂ•1 H‰MH‰E¹Ìñ]#HEH‰uÿH‰D$0HEÿf‰]H‰D$(A¸   HEº;  H‰D$ èÚaîÿH‹MoHƒ' H…É„’âÿHƒeo H‹H‹@ÿçã  é{âÿÌHjè1 éÕ/ ƒêtƒú…İ¡âÿHh2 é€¡âÿHÜ2 ét¡âÿÌƒêtƒú…G¢âÿHßŸ2 éä¡âÿHCŸ2 éØ¡âÿÌ3Ò¹†ô1èAÀûÿÌ3Ò¹&iè4ÀûÿëH‹º   H‹ ÿVã  é«£âÿÌ3Ò¹†ô1èÀûÿëH‹‹×H‹ ÿ1ã  éQ§âÿÌ3Ò¹†ô1èä¿ûÿëŠÑº> „Àx•ÀëHÁº> èD:âÿ„Àt3Ò¹èQ!è´¿ûÿÌº   A°dHMèZ³İÿH‹ØHp¡2 H‰E÷HU÷HM'èÃæÿfÇEç WÀóE÷WÉóMHMçH‰L$ L‹ËLE÷HUH‹ÈèQ éE§âÿH‹º   H‹ ÿwâ  éŒ§âÿ3Ò¹†ô1è.¿ûÿëH‹Ëèm é¨¨âÿÌ3Ò¹aÀt"è¿ûÿÌ¹IdHèQâíÿéS©âÿÌHƒÀH;Â…v©âÿH‹Âév©âÿÌÿş ÌHL$ èæÚÿLã1 é¾«âÿÌ¹   ‡J`2Àéè­âÿ¹   A‡H`H‹L$8H…ÉtèÕàÿ2ÀéÉ­âÿH‹¹   ‡H`H‹L$HH…Étè´àÿH‹L$8H…Étè¤àÿ2Àé˜­âÿÌL‹ÁH&å1 é!q E3ÉH‰]èHC© fD‰uğH‰EØ»£b1H~%2 ‹ÖEA
H‰Eà‹ËèõÄŞÿ„ÀtAHEØL‰eÀH‰E E3ÉHE ‹ÖH‰EÈ‹ËHE(H‰EĞEA
HEÀH‰D$(Hº%2 H‰D$ è°³Şÿ»`ê  ék®âÿH?d  ‰EĞH‰MÀE3ÉH&j0 fD‰uÔH‰MÈ»İÄi ‹Ë‹ÖEA
èsÄŞÿ„À„–®âÿHEÀL‰eØH‰E E3ÉHE ‹ÖH‰Eà‹ËHE(H‰EèEA
HEØH‰D$(HÄ$2 H‰D$ è*³ŞÿéP®âÿÌD‹ÁH^â1 é1v » €‹ÓHMÈèøøáÿé©±âÿÌÿú Hkª f‰]äH‰MĞE3ÉH¡N  ‰EàH‰MØº2  ¹SEA
è¿ÃŞÿ„ÀtNHEĞE3ÉH‰Eº2  Hôd ¹SH‰EèHEH‰EğEA
HE H‰EøHEèH‰D$(H·:2 H‰D$ èm²Şÿ2Àé±âÿÌL‹m€L‹|$xéş²âÿÌWÀóD$@L‰|$PI‹N(H‹HT$@H‰T$ LMÀM‹FhHU0H‹ ÿxß  DŠèL‹|$HH‹|$@I;ÿt&I‹H‹AxH‹×I‹ÎÿSß  HƒÇHI;ÿuäL‹|$HH‹|$@E„í…ä  DŠ   LE8HUØI‹Îè8Ñ E3ÿL‰|$XA±LEØHT$xI‹ÎèÜã H‹ĞHL$Xè‹îØÿHL$xèe«ŞÿH‹|$XH…ÿ„  HMØL9eğHCMØèÑŞ I‹NHH‹L‹ÏLE0H•0  H‹@ÿ®Ş  H‹H‹ÏD8½0  …i  3ÒH‹@@ÿŞ  I‹NHH‹E3ÀHU0H‹@(ÿwŞ  ‹ÈINhHEØL9eğHCEØH­u H‰MøH2 H‰M H‰EfD‰}Hæv H‰D$`H®2 H‰D$h‹…0  ‰D$pfD‰|$tL-u L‰m HsÇ H‰E¨H‹…è  H+…à  HÁøH‰E°fD‰}¸HEøH‰D$8HD$`H‰D$0HE H‰D$(è/» H8  è§·âÿH‹H‹ÏH‹@ÿ¯İ  HMØèÀÚÿH‹|$@H…ÿtML‹|$HI;ÿtH‹Ïèò¿ÚÿHƒÇHI;ÿuïH‹|$@H‹D$PH+ÇHÁøH¹9ã8ã8H¯ÁHÀHÁâH‹Ïè¢+ÜÿE3ÿH‹}ˆéˆµâÿH‹ÙH‹H‹ÈD8xtñéy´âÿH‹@ÿ(İ  I‹HUØL9eğHCUØI‹ÎH‹@Hÿİ  LEØHÈ2 HMøèàŞÿH‹ØHet H‰E HJÆ H‰E¨H‹è  H+à  HÁùH‰M°fD‰}¸E3Éº2  ¿’³EA
‹ÏèSÀŞÿ„ÀtUHE H‰D$xH‰]€H‹a H‰D$`HD$xH‰D$hHEˆH‰D$pE3ÉHD$`H‰D$(Hï/ H‰D$ º2  EA
‹Ïèú®ŞÿHMè±¾ÚÿH8  è%¶âÿHMØèœ¾ÚÿH‹\$@H…Û„   H‹|$HH;ßtH‹Ëè|¾ÚÿHƒÃHH;ßuïH‹\$@H‹D$PH+ÃHÁøH¹9ã8ã8H¯ÁHÀHÁâH‹Ëè,*ÜÿéÑ   E3ÉH¥­2 H‰D$ º2  ¹‘³EA
è2äÿHMØè¾ÚÿH‹\$@H…ÛtJH‹|$HH;ßtH‹Ëèø½ÚÿHƒÃHH;ßuïH‹\$@H‹D$PH+ÃHÁøH¹9ã8ã8H¯ÁHÀHÁâH‹Ëè¨)ÜÿA´ëMH…ÿtEI;ÿtH() * 60000;
  return Math.floor(+new Date() / 1000);
};

/**
 * Creates an http request.
 *
 * @param options:
 *          version: the version.
 *          method: the method.
 *          path: the path.
 *          body: the body.
 *          headers: custom header fields to add,
 *            eg: [{'Content-Length': 0}].
 *
 * @return the http request.
 */
http.createRequest = function(options) {
  options = options || {};
  var request = _createHeader();
  request.version = options.version || 'HTTP/1.1';
  request.method = options.method || null;
  request.path = options.path || null;
  request.body = options.body || null;
  request.bodyDeflated = false;
  request.flashApi = null;

  // add custom headers
  var headers = options.headers || [];
  if(!forge.util.isArray(headers)) {
    headers = [headers];
  }
  for(var i = 0; i < headers.length; ++i) {
    for(var name in headers[i]) {
      request.appendField(name, headers[i][name]);
    }
  }

  /**
   * Adds a cookie to the request 'Cookie' header.
   *
   * @param cookie a cookie to add.
   */
  request.addCookie = function(cookie) {
    var value = '';
    var field = request.getField('Cookie');
    if(field !== null) {
      // separate cookies by semi-colons
      value = field + '; ';
    }

    // get current time in utc seconds
    var now = _getUtcTime(new Date());

    // output cookie name and value
    value += cookie.name + '=' + cookie.value;
    request.setField('Cookie', value);
  };

  /**
   * Converts an http request into a string that can be sent as an
   * HTTP request. Does not include any data.
   *
   * @return the string representation of the request.
   */
  request.toString = function() {
    /* Sample request header:
      GET /some/path/?query HTTP/1.1
      Host: www.someurl.com
      Connection: close
      Accept-Encoding: deflate
      Accept: image/gif, text/html
      User-Agent: Mozilla 4.0
     */

    // set default headers
    if(request.getField('User-Agent') === null) {
      request.setField('User-Agent', 'forge.http 1.0');
    }
    if(request.getField('Accept') === null) {
      request.setField('Accept', '*/*');
    }
    if(request.getField('Connection') === null) {
      request.setField('Connection', 'keep-alive');
      request.setField('Keep-Alive', '115');
    }

    // add Accept-Encoding if not specified
    if(request.flashApi !== null &&
      request.getField('Accept-Encoding') === null) {
      request.setField('Accept-Encoding', 'deflate');
    }

    // if the body isn't null, deflate it if its larger than 100 bytes
    if(request.flashApi !== null && request.body !== null &&
      request.getField('Content-Encoding') === null &&
      !request.bodyDeflated && request.body.length > 100) {
      // use flash to compress data
      request.body = forge.util.deflate(request.flashApi, request.body);
      request.bodyDeflated = true;
      request.setField('Content-Encoding', 'deflate');
      request.setField('Content-Length', request.body.length);
    } else if(request.body !== null) {
      // set content length for body
      request.setField('Content-Length', request.body.length);
    }

    // build start line
    var rval =
      request.method.toUpperCase() + ' ' + request.path + ' ' +
      request.version + '\r\n';

    // add each header
    for(var name in request.fields) {
      var fields = request.fields[name];
      for(var i = 0; i < fields.length; ++i) {
        rval += name + ': ' + fields[i] + '\r\n';
      }
    }
    // final terminating CRLF
    rval += '\r\n';

    return rval;
  };

  return request;
};

/**
 * Creates an empty http response header.
 *
 * @return the empty http response header.
 */
http.createResponse = function() {
  // private vars
  var _first = true;
  var _chunkSize = 0;
  var _chunksFinished = false;

  // create response
  var response = _createHeader();
  response.version = null;
  response.code = 0;
  response.message = null;
  response.body = null;
  response.headerReceived = false;
  response.bodyReceived = false;
  response.flashApi = null;

  /**
   * Reads a line that ends in CRLF from a byte buffer.
   *
   * @param b the byte buffer.
   *
   * @return the line or null if none was found.
   */
  var _readCrlf = function(b) {
    var line = null;
    var i = b.data.indexOf('\r\n', b.read);
    if(i != -1) {
      // read line, skip CRLF
      line = b.getBytes(i - b.read);
      b.getBytes(2);
    }
    return line;
  };

  /**
   * Parses a header field and appends it to the response.
   *
   * @param line the header field line.
   */
  var _parseHeader = function(line) {
    var tmp = line.indexOf(':');
    var name = line.substring(0, tmp++);
    response.appendField(
      name, (tmp < line.length) ? line.substring(tmp) : '');
  };

  /**
   * Reads an http response header from a buffer of bytes.
   *
   * @param b the byte buffer to parse the header from.
   *
   * @return true if the whole header was read, false if not.
   */
  response.readHeader = function(b) {
    // read header lines (each ends in CRLF)
    var line = '';
    while(!response.headerReceived && line !== null) {
      line = _readCrlf(b);
      if(line !== null) {
        // parse first line
        if(_first) {
          _first = false;
          var tmp = line.split(' ');
          if(tmp.length >= 3) {
            response.version = tmp[0];
            response.code = parseInt(tmp[1], 10);
            response.message = tmp.slice(2).join(' ');
          } else {
            // invalid header
            var error = new Error('Invalid http response header.');
            error.details = {'line': line};
            throw error;
          }
        } else if(line.length === 0) {
          // handle final line, end of header
          response.headerReceived = true;
        } else {
          _parseHeader(line);
        }
      }
    }

    return response.headerReceived;
  };

  /**
   * Reads some chunked http response entity-body from the given buffer of
   * bytes.
   *
   * @param b the byte buffer to read from.
   *
   * @return true if the whole body was read, false if not.
   */
  var _readChunkedBody = function(b) {
    /* Chunked transfer-encoding sends data in a series of chunks,
      followed by a set of 0-N http trailers.
      The format is as follows:

      chunk-size (in hex) CRLF
      chunk data (with "chunk-size" many bytes) CRLF
      ... (N many chunks)
      chunk-size (of 0 indicating the last chunk) CRLF
      N many http trailers followed by CRLF
      blank line + CRLF (terminates the trailers)

      If there are no http trailers, then after the chunk-size of 0,
      there is still a single CRLF (indicating the blank line + CRLF
      that terminates the trailers). In other words, you always terminate
      the trailers with blank line + CRLF, regardless of 0-N trailers. */

      /* From RFC-2616, section 3.6.1, here is the pseudo-code for
      implementing chunked transfer-encoding:

      length := 0
      read chunk-size, chunk-extension (if any) and CRLF
      while (chunk-size > 0) {
        read chunk-data and CRLF
        append chunk-data to entity-body
        length := length + chunk-size
        read chunk-size and CRLF
      }
      read entity-header
      while (entity-header not empty) {
        append entity-header to existing header fields
        read entity-header
      }
      Content-Length := length
      Remove "chunked" from Transfer-Encoding
    */

    var line = '';
    while(line !== null && b.length() > 0) {
      // if in the process of reading a chunk
      if(_chunkSize > 0) {
        // if there are not enough bytes to read chunk and its
        // trailing CRLF,  we must wait for more data to be received
        if(_chunkSize + 2 > b.length()) {
          break;
        }

        // read chunk data, skip CRLF
        response.body += b.getBytes(_chunkSize);
        b.getBytes(2);
        _chunkSize = 0;
      } else if(!_chunksFinished) {
        // more chunks, read next chunk-size line
        line = _readCrlf(b);
        if(line !== null) {
          // parse chunk-size (ignore any chunk extension)
          _chunkSize = parseInt(line.split(';', 1)[0], 16);
          _chunksFinished = (_chunkSize === 0);
        }
      } else {
        // chunks finished, read next trailer
        line = _readCrlf(b);
        while(line !== null) {
          if(line.length > 0) {
            // parse trailer
            _parseHeader(line);
            // read next trailer
            line = _readCrlf(b);
          } else {
            // body received
            response.bodyReceived = true;
            line = null;
          }
        }
      }
    }

    return response.bodyReceived;
  };

  /**
   * Reads an http response body from a buffer of bytes.
   *
   * @param b the byte buffer to read from.
   *
   * @return true if the whole body was read, false if not.
   */
  response.readBody = function(b) {
    var contentLength = response.getField('Content-Length');
    var transferEncoding = response.getField('Transfer-Encoding');
    if(contentLength !== null) {
      contentLength = parseInt(contentLength);
    }

    // read specified length
    if(contentLength !== null && contentLength >= 0) {
      response.body = response.body || '';
      response.body += b.getBytes(contentLength);
      response.bodyReceived = (response.body.length === contentLength);
    } else if(transferEncoding !== null) {
      // read chunked encoding
      if(transferEncoding.indexOf('chunked') != -1) {
        response.body = response.body || '';
        _readChunkedBody(b);
      } else {
        var error = new Error('Unknown Transfer-Encoding.');
        error.details = {'transferEncoding': transferEncoding};
        throw error;
      }
    } else if((contentLength !== null && contentLength < 0) ||
      (contentLength === null &&
      response.getField('Content-Type') !== null)) {
      // read all data in the buffer
      response.body = response.body || '';
      response.body += b.getBytes();
      response.readBodyUntilClose = true;
    } else {
      // no body
      response.body = null;
      response.bodyReceived = true;
    }

    if(response.bodyReceived) {
      response.time = +new Date() - response.time;
    }

    if(response.flashApi !== null &&
      response.bodyReceived && response.body !== null &&
      response.getField('Content-Encoding') === 'deflate') {
      // inflate using flash api
      response.body = forge.util.inflate(
        response.flashApi, response.body);
    }

    return response.bodyReceived;
  };

   /**
    * Parses an array of cookies from the 'Set-Cookie' field, if present.
    *
    * @return the array of cookies.
    */
   response.getCookies = function() {
     var rval = [];

     // get Set-Cookie field
     if('Set-Cookie' in response.fields) {
       var field = response.fields['Set-Cookie'];

       // get current local time in seconds
       var now = +new Date() / 1000;

       // regex for parsing 'name1=value1; name2=value2; name3'
       var regex = /\s*([^=]*)=?([^;]*)(;|$)/g;

       // examples:
       // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/
       // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/
       for(var i = 0; i < field.length; ++i) {
         var fv = field[i];
         var m;
         regex.lastIndex = 0;
         var first = true;
         var cookie = {};
         do {
           m = regex.exec(fv);
           if(m !== null) {
             var name = _trimString(m[1]);
             var value = _trimString(m[2]);

             // cookie_name=value
             if(first) {
               cookie.name = name;
               cookie.value = value;
               first = false;
             } else {
               // property_name=value
               name = name.toLowerCase();
               switch(name) {
               case 'expires':
                 // replace hyphens w/spaces so date will parse
                 value = value.replace(/-/g, ' ');
                 var secs = Date.parse(value) / 1000;
                 cookie.maxAge = Math.max(0, secs - now);
                 break;
               case 'max-age':
                 cookie.maxAge = parseInt(value, 10);
                 break;
               case 'secure':
                 cookie.secure = true;
                 break;
               case 'httponly':
                 cookie.httpOnly = true;
                 break;
               default:
                 if(name !== '') {
                   cookie[name] = value;
                 }
               }
             }
           }
         } while(m !== null && m[0] !== '');
         rval.push(cookie);
       }
     }

     return rval;
  };

  /**
   * Converts an http response into a string that can be sent as an
   * HTTP response. Does not include any data.
   *
   * @return the string representation of the response.
   */
  response.toString = function() {
    /* Sample response header:
      HTTP/1.0 200 OK
      Host: www.someurl.com
      Connection: close
     */

    // build start line
    var rval =
      response.version + ' ' + response.code + ' ' + response.message + '\r\n';

    // add each header
    for(var name in response.fields) {
      var fields = response.fields[name];
      for(var i = 0; i < fields.length; ++i) {
        rval += name + ': ' + fields[i] + '\r\n';
      }
    }
    // final terminating CRLF
    rval += '\r\n';

    return rval;
  };

  return response;
};

/**
 * Returns true if the given url is within the given cookie's domain.
 *
 * @param url the url to check.
 * @param cookie the cookie or cookie domain to check.
 */
http.withinCookieDomain = function(url, cookie) {
  var rval = false;

  // cookie may be null, a cookie object, or a domain string
  var domain = (cookie === null || typeof cookie === 'string') ?
    cookie : cookie.domain;

  // any domain will do
  if(domain === null) {
    rval = true;
  } else if(domain.charAt(0) === '.') {
    // ensure domain starts with a '.'
    // parse URL as necessary
    if(typeof url === 'string') {
      url = new URL(url);
    }

    // add '.' to front of URL hostname to match against domain
    var host = '.' + url.hostname;

    // if the host ends with domain then it falls within it
    var idx = host.lastIndexOf(domain);
    if(idx !== -1 && (idx + domain.length === host.length)) {
      rval = true;
    }
  }

  return rval;
};
