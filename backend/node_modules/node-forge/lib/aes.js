/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./cipher');
require('./cipherModes');
require('./util');

/* AES API */
module.exports = forge.aes = forge.aes || {};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};

/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */
forge.aes.Algorithm = function(name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};

/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */
forge.aes.Algorithm.prototype.initialize = function(options) {
  if(this._init) {
    return;
  }

  var key = options.key;
  var tmp;

  /* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */

  if(typeof key === 'string' &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key string into byte buffer
    key = forge.util.createBuffer(key);
  } else if(forge.util.isArray(key) &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key integer array into byte buffer
    tmp = key;
    key = forge.util.createBuffer();
    for(var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }

  // convert key byte buffer into 32-bit integer array
  if(!forge.util.isArray(key)) {
    tmp = key;
    key = [];

    // key lengths of 16, 24, 32 bytes allowed
    var len = tmp.length();
    if(len === 16 || len === 24 || len === 32) {
      len = len >>> 2;
      for(var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }

  // key must be an array of 32-bit integers by now
  if(!forge.util.isArray(key) ||
    !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error('Invalid key parameter.');
  }

  // encryption operation is always used for these modes
  var mode = this.mode.name;
  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);

  // do key expansion
  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};

/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */
forge.aes._expandKey = function(key, decrypt) {
  if(!init) {
    initialize();
  }
  return _expandKey(key, decrypt);
};

/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */
forge.aes._updateBlock = _updateBlock;

/** Register AES algorithms **/

registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.Algorithm(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
var Nb = 4;       // number of words comprising the state (AES = 4)
var sbox;         // non-linear substitution table used in key expansion
var isbox;        // inversion of sbox
var rcon;         // round constant word array
var mix;          // mix-columns table
var imix;         // inverse mix-columns table

/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polyno7So}SÊwN¦qëŸ@Ô½‚ääã¿ÅzjªW´.òºö"y7}æÍ°?¥ÍÛpÏ áé·Këù¹Ótâóã­<}P6{gy<óıl<6 Ï.Ï;7G>	ÏĞ _^rI6–ƒçàÅgã¹µüEÂcÃ{‰¸W‹x>ê¥~2“ø£YDƒ§Õ‘ÖNıC“úÓë
ı
ú3|7[¿d ˆ—t!>« -ñ\ø±	ªƒ&ğûhÉÏ¥v£­àçí:Ïeëá÷ÏîwVĞïÁÉ"¹­­Eyù¾Ÿã›°{p[yüôŞE,âÑ¼v½mÛ®Ü~"Ù5ŞşQÎÊï	}œ}Ü1"^0ûÓW(Şó}ÓæQÜº–ïG£óšµg ù½¿×ŠâñsÙú;¸çjŒ¢÷ähgÏÓ6Ú7sÆ‰W ¿~DN|”âQüOÊô±–çÌ/ƒ²å³ğŒÅÙx¤¯ùJ+ğßğäl<g@¶¾Q—gÈããÁ-è`L|9ıIxÉPq¾²&æÌ§’¿š[b¼Ş!âéÒüÇÈÆ‹%û%˜Í;
ú÷ÎûÌîOÂ³‡‰ò¹fãE9şgÜU^¾èŸÙxV¿ş¢_æŒ7½@>óëœxœc?W²Ÿ&Ù/x$güæàÙıëÎÏÆ³sôâÿq6™#Ÿ_ _ğXN|É‘O+è–ÓqY€çÿ+'>Kñ ‚?ÇñÅ9)§?äxÅû£ />.ÏË‘/)ÀósÖ9öcös¿ÊYçŒ_«À_ü»sâéàìı“S _ğ9ñ%'^ã#ú(Ç~Òø0°>aEû‹§râsı¼ÛËÇ}NÎøÍÁó%<9Ş'yx9şâírìIş¢‚xïÎÊ9ò%Eë¡/rúcP¶|^‘¾Í™rúC/Š§·äè›ƒ—­¯®É‰§R›a½Q€g‘ƒ'ûe³¨?ŞÈ™g_·(^­Û+ÏÎ±_X ¯³Şprü/*Ğ7Î™mÉ~ÖvÀ)X¯%9óo”£¯Qàæm9ë—œş°ú#Î™œõFT oğx¾ÿ3¤ş0GJëû×sÖ/9öÓ
ì§ÏË™?rğXscN<í‡ıGR€?!âñóİtş;ç<gãüíL´ƒ|éølñüÀ’â‰ÿğÖ+ÚÑ¢<á…t®n.ìCøüùÃ]”–ÏÕ½=Äóm{\W!m-$¹*>WÿŠŞC[t®ı²—®ô\İ}ŠôĞî&š\EÔµ¯Ş ş)ûQz/¢Á¢:(>o->›ÊI4}>ßájOz>ŸAõ‹ÏGwœ~!\/ÚI yÏçõûeöwMŸ‡Ü{¶`ïö³3ÛkqşİÊçóés“x{æÉ¹¶<Ÿ·6¥~÷¨éÁn—Šö4Dú2¢îºTß™3“üğÖ™¢¿ç<×Ò.ùäçZÖ´™Õ?>Œ?kïıj1Æ“uQï)Œ«'Åñ”ŞsæÏ1Úè¾?§åtm»ïÂÏ‹9ı_¹ï¢Ã÷“¹ôŞ?.öÏ]”æ÷!UËí£}›Ëók¢áã"Õãmô¸˜–ËóhÑï¾µû)¾†!Æä<ÈùèğLÜğöıÿĞˆ|ÆÓ	4êA¿K–Ÿû³÷ñşÌ?>Îù9å~WäWi?ß‹õÓ=8ÇEš 	/Ï¹_ç]IrÅè-Ã3ùµ	øNô4¼ğòíDÂx7C©ÿ ‡¬_¿iE\Ÿjƒ: –Dƒ{S9Ş{á=Giın¢Ú+D=é9½;·wEz$Ÿ¿Îş„‹÷¤ÿî-ğ';ï_Öì³†¬QÿÑ/’9ÂéÈ¿aÈÄÌËÉNîÔ>ÿ]mÜ{ÁîqDõõ(?7~F8éïo rgQãfğƒj :¨>Ô½rÏûÇ^HédaNÿ¾"ækO!ık´ûrv=÷p’ßY9¯õsfˆıèŸ+Ú5—6ñ1à±ñÀm ^<DÀ•ë[ÀhßCÿE·ŠíY×Iöÿ>õ¿+ú	ıÁÎB?/Ãü²¥úÙ‡şKÔØhøcÔ›N4~Œh0ãT¾	Ğó¢Æ“À»ÒÉ¥(ŸCÔúÚyòbD?®Q~°á¿ÿëó@´£ïØDôÏáÜ>¢ì;(mMØ¿Mìd=²¿ Ÿ8İÚx§Áõóˆ&ö¯ÈNé8“âÙ]š'¦"}ğoÌö/Õvsn…^‰qÁùÙ-ú¡ØÕÚÍ¼áÓnEó«/¯K$»ù×Õí–e·p§‚qzMİnYvsd»U¸n«yA¶›ªu°j»å­;´cS}İÑÌ?¶PÏı7Ö+¬L‹Ò9QúûËn´ß3;a]²ß(òÛˆúÅs%»=Î¹;S¹ÉˆjwÒı?÷!²·Ö««Ğ{¨“˜æëó:ú8?ï ğ¥çO¿ßä¬Cí2È½½€ş‰ÒÑ$¿÷LöùXº_}Šğƒ¹t/Ş˜ûñ;`¿ı~<ç`wã½L3ñÜådäÿ[ü¡Ö›äL¶'/Ùú<æ8Ñ¿ôîÄ|h¸ÑçulsØ}ñ6B;.ô‡à¹C{ô·Ó‰³õ·I`sôî¬vdÇ¢¿ˆx½RûİMıëñöu±_9uP{ö>D†eÛñºÂ¿AqH)G²ÑyŒ[Ğoc<„s
ø¥³ûMè}fÑg4^4Òs—Ñhoû.B{z{òç ñ¹ƒ_OĞó
ï«Í„zì›Œ>cÄñ›ÿïÃïiB~‹ßM£]oKøEOôËÎ$_¼ÉcMïİÓ¤tş¨'µm'êa,¢şs»Ÿ»…Øßyç‰-âÍgx_ğ¾dwoï½wŸïñ÷ÉÙ§ĞïíÂ•|ÛG aøÉ ¢Æ^Dù{{Ã^R¿¼>†Ê÷ó“úöt€«şé—Ó?ü»(h'œsº“üK¨=g€X?¼ ş<´Ôv •_Œß+¿K÷»m¤Y'*¦Ò¸”¿šÎ÷ü;ö¨§ßN”wÔ@ÚEy¥xş‡Îpô÷Pø'?ÿ½û"’3^F”íDõ¬ŞèïŸS{ö‰”6#ªM4´‰²“‰Z“‰ºÓˆ;Û…¨6¿WNÔŞğ ÂéLÔûÚN4ùÕ‚~öÊ×-ÈqpCş(´»á±=ˆÆ]Åß÷øG’<ÆQDı#ˆêÈ×‘PK¸Ñ»‹ş–ó<Òl/òñç‘ézá°ƒªóÿ‚ç"izûÀšüß„~ÚŸ*Ó/hW^?xëôËßºÖ¤Ÿıì%jô3Ú¨ÿ¼û/èC¸ÚS•éÇ¾S^?wHÛôŸÿZmúY÷‘<ú9ˆ;çõßõĞ^8(S_§C¿l}íÅ­ëOÿŸ•õ§³Yyıô#ÚF¿äÔÚÆ£y1É¯¨L¿hÌ+gCŸ$ÊuxÅÓ÷Z×áz‡ˆşgûg°EùşÓZ»â)×Ïi'êgş&[?³Kyı¬cÛF?ïƒÚúÏ½ëäàŠôK6E\:ó ìñ7®müÓ[9_|¦f>ŒÇ¶Q|9ºuş¿(Êmı>»ÿüõËëÇ†µ~ñ±µé"~j_WæŸF§òúym?¥µù'»û
õ
ô‹Ûj~¨µÿ_Ü¿W¦ŸÓû¦³²ã‹]e|	ÿqSEúÕ:ş\øg²¢:ÿÔİlıÌµÍ?gcıòDuë—\ÿœ­_ô×ƒÊê'ŸcÉúY5®·M®ß“•õ_‘~FÎ~B[†uÜ_ªJ¿tİP£~|~0?©L?s‘ÏxAŒëú˜¶™ôYµ?†ñçşCúUÆmEeñÅ«q}Ípé¼%Êí<“³>Û°`ıYåyEği…ñó­ÚôãÏıŒû¨]÷|œ_üAÒ7o=º^y}í¡mt~ñzëô¹/ˆò³ßÕ¦gP¥î'•õkÍï³‚<ş/Wx^³AÿV¹>eŸVv×ØŸéúû“Êô³±Š”3ÿW¹¿p*\ßØÇ´na}Z]|œ­ŸßÊıSnü©ñ|†ñóµ¥Òşé¹œõwÎywj—Õé-¯Ì?İ?ÕæŸáìï¯ï‹ûßİAĞ/ŞûÃ­ğ\áÂƒ2õÓ®N?óŸ•éçÿ¥2ıâ=wÊÓ÷Ò›‡ù^?<Á=yó¼l;8sE?ævĞrÎQyZ«ò5ş¼Âçzös´CD;Ø¦hwv¶äñÌíäÌ;é¸k£ó¬ÏëZ<·®Ğòóàà@Ñ:;HhÏøÓq§Ø^Z=/bo­Y{ÖŒ½Œãş;üËx(Ç^—TŸ<ÿˆfgÇç`|uöJVT—¼;‰òØ+F<Î³c;
ör–(”'ón
ûE•?Z³şä¯¡ñçúïÑƒÙö2/Ì¶—û²¸ş+²—†ı«3Šê%ÓRj/}Éš±—q+(æCëéÜèRœ_¶Ÿ‡åí|<s/ÉŞ8mß[û¼/ü—¨·»0ç¼zóòãÇn£çÑÎû5'ñû!‘$wŞó¢‚ıxĞFÏ‹‚7kÔÏÒßWâ¼Rş‚wŞGŠñïVø^ñ¼óÃtÕFşüNç{áùô3%û„9ö±ß¥öøwŸ-~¾Íğ¼÷8?·åqĞ½Pl'•İN¸DÔË;` ñ÷!j ­cŸÆëw%<ßÒqûÒùõŸ²ıÚë\¾½#«<gZYáş®•qÉ•Ãä>G“ü”Ÿã§óIÎs˜<ıô*Ó/xµuçhÆF•Í+Eã0h£}i\ã=‹ëüHšWœ×rÎ{1¯øçåœ£åÌ+3yÒs&óëÊú/¬q^Iïq-®ìœPÛ¨ü¼µÑ>Ùlå½CoãÊü3Î¹”¦ÛhİãşµÆyß×°ÿLõõiâú9íÈ•wïÚG=~ïZñWqça=n½%æÛ7â¾Ç«b~ˆu§»TÂ¹óQ,æûdç{w¢])ßÈÉoÇşà=1ß¹ãY’'œ~—å¹çªïŠùòõ÷Åüà~ğ/–ìƒ}±ö¦¤×uè?)ß¿r¾“ˆ?ö|C²ƒ‡õ‚”ï\|©_ŒË§¤~dÀw¦P»æK’\ÜŸ¯ıŒÏïVq~çùÚÖb>Ç·^Àşh(ä=$üçÌñË’<àgü{õ|\á¹{üÇ
ùqŞl Æ‰Pº™çlY>šmt2øsëÎ™å~Lß‹‚ıdˆı¤	{°vÆÍ{¸mdVáó‡÷Ÿ·ğß­(¿_øÚš=oI¿SÁãÿşÄGäEß)‹›ÔAÔG=úœÛò£·'|ğ™xoRŒ´ö©x™î¤s Y?kSª¯ã{œºçl–i_¹~Š?nÛ²åœFGA^ü>¯†Sùw…ş¦ô}°h{SÃ˜…ï„wƒ=ğ;KSâs¦ß?j÷#~]K¿OµN¾’ô]ºMY=å´±î¶UÙ%=çÅïRå÷A¦Ïû!¿7•ä7.Ày1¾'Âiıô ø70³Ûİå‡ÂN|]¿¸Ïô†™™úÄ÷R¾·É·ÃOŒnu?)ç'V…~b/Ÿ¯wf×Këßa
”ÿ~ÖOvˆND>¾ä!­£ÜFùI#úe%~}1åëŸà÷}mƒ,_3øößûRÿ|"=ÇŸûßŒñvüùÒÊåúl.å; öàÕ@C”ó÷û¹£²ñşr+pn|È7P¿;pb¢æ´qTÿ$¼¯”·|Æg‡r°?]œ—‰Êßs
>ƒİ6Ë#PïD=PıâÍE¾…z[åßÙ6 ş‰ºĞy•ıevûî¸ì|N½N‡Nü,\ík“ßıÛHşòk9òÛ°¿S£ı£DYÉoC~ë¥l¾p9ähW£ı‡Aî®m#?ƒüé{Ó»QÚ M@õíág ávDmé?àıÁ7_Aõ1¹A/Ì—éûÙ¤y&}Ïã&è¯é}¹¢]ÑşÍô^¶äF~ø½C>——ÿ–æqó+?/7oE;Kğˆ3E9Óuöf”\	ûÿãá_x¯Åå°ï?(m&jİ~ŸBi}¾/º%åÅ}¡1[“ÿ‰yÔÆüı½7Â¹Ÿøı×q¯uÑødª§ÿßƒãûdèÃ©ıš¸~ş)¾£Å>-‡òõA|h'N½Ş}3ëE]°nkûl(®Û¬9¤§ÙvE?Åë’_‡MÏIîî+P÷(²ƒ³ıƒúæ[WˆÖæè£úV7şªŒlÚ:Nô3NÓõææä§ü,¹~ÿï¾B?Yı€Óñfa¶¾ô:ïÈêô­6^7úZĞ7||#¦ó;ôõ"âÓù÷áŞD}Èol
Z¥üUÇKÈ¯Aş4Æ÷€9åòë›a¾Z$ÊoÎB¼…ü.¾7iUéoÕ®BÈïBnö·ŞÙP éù)ì¯zÉ:CÏ6ZÇ&¾ßşú(ôÆ÷—“»è=ÌÉB¢ü¼Âú	üq@Ÿû3²Gºßév0Î¼¡‡
ãĞ8óãdÌ3Á‡şq¤´ÿ€xnJé4®‚ß<
8 ÚñE|@}ı8È{<æ;P}*è0"¡^ü€x>Hét|6bŞ?rµg@ÿa(¿ƒtø5Şvä¼xgB¿ë¡œÛÏ®‚üWÃ×bœ]üëÀwä8[ì7ã,à%æ§ûß3Å~t/@{ ìJØTŸ|PùìA±ŸµÅ~ÕÌîçpì½ã¡ÇÍ°ê™Šıb=˜İO¼_¼Û³û#=_8zËïï®öĞ^$ô]t$}œcèÓ>ç£(7¦PÚ<(>Åq,Ô“Û	ë—-_Îz5?øòpy)­¿‚sŞW‰&8‡M×y³iıa¿Cïa>Â8ß·?É¹Qÿ²|ñ>Tî-İ»,ŸÎñ ÒÒöxĞ+wÎô›<¼ íšÏÖ¿¬y<F_;ü;Ç›ôÏäã÷SbğëZy>çvÌæ“Ûe›fóñòô~Ì¦åõ4÷-ßO!ï'Ø+8¯¿8ÎÎ§´{)ä¼ˆ¨qI¡?äç´ÚO¨\kGãÈ|õÑŸò:;Ú} åWø;‰d—_‹{
¨ÜÛœhÑóoI…÷‘× ¶Såóíû„|³#¥Óç}
üán”Î½G6zòı[¿eù]™@6¿İzJüNÿl~üîxßšEç¿Ş}D­qb\IïÉq9ÎP¶Ü?½|¹‡òô¾Ò¢ä=÷³Èö£ôŞÍ\èµ–ün,½ïòŒ(wŞ},ëñòã$º±uúå“9jÒ/¾NìGãéÊúÑùey=½6Ò³µı<WY?Æ¿ùäßÇ[9~<: UúÅ5öc:Ÿ­¬ÿŒ_•ï?­Jı’×*‹çµöŸ—ÍRû|>ÖcJÛ‡RÜæñIÿ~ù8îKüV¿=Lä{gókİ‘/ñ³ı³ùmğë‡ŠóP²{yyâ"´W6°îÙJúºĞ7\œ_×‘6E|÷{ò,é»K6¿¹=ò‹üÆ¾åñõ!"~»ÏÀL~[š×Y‘=%}‹Öö!’¾»Bı³å‰·ñÍá”ºIí"_—ğí{zÜ%ÿÜ»Àÿ%|o×ûÈúøƒİOÂß#›ß¿ùƒDş¤g6²#ì,ñû9ü>øãÁ¢½³ûKüF}$ş$‡ßÆx´¥ñkçŒßÔ>ğÏq¥(¾'ˆ|-îWÁ¿×ÔüÌßû‘ßí¡bûeÛÃØãc¨h?'‡?õw	ŸåÄï´?%ÿ{äÄ{ô'·G»k 6¨/á%9ã!ÔÅ~Ëû„-ÅOwŸœx»ê‘ü­W6~~Æ¿ÓiäØËEØRü4râ§xKã×Ì‘?ÿƒD|+g¼[ïá¥âşÜ^‚ïO?0‰pñİßğw;	¸şùT~¯ú˜çëŞÃÿa©t. z-¾WƒàÃ²ñ¬qÇgâ·‰xÉPñûÜæzÇgâÙ5âùeãE9úZ?ñŒcOõ—­o(áé`üIxñ1"^0*O“ôuT¦¯±|bvÿJxÑÏ0n%ù‚	Ç‹ı±]¶ıÌ¼şx¸¼|îªlù¬Ùgxü{ó.ğø÷VeÿóúŸ‘‰çÔè/Ñ¦Ùúzû³l<Mú~½¾u6+á9xìX±?¢NÙx‰+Úo^—ìçw†€§í—m¿HÂs:áyİCåû#Ù'Ï”ú×ˆôu
ú7î—çÎÎÖ7)À3†gã±<£ Oß?/ğ,è«ÿ¬<9:ÏÏ‘O+À³Gdãé9xV‘¾fãÅ’¿öqş’R9ŞKò%°ŸWä/²å3rúÃ–ğØùâøÍÆÓ€çüA´ŸY0ŞÌrúCŠ!â½ûŸãAğ÷ìxê@>ò™ˆ~ıœ!9ı»ÇA>ò/ÌÁ;LÈo=D<_ì¼XËÆÓrğœ<w³l<]ÂÓàÏ^‘¾³ñ	Ïo~ŞVÙxÉÙúšEx›fãù’|1ü%|¸<^´s6+á1Œ7V€gwËÆórúW+ÀvÌÆ3sğ‚ûE]³ñìœş
ğ´íD<WJ³İ'ø–„ov$ü° ?ÙFÄæÀŸ_ÁswÜ7‰ùı}|GÌİMlß‘Úw·¢öã‚öÍí³Ûwğı<¿W ¯Áû÷åÍ‘ş'-:_°ùZ<Eåñxàş§¿—Ò@r¤ç¥[œ·àŞ¿y¢¨g|Ü Áüù¨5¡¼=œ‘T^éy‹±¸²ótk˜ØnµÏG[Œé÷}öƒ„rç1´7WÌ§t$ı4şìõ3¢Á“•ùWò`y{&·UgÏJıË¹¡2{¶øôÓéç·‘~zúEĞÏüµıÌÛÛF¿Zãƒõ(âÔoÕègİ½vé=Bò„¿©L¿hAyı‚»ÚF?»Ó–5é§IqÊú9â”ü";Nù¿Dœ‚EvÒÚÈNa­q
úUzïÇ,ĞÏ¾³:ıâ·*œ×æ¶n^Óû=Ÿ×¢G«³CøPy;ÄïÚ½•­wÌ
ï?éS*ïyv0ş ÙáVÑ^Ä9n=(o¯Ê¸ç¾Sá{ƒ[éú‹¢\Éé{_Vˆ÷ìrßkó(“Òö›m3î“¨¶q¯ïBïKÇÔë¿Ãq^ı‰ûïA™|ü>ç‹z¦ö¤ûæ^ƒ…úŞ!”¶ÌÁ‚<1ò£	b~§‘oO$ª†v6‹ó•
ùÖµlQß4:~° o~üTÏEÚ5APÔ†4MCÿF !h êƒz îq¢öñÙúÊı[±[©oÚH_‹ëù7Èóü—Ÿ6,ĞèSĞ‡Ü¨gîBic9úi'JËPş9èw)ßû8ÀµºS~ü!äã8;S¾õa¶İÓßƒ.Î.—õ2$}ÖV½’OĞo‹ı!ÏŞ×{R¿®$š÷¾‚¨'ä[h^{¢É† ‰:ÑhÑ°3Qåü"½_5Ÿ~O©oà]€·1Ñx3à ]ù6ğ]Şş>$§ÿÎÉ†¢?¤{Ôî³İ9ÒûI|ŸmBßDµCû¸ÀÏ»wë¡<Èás
êË|É`j?¬°^õ
pª•¯7ìOó¿6lH¦İ9_zOcô¿Õãè±?Óı¿ÈÛ_@¿»÷?ÇƒXÀåãÂéÿŸíßÔN9õô}²í&ûk?][íÍú¬İòÅ(×º'c?:œÒSWx|=Ò|=«/.”Oo$Pş½ d)ñ¹s‰²÷‰záø8·æ”ÿNŸãæùQºŞ½û·{ˆšH3P4Ay2Kô{ë|Ä½+I®Ø½ex¦ãˆòƒq¨½üx¸Ø§¡œß‹¼ÊyD›Áªê .ø<P÷È3O´»½ÒÉB1?-EÌ×Bú×h÷åìzîá$¿³r^-êçÌæ™sE{¥ó¨{nüñb±?äúÖ°Ú÷Ğ/Ñ­b{Öu¢|ÉxŞO¨wšï–Q~ŞïşäõRº¾›:¤lyúŒ	Ğó‘ß¸qëR”Ï’Yß»A”7ğÄñÙ¢Ÿ$Oÿ©İoÉø”ÇÇ©t|&;ï_ŞNg­Ù8¦_$öc:ïMÇøA?¯i;™—“Ü1±~OæŠş(¯û?ğ!÷-¨+Öùxi#ß„rÔ¯ÍÃ8À|å#Ÿ!ß¸ãùÉM¢?ËãËïÏDıµ]~ó/€İqÎb!Î=Œøo}ıÏŸ#ßDå!ø‚ÇÄuUºÎ q/ä{H\#ı(ì„òôwÚçDŒÎ”›×æ#}ÚA:¾vøòùû.NÀï(¯À{ázÑóIoœøü2ï÷¶Ö"¬k€ËåÔß„<¯¡Æ®Oå˜ÇÍï¥vÖ’y\=4ÛÏkœÇı„—7·˜w+œÇ¸˜ÇÍ£†fã¥Ïİp¾Zå<®íI¸ÉîDÍGE¿æóx¥çKyq3÷®Êy\®ßbççÏïôòs¿Ÿù†È×âûÄü|]õïL¿'ög¥çÏş(ô×®D-øsŒ|÷zè‡û-œòıJêßŞïÕ™êÕthê'P.İwà÷r8•õÌ»Q)Í[ÿèÍÌO÷Sß‡®¥¸§CïåL¶@şt²³±âÁ‘CÅşÄú‚÷ŸnÂ¾]²ãGkÏOŠ¨µe¿äP½7ü~f÷‚Üğ›¼õ›ßW´C}ı†ùzÍ—Æ4òv¹øœ/½Ÿ¸è6â©ì'ÁUâxòú tŠ¡¿Òß•_+úAîï’=‘¯ÅwI/„?W×¢WÚö{-ÎYğ;|§Dµ¾ì¢êôMµ­¾ìì¶Õ×«²í6Ö7hãş/®NßJçéšïA¹Ï—µÍø.Y»ôÕÏk[}ÍÖ.}5ø³1§môuªŒWî«m;~-Ä«¤ôÖ²şÕÛ you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */

    // calculate mix and imix table values
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me =
      (sx2 << 24) ^  // 2
      (sx << 16) ^   // 1
      (sx << 8) ^    // 1
      (sx ^ sx2);    // 3
    ime =
      (e2 ^ e4 ^ e8) << 24 ^  // E (14)
      (e ^ e8) << 16 ^        // 9
      (e ^ e4 ^ e8) << 8 ^    // D (13)
      (e ^ e2 ^ e8);          // B (11)
    // produce each of the mix tables by rotating the 2,1,1,3 value
    for(var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      // cycle the right most byte to the left most position
      // ie: 2,1,1,3 becomes 3,2,1,1
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }

    // get next element and inverse
    if(e === 0) {
      // 1 is the inverse of 1
      e = ei = 1;
    } else {
      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}

/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0 <= i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */
function _expandKey(key, decrypt) {
  // copy the key's words to initialize the key schedule
  var w = key.slice(0);

  /* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */

  // go through the rounds expanding the key
  var temp, iNk = 1;
  var Nk = w.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;
  for(var i = Nk; i < end; ++i) {
    temp = w[i - 1];
    if(i % Nk === 0) {
      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
      temp =
        sbox[temp >>> 16 & 255] << 24 ^
        sbox[temp >>> 8 & 255] << 16 ^
        sbox[temp & 255] << 8 ^
        sbox[temp >>> 24] ^ (rcon[iNk] << 24);
      iNk++;
    } else if(Nk > 6 && (i % Nk === 4)) {
      // temp = SubWord(temp)
      temp =
        sbox[temp >>> 24] << 24 ^
        sbox[temp >>> 16 & 255] << 16 ^
        sbox[temp >>> 8 & 255] << 8 ^
        sbox[temp & 255];
    }
    w[i] = w[i - Nk] ^ temp;
  }

  /* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */
  if(decrypt) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w.slice(0);
    end = w.length;
    for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      // do not sub the first or last round key (round keys are Nb
      // words) as no column mixing is performed before they are added,
      // but do change the key order
      if(i === 0 || i === (end - Nb)) {
        wnew[i] = w[wi];
        wnew[i + 1] = w[wi + 3];
        wnew[i + 2] = w[wi + 2];
        wnew[i + 3] = w[wi + 1];
      } else {
        // substitute each round key byte because the inverse-mix
        // table will inverse-substitute it (effectively cancel the
        // substitution because round key bytes aren't sub'd in
        // decryption mode) and swap indexes 3 and 1
        for(var n = 0; n < Nb; ++n) {
          tmp = w[wi + n];
          wnew[i + (3&-n)] =
            m0[sbox[tmp >>> 24]] ^
            m1[sbox[tmp >>> 16 & 255]] ^
            m2[sbox[tmp >>> 8 & 255]] ^
            m3[sbox[tmp & 255]];
        }
      }
    }
    w = wnew;
  }

  return w;
}

/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */
function _updateBlock(w, input, output, decrypt) {
  /*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr-1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */

  // Encrypt: AddRoundKey(state, w[0, Nb-1])
  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if(decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d, a2, b2, c2;
  a = input[0] ^ w[0];
  b = input[decrypt ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt ? 1 : 3] ^ w[3];
  var i = 3;

  /* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */
  for(var round = 1; round < Nr; ++round) {
    /* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */
    a2 =
      m0[a >>> 24] ^
      m1[b >>> 16 & 255] ^
      m2[c >>> 8 & 255] ^
      m3[d & 255] ^ w[++i];
    b2 =
      m0[b >>> 24] ^
      m1[c >>> 16 & 255] ^
      m2[d >>> 8 & 255] ^
      m3[a & 255] ^ w[++i];
    c2 =
      m0[c >>> 24] ^
      m1[d >>> 16 & 255] ^
      m2[a >>> 8 & 255] ^
      m3[b & 255] ^ w[++i];
    d =
      m0[d >>> 24] ^
      m1[a >>> 16 & 255] ^
      m2[b >>> 8 & 255] ^
      m3[c & 255] ^ w[++i];
    a = a2;
    b = b2;
    c = c2;
  }

  /*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */
  // Note: rows are shifted inline
  output[0] =
    (sub[a >>> 24] << 24) ^
    (sub[b >>> 16 & 255] << 16) ^
    (sub[c >>> 8 & 255] << 8) ^
    (sub[d & 255]) ^ w[++i];
  output[decrypt ? 3 : 1] =
    (sub[b >>> 24] << 24) ^
    (sub[c >>> 16 & 255] << 16) ^
    (sub[d >>> 8 & 255] << 8) ^
    (sub[a & 255]) ^ w[++i];
  output[2] =
    (sub[c >>> 24] << 24) ^
    (sub[d >>> 16 & 255] << 16) ^
    (sub[a >>> 8 & 255] << 8) ^
    (sub[b & 255]) ^ w[++i];
  output[decrypt ? 1 : 3] =
    (sub[d >>> 24] << 24) ^
    (sub[a >>> 16 & 255] << 16) ^
    (sub[b >>> 8 & 255] << 8) ^
    (sub[c & 255]) ^ w[++i];
}

/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'AES-' + mode;

  var cipher;
  if(options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  }

  // backwards compatible start API
  var start = cipher.start;
  cipher.start = function(iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;
    if(options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }
    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}
