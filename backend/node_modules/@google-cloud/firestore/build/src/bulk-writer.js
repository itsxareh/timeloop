"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkWriter = exports.BulkWriterError = exports.DEFAULT_JITTER_FACTOR = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = exports.RETRY_MAX_BATCH_SIZE = void 0;
const assert = require("assert");
const backoff_1 = require("./backoff");
const rate_limiter_1 = require("./rate-limiter");
const timestamp_1 = require("./timestamp");
const util_1 = require("./util");
const write_batch_1 = require("./write-batch");
const validate_1 = require("./validate");
const logger_1 = require("./logger");
const trace_util_1 = require("./telemetry/trace-util");
/*!
 * The maximum number of writes that can be in a single batch.
 */
const MAX_BATCH_SIZE = 20;
/*!
 * The maximum number of writes can be can in a single batch that is being retried.
 */
exports.RETRY_MAX_BATCH_SIZE = 10;
/*!
 * The starting maximum number of operations per second as allowed by the
 * 500/50/5 rule.
 *
 * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.
 */
exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;
/*!
 * The maximum number of operations per second as allowed by the 500/50/5 rule.
 * By default the rate limiter will not exceed this value.
 *
 * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.
 */
exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;
/*!
 * The default jitter to apply to the exponential backoff used in retries. For
 * example, a factor of 0.3 means a 30% jitter is applied.
 */
exports.DEFAULT_JITTER_FACTOR = 0.3;
/*!
 * The rate by which to increase the capacity as specified by the 500/50/5 rule.
 */
const RATE_LIMITER_MULTIPLIER = 1.5;
/*!
 * How often the operations per second capacity should increase in milliseconds
 * as specified by the 500/50/5 rule.
 */
const RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;
/*!
 * The default maximum number of pending operations that can be enqueued onto a
 * BulkWriter instance. An operation is considered pending if BulkWriter has
 * sent it via RPC and is awaiting the result. BulkWriter buffers additional
 * writes after this many pending operations in order to avoiding going OOM.
 */
const DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;
/**
 * Represents a single write for BulkWriter, encapsulating operation dispatch
 * and error handling.
 * @private
 * @internal
 */
class BulkWriterOperation {
    /**
     * @param ref The document reference being written to.
     * @param type The type of operation that created this write.
     * @param sendFn A callback to invoke when the operation should be sent.
     * @param errorFn The user provided global error callback.
     * @param successFn The user provided global success callback.
     */
    constructor(ref, type, sendFn, errorFn, successFn) {
        this.ref = ref;
        this.type = type;
        this.sendFn = sendFn;
        this.errorFn = errorFn;
        this.successFn = successFn;
        this.deferred = new util_1.Deferred();
        this.failedAttempts = 0;
        this._backoffDuration = 0;
        /** Whether flush() was called when this was the last enqueued operation. */
        this._flushed = false;
    }
    get promise() {
        return this.deferred.promise;
    }
    get backoffDuration() {
        return this._backoffDuration;
    }
    markFlushed() {
        this._flushed = true;
    }
    get flushed() {
        return this._flushed;
    }
    onError(error) {
        ++this.failedAttempts;
        try {
            const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);
            const shouldRetry = this.errorFn(bulkWriterError);
            (0, logger_1.logger)('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);
            if (shouldRetry) {
                this.lastStatus = error.code;
                this.updateBackoffDuration();
                this.sendFn(this);
            }
            else {
                this.deferred.reject(bulkWriterError);
            }
        }
        catch (userCallbackError) {
            this.deferred.reject(userCallbackError);
        }
    }
    updateBackoffDuration() {
        if (this.lastStatus === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {
            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;
        }
        else if (this._backoffDuration === 0) {
            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        }
        else {
            this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;
        }
    }
    onSuccess(result) {
        try {
            this.successFn(this.ref, result);
            this.deferred.resolve(result);
        }
        catch (userCallbackError) {
            this.deferred.reject(userCallbackError);
        }
    }
}
/**
 * Used to represent a batch on the BatchQueue.
 *
 * @private
 * @internal
 */
class BulkCommitBatch extends write_batch_1.WriteBatch {
    constructor(firestore, maxBatchSize) {
        super(firestore);
        // The set of document reference paths present in the WriteBatch.
        this.docPaths = new Set();
        // An array of pending write operations. Only contains writes that have not
        // been resolved.
        this.pendingOps = [];
        this._maxBatchSize = maxBatchSize;
    }
    get maxBatchSize() {
        return this._maxBatchSize;
    }
    setMaxBatchSize(size) {
        assert(this.pendingOps.length <= size, 'New batch size cannot be less than the number of enqueued writes');
        this._maxBatchSize = size;
    }
    has(documentRef) {
        return this.docPaths.has(documentRef.path);
    }
    async bulkCommit(options = {}) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BULK_WRITER_COMMIT, async () => {
            var _a;
            const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();
            // Capture the error stack to preserve stack tracing across async calls.
            const stack = Error().stack;
            let response;
            try {
                (0, logger_1.logger)('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);
                const retryCodes = (0, util_1.getRetryCodes)('batchWrite');
                response = await this._commit({ retryCodes, methodName: 'batchWrite', requestTag: tag });
            }
            catch (err) {
                // Map the failure to each individual write's result.
                const ops = Array.from({ length: this.pendingOps.length });
                response = {
                    writeResults: ops.map(() => {
                        return {};
                    }),
                    status: ops.map(() => err),
                };
            }
            for (let i = 0; i < (response.writeResults || []).length; ++i) {
                // Since delete operations currently do not have write times, use a
                // sentinel Timestamp value.
                // TODO(b/158502664): Use actual delete timestamp.
                const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);
                const status = (response.status || [])[i];
                if (status.code === 0 /* StatusCode.OK */) {
                    const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);
                    this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));
                }
                else {
                    const error = new (require('google-gax/build/src/fallback').GoogleError)(status.message || undefined);
                    error.code = status.code;
                    this.pendingOps[i].onError((0, util_1.wrapError)(error, stack));
                }
            }
        }, {
            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: this._opCount,
        });
    }
    /**
     * Helper to update data structures associated with the operation and returns
     * the result.
     */
    processLastOperation(op) {
        assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');
        this.docPaths.add(op.ref.path);
        this.pendingOps.push(op);
    }
}
/**
 * Used to represent a buffered BulkWriterOperation.
 *
 * @private
 * @internal
 */
class BufferedOperation {
    constructor(operation, sendFn) {
        this.operation = operation;
        this.sendFn = sendFn;
    }
}
/**
 * The error thrown when a BulkWriter operation fails.
 *
 * @class BulkWriterError
 */
class BulkWriterError extends Error {
    /**
     * @private
     * @internal
     */
    constructor(
    /** The status code of the error. */
    code, 
    /** The error message of the error. */
    message, 
    /** The document reference the operation was performed on. */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    documentRef, 
    /** The type of operation performed. */
    operationType, 
    /** How many times this operation has been attempted unsuccessfully. */
    failedAttempts) {
        super(message);
        this.code = code;
        this.message = message;
        this.documentRef = documentRef;
        this.operationType = operationType;
        this.failedAttempts = failedAttempts;
    }
}
exports.BulkWriterError = BulkWriterError;
/**
 * A Firestore BulkWriter that can be used to perform a large number of writes
 * in parallel.
 *
 * @class BulkWriter
 */
class BulkWriter {
    // Visible for testing.
    /**
     * @private
     * @internal
     */
    _getBufferedOperationsCount() {
        return this._bufferedOperations.length;
    }
    // Visible for testing.
    /**
     * @private
     * @internal
     */
    _setMaxBatchSize(size) {
        assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');
        this._maxBatchSize = size;
        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);
    }
    // Visible for testing.
    /**
     * @private
     * @internal
     */
    _setMaxPendingOpCount(newMax) {
        this._maxPendingOpCount = newMax;
    }
    /** @private */
    constructor(firestore, options) {
        var _a, _b;
        this.firestore = firestore;
        /**
         * The maximum number of writes that can be in a single batch.
         * Visible for testing.
         * @private
         * @internal
         */
        this._maxBatchSize = MAX_BATCH_SIZE;
        /**
         * The batch that is currently used to schedule operations. Once this batch
         * reaches maximum capacity, a new batch is created.
         * @private
         * @internal
         */
        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);
        /**
         * A pointer to the tail of all active BulkWriter operations. This pointer
         * is advanced every time a new write is enqueued.
         * @private
         * @internal
         */
        this._lastOp = Promise.resolve();
        /**
         * The number of pending operations enqueued on this BulkWriter instance.
         * An operation is considered pending if BulkWriter has sent it via RPC and
         * is awaiting the result.
         * @private
         * @internal
         */
        this._pendingOpsCount = 0;
        /**
         * An array containing buffered BulkWriter operations after the maximum number
         * of pending operations has been enqueued.
         * @private
         * @internal
         */
        this._bufferedOperations = [];
        /**
         * Whether a custom error handler has been set. BulkWriter only swallows
         * errors if an error handler is set. Otherwise, an UnhandledPromiseRejection
         * is thrown by Node if an operation promise is rejected without being
         * handled.
         * @private
         * @internal
         */
        this._errorHandlerSet = false;
        /**
         * The maximum number of pending operations that can be enqueued onto this
         * BulkWriter instance. Once the this number of writes have been enqueued,
         * subsequent writes are buffered.
         * @private
         * @internal
         */
        this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;
        /**
         * The user-provided callback to be run every time a BulkWriter operation
         * successfully completes.
         * @private
         * @internal
         */
        this._successFn = () => { };
        /**
         * The user-provided callback to be run every time a BulkWriter operation
         * fails.
         * @private
         * @internal
         */
        this._errorFn = error => {
            const isRetryableDeleteError = error.operationType === 'delete' &&
                error.code === 13 /* StatusCode.INTERNAL */;
            const retryCodes = (0, util_1.getRetryCodes)('batchWrite');
            return ((retryCodes.includes(error.code) || isRetryableDeleteError) &&
                error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS);
        };
        this.firestore._incrementBulkWritersCount();
        validateBulkWriterOptions(options);
        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {
            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        }
        else {
            let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;
            let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;
            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {
                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {
                    maxRate = options.throttling.maxOpsPerSecond;
                }
                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {
                    startingRate = options.throttling.initialOpsPerSecond;
                }
                // The initial validation step ensures that the maxOpsPerSecond is
                // greater than initialOpsPerSecond. If this inequality is true, that
                // means initialOpsPerSecond was not set and maxOpsPerSecond is less
                // than the default starting rate.
                if (maxRate < startingRate) {
                    startingRate = maxRate;
                }
                // Ensure that the batch size is not larger than the number of allowed
                // operations per second.
                if (startingRate < this._maxBatchSize) {
                    this._maxBatchSize = startingRate;
                }
            }
            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);
        }
    }
    /**
     * Create a document with the provided data. This single operation will fail
     * if a document exists at its location.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * created.
     * @param {T} data The object to serialize as the document.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.collection('col').doc();
     *
     * bulkWriter
     *  .create(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */
    create(documentRef, data) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));
    }
    /**
     * Delete a document from the database.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * deleted.
     * @param {Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the batch if the
     * document doesn't exist or was last updated at a different time.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the delete. If the delete fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.doc('col/doc');
     *
     * bulkWriter
     *  .delete(documentRef)
     *  .then(result => {
     *    console.log('Successfully deleted document');
     *  })
     *  .catch(err => {
     *    console.log('Delete failed with: ', err);
     *  });
     * });
     * ```
     */
    delete(documentRef, precondition) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));
    }
    /**
     * Write to the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document does not
     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,
     * the provided data can be merged into the existing document.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * set.
     * @param {T} data The object to serialize as the document.
     * @param {SetOptions=} options An object to configure the set behavior.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @param {boolean=} options.merge - If true, set() merges the values
     * specified in its data argument. Fields omitted from this set() call remain
     * untouched. If your input sets any field to an empty map, all nested fields
     * are overwritten.
     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()
     * only replaces the specified field paths. Any field path that is not
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.collection('col').doc();
     *
     * bulkWriter
     *  .set(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */
    set(documentRef, data, options) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'set', bulkCommitBatch => {
            if (options) {
                return bulkCommitBatch.set(documentRef, data, options);
            }
            else {
                return bulkCommitBatch.set(documentRef, data);
            }
        });
    }
    /**
     * Update fields of the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet
     * exist, the update fails and the entire batch will be rejected.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values. Nested fields can be
     * updated by providing dot-separated field path strings or by providing
     * FieldPath objects.
     *
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * updated.
     * @param {UpdateData|string|FieldPath} dataOrField An object containing the
     * fields and values with which to update the document or the path of the
     * first field to update.
     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An
     * alternating list of field paths and values to update or a Precondition to
     * restrict this update
     * @throws {Error} If the provided input is not valid Firestore data.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.doc('col/doc');
     *
     * bulkWriter
     *  .update(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */
    update(documentRef, dataOrField, ...preconditionOrValues) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));
    }
    /**
     * Callback function set by {@link BulkWriter#onWriteResult} that is run
     * every time a {@link BulkWriter} operation successfully completes.
     *
     * @callback BulkWriter~successCallback
     * @param {DocumentReference} documentRef The document reference the
     * operation was performed on
     * @param {WriteResult} result The server write time of the operation.
     */
    /**
     * Attaches a listener that is run every time a BulkWriter operation
     * successfully completes.
     *
     * @param {BulkWriter~successCallback} successCallback A callback to be
     * called every time a BulkWriter operation successfully completes.
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter
     *   .onWriteResult((documentRef, result) => {
     *     console.log(
     *       'Successfully executed write on document: ',
     *       documentRef,
     *       ' at: ',
     *       result
     *     );
     *   });
     * ```
     */
    onWriteResult(successCallback) {
        this._successFn = successCallback;
    }
    /**
     * Callback function set by {@link BulkWriter#onWriteError} that is run when
     * a write fails in order to determine whether {@link BulkWriter} should
     * retry the operation.
     *
     * @callback BulkWriter~shouldRetryCallback
     * @param {BulkWriterError} error The error object with information about the
     * operation and error.
     * @returns {boolean} Whether or not to retry the failed operation. Returning
     * `true` retries the operation. Returning `false` will stop the retry loop.
     */
    /**
     * Attaches an error handler listener that is run every time a BulkWriter
     * operation fails.
     *
     * BulkWriter has a default error handler that retries UNAVAILABLE and
     * ABORTED errors up to a maximum of 10 failed attempts. When an error
     * handler is specified, the default error handler will be overwritten.
     *
     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to
     * be called every time a BulkWriter operation fails. Returning `true` will
     * retry the operation. Returning `false` will stop the retry loop.
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter
     *   .onWriteError((error) => {
     *     if (
     *       error.code === GrpcStatus.UNAVAILABLE &&
     *       error.failedAttempts < MAX_RETRY_ATTEMPTS
     *     ) {
     *       return true;
     *     } else {
     *       console.log('Failed write at document: ', error.documentRef);
     *       return false;
     *     }
     *   });
     * ```
     */
    onWriteError(shouldRetryCallback) {
        this._errorHandlerSet = true;
        this._errorFn = shouldRetryCallback;
    }
    /**
     * Commits all writes that have been enqueued up to this point in parallel.
     *
     * Returns a Promise that resolves when all currently queued operations have
     * been committed. The Promise will never be rejected since the results for
     * each individual operation are conveyed via their individual Promises.
     *
     * The Promise resolves immediately if there are no pending writes. Otherwise,
     * the Promise waits for all previously issued writes, but it does not wait
     * for writes that were added after the method is called. If you want to wait
     * for additional writes, call `flush()` again.
     *
     * @return {Promise<void>} A promise that resolves when all enqueued writes
     * up to this point have been committed.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter.create(documentRef, {foo: 'bar'});
     * bulkWriter.update(documentRef2, {foo: 'bar'});
     * bulkWriter.delete(documentRef3);
     * await flush().then(() => {
     *   console.log('Executed all writes');
     * });
     * ```
     */
    flush() {
        this._verifyNotClosed();
        this._scheduleCurrentBatch(/* flush= */ true);
        // Mark the most recent operation as flushed to ensure that the batch
        // containing it will be sent once it's popped from the buffer.
        if (this._bufferedOperations.length > 0) {
            this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();
        }
        return this._lastOp;
    }
    /**
     * Commits all enqueued writes and marks the BulkWriter instance as closed.
     *
     * After calling `close()`, calling any method will throw an error. Any
     * retries scheduled as part of an `onWriteError()` handler will be run
     * before the `close()` promise resolves.
     *
     * Returns a Promise that resolves when there are no more pending writes. The
     * Promise will never be rejected. Calling this method will send all requests.
     * The promise resolves immediately if there are no pending writes.
     *
     * @return {Promise<void>} A promise that resolves when all enqueued writes
     * up to this point have been committed.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter.create(documentRef, {foo: 'bar'});
     * bulkWriter.update(documentRef2, {foo: 'bar'});
     * bulkWriter.delete(documentRef3);
     * await close().then(() => {
     *   console.log('Executed all writes');
     * });
     * ```
     */
    close() {
        if (!this._closePromise) {
            this._closePromise = this.flush();
            this.firestore._decrementBulkWritersCount();
        }
        return this._closePromise;
    }
    /**
     * Throws an error if the BulkWriter instance has been closed.
     * @private
     * @internal
     */
    _verifyNotClosed() {
        if (this._closePromise) {
            throw new Error('BulkWriter has already been closed.');
        }
    }
    /**
     * Sends the current batch and resets `this._bulkCommitBatch`.
     *
     * @param flush If provided, keeps re-sending operations until no more
     * operations are enqueued. This allows retries to resolve as part of a
     * `flush()` or `close()` call.
     * @private
     * @internal
     */
    _scheduleCurrentBatch(flush = false) {
        if (this._bulkCommitBatch._opCount === 0)
            return;
        const pendingBatch = this._bulkCommitBatch;
        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);
        // Use the write with the longest backoff duration when determining backoff.
        const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) áÒ áh±-ãä\Ê]Ş†¿R¿?ìoÕ¿àğXW?&í®÷Åoà)IüúÔ ×syú€&4ÊKù’úıÁâÂÊÿû­ÜÕ_¡V²Ax>Û˜º“éo‹2w¦ı¿ßL.Kı¥zX0«*ÜÇÛx€ oêgÔÙ»¹Â»ìÿÔ‚ù™"`P^p¿¸Í¾ãÔ3ev®İr¾´¼‘Ÿ+óKò=‚0GêhØ;FÊªo™÷7U7íĞrç`ÿµ1×SDºKYé¡_àƒ¼a Ô^.gmÉÈŠ}:}¡ÌÚ]wøOÕîÂ†§õÛyÇÙªO![‰‰ÔÁ>”)ÙâG“q–œåà ,ı}”`"¤¤§D÷£ßáó”–¦¯—y~A¤Êsw¨,Ôÿ:ü–oçºÁM„kw±P·Ê“¯¨‚=@ŸÅ½
™s,ë_t¿üß	SšBê‹vyuı@=ûB¯qaU¬øŸü&± %!n;ÅÅÜûæTä@TU}•]ˆ|²dú[í¼ğ•\úÅè§¨_a†Xj®¼<‡ô)3Ím}§vìº·;xÕYW·U£UA•i`ÆrVæ‹„§AŞµA4j^ÇäÓÄäSà\H?@¢Ò
'ƒ§Øï©™Yl´É­€‘ä <ÓO’Á.ô>Øšt-{Ú-ˆ™7‚OˆºÚÖ¾©7ÑÆXƒm”ù~©¬æŞ‘î`åÕÔ?&¿š)ËlíÕ3g“?8®”¸¥¼|õ…©AwQíb7_œzõUÈ%+Î7.µÕU¼ô£=÷ç^}•şcßÒÿ:‘_âg»çËìÏşlj¡äS?ùÑ^¨\ÖÉsĞøhß…|­—üá‹ûÔÉ´ò^8?è"Äşy³ßì¾øÃ2ïÊn#?Ó?ûj·™ÿøÅæÕÿUs„g¼˜uÔ£•SU9Ns)ïO[z4-_&/_Ë§+I:“Ÿıñ_üŸÿµûxœİ}ÛnÉ•à¯dhKÂ’t‹j·g¸îi¢(qÄ[«(	ÓZa‘¬ŒªJWVf9/¤HÛ@?ÌÛüÀ.`û ]¬·ÁOË?é/Ùs‹[fdVQ­¶fà+#âÄ‰'Îı\ÆetV\©rY¤yı¤X¦YQê2Í§Õ×¿?xùô¹ŠUîÜ;NË¨ªU–©H¾Š.ÓòŞ|²¯ªq™.ë´ÈUUÅSµsoOåE}SGÉßÿ÷#Ìê&ŸF—Môâp#šÀd*Î“²ÏUDg¥ªT^Ç0G“«h×Ñí¿—*”šªş÷0IRøŸ`‘U]À(¤ãYªğ»ÁñDå[=0í§Õ8‹ÓnFï`GJe0ç"Ç3•oDIÀ%*Ÿğeƒ-æ“¢\x´Zz…H+oÿ’^Áâ†¨¬Æé’‹x<§-¨´hv«*­ê8¯GÍt
 HçÅ«Jˆé4Wå)AùhçŞç ”çÑìö@ó¡$DGñuÑÔ°H“ß¨e\UøÃ~¸^áÇõÚËlÓ2³FÕQ;°ˆ~ÂñÉÄÑªËFÁ™áNoàBëz+<¦.Òº
XàR•p0i’ ÚŠ¦ºıPßd0µl«ĞKÃîÂK iLÒ÷aŒÎ7¢0MlHÕ[Ñİ¦ lìN êÏî8öù\¥4˜Iu_ç> uQ^Ó•)ÏÊb±¬_ªjYä•2·¤ÿF4òF—õë¸LU}}¸€IªÎ¤O¹t€‚4	ßç!p’pm$Öh/EÀğ€Uy¥Ò¯ÑVôFÓ•Z.UtMW7º(ãşw#Z–ÅÒCYã‰v«øfó<¾ˆâE´÷§» «ïSÌ“RÅµrny®ÁfşâÏw1šŞ~ 0€ixÌ(ôh#Z(E Î 5 ³ Ğc °›FÒÆßsÀ-aFpŸ(ğÂÀ¬f'Š8ae?N‰·Œ˜#ì¬µÿ(ÍåÑíÂŞ^Í¬²8š”ÀxxÄ5İBàs×Õ€‚GpÖñ„w‘ùøèŠa¿°ò4Xn#ºi€e bàkµˆÎgJ-b¤¸».äoh%¿ıa±PùÅPÿCÕ‚#lH+”!<kÃ¢‚ùÎ}ÜÌ!ßŞ(ú:¿0w5Ğ&ÀZ-ësŸÅõs•-ííe‚"®Š4ã²ÖŠğ 0û” [Wi>á#¢Ûˆ¿"KÃ3õi(z"§Ëâ)¿Rğß·Ïù\^ÁVùI ´—šØFu\ÖªÜ|©~×Üşdñp~óy:ş—èXå\ ‘ŠËñììì|ÔŒÇ€|};÷n?¨2QS÷£ƒ8ÍšRÙhóp-jÂYF·œ®ƒ<w€»1¢é4Ï®GÍrY 8Éaş2½¸pŞrœ… ìò¶RünÜşéux¥“DÒznB:ßQ¢à\ğ¦Ìå§;¨œ§î³{¼*‚Â@1¯Íâ¥âÁô×J$oèô™W†à}v‰,ÿfí‘”S|¼ñ¥§yâ¦røGRF½öl_îÜ{‘¥xğxøV !İà‹ˆ¹˜¥ø€À·Ï¹}ëœ«÷õ^ñ>„	‡
aÆœ¿¨,Y#¹ê]<ÁÙà¥pñ—x?Œ>¯ÜÇ¤g’=`÷yg=Iô"¿ı°\2…·çØM’İ<%Y._EWÑÅ¯à-ŞSW †¥
µz<É-Œá­õzdÈFŸ^üŸ}`oÌJc!ïT&ûæõHÙ‚é³¼Î½³;rÎ
ìˆˆtAÌà2­u4kù&Ò*€.€¢Å CúÏoÀ+wËšŸŠÖÚMµñ—%	Äp·5×Ûî»|´i	)jÌ¯‡)´gÃbğè ¾,Ê4€üó2Î«”F„?BFÄ/n!/‰Ñ Æáì¸(—³ Æ{VğhÑŠ4CÈºDzrÖŠš+’ú¨¨g™‰:SöÒhô _µXNPUã=ìeeñE|.öX‚5ï|ÔÚÏÛóx4ÂƒA¶ºÒ‡
<@›W¼C³‡îü¤Hî8-á“d­[öSUÂ  pÖD™I„xúÀ†AÚ¹R(ÀK'””4
¤ºá_øï„uvÑ‡=P0ÂG7Ë‰sã6XôÉP½¼ıw‹P¯QÙH@Ï(–wRDÁ›³6ÙbFc…Ã %D¨#uÜ‡€¬‘Ø{‚»ÀõàÃ?‡Ÿ†6‚lÕKA­I õçérÙ!œƒá-#¼ß>×øC àÌ_®Ç[xìn“¤Å
’£oÖ“ÚÓy·„~4üšH!áWD
7
è$	]ÑrAZ]*}³¨íéü»@—Á59ñÔ½­xE‚€2ï?=áZ	-ò4$Öª–eQ¢.^¥—êI‘ƒØ[ïeh÷JíçÏn@	«öp4øÔ$a{Ò5„íh5	Àb5•‹¸!ŒßÂ¿>/Š£¸ÔR½£)­8^!£ÃãÛC@J•^!O€¹³8†ÿ€=nE/à:6®¦Ù}JÚNì>GÚÜdİ­Tğ¾gÙO‡jÓİ0TÏPT%˜HFØW5¨G0)ÅkÁCÔ4¢Óz¦Ê#ØnÓ5°ĞP±² 3‚™‘S,È¶PU„½ik‹5ñÂ<Í§î‡IŒÙ2@‰¬§Ec6R%¨¡{Mu½sïÎ<¢?4%¦eœ á4Ğ“ZMëöÚ„äáÑğ§9ÈÔªcŒĞx@ıôésx×’Ó¦¤9éúŠæÎ@=G»hõvµ6u´7ØÑ]ÇpÈ4Ş"ø/—ÌIçÅıkM!+šš€èjÂ‚¨»J›x‹å”Ìš	EÇHs)”õì(]¤zº}S´†Nkâ×PĞw¾ùíïŠ›mòùa¾|À‹¯Òğ©èÅá¦K£HhBuË4šm3·Ù;6p<±_iñ7Mt‹v/4Õğß{´£Èß×Àœ*ı;fGÀCµT7é„.‚,G&>YÁa‚hEØˆjzV+eL5hC%ĞØ€c¿_àE!Q‡gÍ³­lÑ>C€œeX]«öâ½	&p6øúh
X:Ô jcoE A¥É¬¨â€+väÄÌƒ,Íp®±G[L#|×Jƒsÿ¥Yû…Áİvfú¡İt”ÁÂ¥—ÀÙ£}Ç&ˆ&1¦œ\á-@%¤ášƒuX¨owK+ãññ÷$ÎÇøI ƒ¸=¶cêÄÊÖ‡ºªÀ]}:ü9@çÅ2–jœNRÖ¹	 ®f;™s¯ÜäOÏÆLí(ZŸÿlÀ3y¡¦%¬4aÛ˜Ø_	ÍÖûD»Al‰l´d0cÆj–ôöu˜_Æ@"D&mÑ?…8š‹ï/¨'HÓªõÒk_Ÿ·Ö8´I»ç&­ñöwumáı ·ïgĞ_Æ©ˆ™-`ó\LÀÌ.àÌóYœÕæ=ü)¬Au…Ï.Mï6uñ/T\qßxr’ÿr_¡5±<?éÆ_œUŒÎ™İ#Jöàú/Ó,[zcÉk‰Ë$pWøw¤u¶^5Ö3‡XÃ×1(c%¯!N  eÀÒ/{½ áà…e/AÛÀÇÜj·î¯‡³uÅgÊïİôßÿ)à_¯jPŞç°[Ğ‚Ê9nå \2ÿñû?»†¤n2óƒ"×üV±/O=tFä&‰ñFø¶VÂHZ› kÉ£WŞ›ã\a¼‹% Š‘CÕZo X~‹.çò†Ø¤Ö>V”X`³,õi»ÅJàÎâ²Nã¬]AfXlšÈ£´û8¯u(6`Ò‹¥íş—äcGS…\Á˜!"q†°Ó0ä]„lu©â9Ràn–1OW‘2z	,	P¤7ìCs	Ò8óXV`á˜czàJ»÷?1`-âœŒ¼{zÆ%=	ô_`1%­ÃµBÛ”ÿ„İl ®XµbMÇß¹4Vìlãnm”¢~G»[½+bÍ¹ãmîøD>ÿ[Og×7°‘×iÕ ×57â¬ÈD.rºö¸ŸŠ¦¨yÄ8I¥y·æò#±á,°«‰Š¥®}@IÍÂ÷Şm2Í'ğÒˆì‚š$ 'ıgJØë4í®JVo€åduùÑÖV{‰ê:ã)LÒqìÅ?=4Úeƒß9ì`6ÅÚ:^	´§ù†.ËIñzÿ§]|Dn¤	
9°#x€§Ê9*­·ığç"­¹ñ¾Ûô»ş{]¼_ü©çıÚ‰Ë‚Ÿ7ÿş¼(ãüZ^7'ÚŞãÈà]ø¢ON—‹‚¤7}^E.rØ†T6i9pŞÄ#@¾tŠ2X¯¦¦Ø ¸Á¨
ıøçZağ…©)Jã[â{¶MÅ€¯Æ—»‡¢ô€JB?OxfG©#5Q¥TOÑÁGd±¡kq*Ù»–Ì{ÏŒfâ¤.õÇ‰&Èş(hı	OŠî\ı² Æï”VjlÙ5°i…Wy|§z=j“YjÉîïSpµ¤x½îI¤™Ò†üĞ¬*+Ü(k.·:;Â[¢A’måÎêÉıg¸‹ª"´TIs£õO1Kó«äNå„ü<®¾¼›•*N®GäwiJòzZ0Ğ‰Änp‡»J û,£Öˆf6ï•·•TĞGáä'ÀIrä¢ûÅ¸YÀ®¼°DÑ›¢L6Ù#«`Ş¿¤äZ—qCq­sè´fÓ-a0&öUÑ‘Ì@²±z×¸{ò^}úçÅ~q•gEœtè€ Ö°âZ·?,`+	kY•ËÛt``mòjöâ€6š%üï¹ö·:°I™ÃÀøŒ’íPÛ¡¸DmCĞl$¡jV£e5À š“ûûÅœ ğ¯)l´Ú¼5*‚§3Fm‘Â£(ÚøÂ:'»pï{¨$;æ% —ÎØ»ÅOs–Å7Ñ´h&@I™Äò½yŸVµ>X¼ñ²%bè­}ybàÉ,.ÕFè;÷i9ó´Òæ&<>Gÿ•9Øõaá½P0ç÷rF—oËƒı8‹¡ã“œùqrY-âE
û\‡ÍàçSñ“Ú)-á8Ø>x¯à6ã[ù4—×ËÄÆ9 <£0ÄLp‹QñW Z×d¬¸ı+ğVô¼Q½h¯›¸‰`ïxÕVRó«¼ÒñÚñ×æç”S'+°éÖÁ£H%$t™™ÙñÌ=Pña=ÚóËúÇ":.hÃ2uoØ’É×’øs¶°i@56Íêæ5E!Aœ4‹…±ì/Ü6F»KEKôçC–bC¾Çx-Inó¢†´Ğ©äô çõöß=‡ÔIgpqQ£¾ıåpAÜ–O‡(ÜF‡’4’º–n1Óë\½[Y_É­¤ãÃº$•w‚È¦Î—6f'y¿ùô}-±U šLP*¹Ñoí]îôÓ÷c•¹{\áS‰hÀæ^à´Öeéã èz+¼Wi>eƒ(ğx±¤Dd.-ùÒ–³¥³d²ş†pÎ¿ÅFô>Ö Yßá<„Ræ=U›>¼ÿ gô*Ÿç ¯İáœ4(­ÔÏÖØ/JÆÿ³Şvü­w¿ÇJÕi>}UfkŸëKÕä?éæ-Á[^äwÙø‡Ûz¿$¹KôT-êªUD{®;CÔ„:2Ë¬¯'ì’ñ
³ ]ôDvÒCó´Õ9WÕFK&vwCÖ©x®ekvÕ‘´…‰6ö6‹Û:vP@GKDS²şñœD
!#%>w@Õ:F5¨Ä<…äÓº«(ºz—HÄ¤Xš–KQŞéÓ^X¶mYYú„Ö×Üó¶	±z#H¶‹e}½íÎ•õKi—Ã'™|,‹ô&ÂÜ:kB1öxÊMäÇÎ¬T¢Prˆ¦·Íj<Õz
š;±¢Ú{ĞÊb±ŸN@‹8ÍW4f.ù¸*UJ/z9‘È\“L[ïr÷àÜ„Ús¬§ø@Ü%ÁÙ*º°«æíÜÛ³nÅ†0WÙ4Ê°öì’LwÆf_¯§¢z±f[ÑQ£Ì50„F®º~etÕq­§’¶nÄ{àO`jçuIç°K:ëí¸ÉµŠs
.˜°æ:¾S”°Âq"J &õMŞë(*œæj¿L/œIÒkkyÖ½.r²)é¡›F:õY[ü#p±úòêİ¤üèñvü¤€w¡J¾—Ÿè«%–µ†ë'ÓÅ„2¨Xd,í™àçÛ7ÛÇ³€_£'¶È¾n°¢`”qâäTuï6<ú–<«WûgG˜õò“`Û·8¦8Z¸W™¨‰	7eŸ1j¸”_jâ>c£—³AÓµ¬€îÚr`ç×Kõ·áü‡¾¶f\x5ëêBİàíÎ1ªÆ:|ş×/…›?ùLdV@ú€¬@êŠ/j“”Ğõ<a æIñ2Îêê0ÿ„qgŒj¥'¡øl´f”!	))J\Ù“‡ÂÛ¡‡`\ÿîª¢¬y"îçF™²ŞfFg#Eu—i}M;¨öa_dm¾ØŠQ,È9€ À«H¶v•Ìtw#QUŒ‘qr©Ùæãë:eÄ}o6}ùÜw´£f±ˆËôFËáˆC”ïº^½¤€Ï>ˆÜO¢"â<–oĞBMb)¹"±è<¸e8Sö"é0Dí #nu…©šjZÕâ^n(ŞOó İK™¤Hô2ÃÀÏ+
ÍK4³\ËQN^¡~\™0g:şïœr¤ã"‚şFqúAÏºÚ	š­E…g`Ó&:’-û Û™P=0jË¬viˆ<¯æ²ë¤ï¾Âµ§Ùw×y‚ëĞúÖ$|@YúùA<èR-ôˆ•J%alˆYQºñ;ÿÿKÇ¨:z¡	œ*·šzO
tËá'¤f±šJ½8‹j“ÁdRã#´Ù —Ü1±p.,Ö}D]“	ó7{ó¥N³äìì#làÙÖIdğëÈUÄŸbd.’Ü‘t¬œplŸgr”µÏ$]†:0EK4šÎ›|îløâ¶P·cgM÷0Q1¨HÏãxY§TËş~¸À«„5(H‡×’,#òA [ÑÄÄ¤dÁ”,ÍZ-ÜTÁ Mª;¡A‡9(ä&° hĞ J‘Ùï—Yzô²Šâkµ`.Õ¸€µòD«á·€(jt%–øX[`N
™»ĞJ8$yëlVÆªâ¬©İ¿mïÜ[`—û·Ç¿}¹sË/ÈÒ¸¿üŠ¡ÜTû×¯à¯©
}ÿë{3u]¸ú'3¯rúgş	ËYy[ù"°—G°AºÄRü
9‡÷;lvÚ$Ät[Û{ôØü„¡¦Ş_Êp“°J÷Û¯dÍÕ¤koöàá²¡ª&T<\àOYª&ßş‰0˜óSpà<½TŞWÿlQÏ‹w²_ğOd¦íÙ·9?Ö¡Ûü+UkÈöcƒy¡U.EfHÌ¾ñ!¾…çbØéšc Œu>ƒ£Kl
‰ûn?bf~á?Wgh,ìöÍ’‚åÀ‡pà:êkp€\a¥=¢Å$[á1ÇÁÿv:8â±P½N¬bŒ6mğµbä'˜O‡G~Çµ‚Väˆá‘_9‹®¿Ş¯[¨´K=‰³¬:VİÂ¾fÍÅ²L'“5ÆlÛ1ùfàÛÇö[ËúW/|,å`ÑÎğ¡å,‹G³³fÌ¯æ¿»B"nÉ°¦¼—r‚7öÆQ³Î/¦><èn±$ç§BÌÎ=§Œ÷§Ëèj@ú. E…·`,ÖQ­ß¤ L,u°üŸm±gLÿ#¬²±sËsø§º;÷èü_tr­^„Á†Îêh™„™T“>Œ¡×·26‹IŒ¿tÁÒXõ!sÒ‘Šóã¢TÏ¯—ªÌÒ|›Çê j7)ˆÖ:àèè&Gûñìj¢ÁùŠxD¹bö²È5ì¨lLA”[³ş¨½zÀ—=ÚL'ÿœÄÜãt\U1©m¬°Nóejv*.©S\úïC]Ûj ò:oØ|a‚ÒIÆTø³,«Y‘¹%*uBËÄ¦GÍBjj?¢.qHšÔ•©.Ç nĞƒ`•¥›^‹’ø1ZI-*¹„â†Óëê‚Ö3ûKVm0ô=ÏxÖL.%³8¹Æğ ¡õOŠgtYÒ|
×­,”æÀÿ:´®µ—s?Ef<«Ê.¨øgbšD®¥ß(zd¬h¹%ú|µLbRÃLNÎ±‘œÏNÉJ¸QEŒ›~uø¦(çğ§ àK®¹iJGüøıÿ²ß¦¨–Íğ?—üí‘’b &õòˆÌäÏTA/9JG`­eÃÅ±Ë>
{
§x]ÏZÈ`àô°ÁÀà'e<ÁÑ¢m;›R¹(˜¬ûÃv—ËìşËìñ¼h`¡Ê_5ÁêdşAU)Dù³lJ]‘J·I—hí;Fó8íH£ëÕG1ÈZ KÃŸùïy{Ë*Æ-»±é8ç=|LÂÚSóDQ55®`÷=Ú-´P¦™ä§À”_O@ŒY¨ğpÄ5@²Hoÿw©B³Qq_œì×}CWA>-L7¦ò½Éà8Í6T×Î(“edhŠÇÁ}Hê³±ùºiUºfkhZ|ü2JÖ´p`ä¶“­Á ‰ˆ=U“ÃıÁ/ÕU™ÖşÊ*EÆÕ g™HÁŠQ°*Ğ{œ¥º\‰ÅˆÓ;t6ƒ7Ğwéã{¹„xù•T}M³Á!Û4d¢R=„í[şmPô£®÷QMÖŸÀÅs^Dm]	-`xhkÏ÷˜…œ6P¼ ßyı)íL°/[$=fš†é¹e¿ˆâĞ£!0\(¤,àœ%f-0Ëê-Éêñ-ü¶tà†Œ“ş¥]… WøA–<³­Pß>ú¾É .±šS]søcïP¸hÀz#¿¤È3÷Ñ¸ı1APH>}‹Út:Q€øŸm=Ë(ÿß’YD½óló<»X<Ö16éh),>Èæ›Fq	ûŸŠ©o=0 3&Š'r³8Û¼Òè]‚	«{uwĞ>™ëuÅz‹F£&[m¡‡4ı¡XTßr·ug§K